diff -uNr linux-xlnx//arch/arm/mach-zynq/board_zc702.c linux-xlnx_xfb_14.1_build3//arch/arm/mach-zynq/board_zc702.c
--- linux-xlnx//arch/arm/mach-zynq/board_zc702.c	2012-05-15 03:09:09.000000000 +0200
+++ linux-xlnx_xfb_14.1_build3//arch/arm/mach-zynq/board_zc702.c	2012-07-09 15:12:26.676292000 +0200
@@ -27,6 +27,7 @@
 #include <linux/i2c/pca954x.h>
 #include <linux/i2c/pca953x.h>
 #include <linux/i2c/si570.h>
+#include <linux/i2c/adv7511.h>
 
 #include <asm/mach-types.h>
 #include <asm/mach/arch.h>
@@ -216,7 +217,23 @@
 };
 
 #endif /* CONFIG_SI570 */
-	
+
+#if defined(CONFIG_ADV7511)
+
+/* Initial ADV7511 DVI output format is set to RGB */
+static struct adv7511_platform_data adv7511_0 = {
+	.format = "RGB",
+};
+
+static struct i2c_board_info __initdata adv7511_board_info[] = {
+	{
+		I2C_BOARD_INFO("adv7511", 0x39),
+		.platform_data = &adv7511_0,
+	}
+};
+
+#endif /* CONFIG_ADV7511 */
+
 #if defined(CONFIG_EEPROM_AT24)
 
 static struct i2c_board_info __initdata m24c08_board_info[] = {
@@ -273,31 +290,36 @@
 	 */
 	xilinx_init_machine();
 
-#if 	defined(CONFIG_SPI_SPIDEV) || defined(CONFIG_MTD_M25P80)
+#if defined(CONFIG_SPI_SPIDEV) || defined(CONFIG_MTD_M25P80)
 	spi_register_board_info(&xilinx_spipss_0_boardinfo[0], 
 		ARRAY_SIZE(xilinx_spipss_0_boardinfo));
 #endif
 
-#if	defined(CONFIG_I2C_XILINX_PS) && defined(CONFIG_I2C_MUX_PCA954x)
+#if defined(CONFIG_I2C_XILINX_PS) && defined(CONFIG_I2C_MUX_PCA954x)
 	i2c_register_board_info(0, pca954x_i2c_devices,
 				ARRAY_SIZE(pca954x_i2c_devices));
 
-#if	defined(CONFIG_SI570)
+#if defined(CONFIG_SI570)
 	i2c_register_board_info(1, si570_board_info,
 				ARRAY_SIZE(si570_board_info));
 #endif
 
-#if	defined(CONFIG_EEPROM_AT24)
+#if defined(CONFIG_ADV7511)
+	i2c_register_board_info(2, adv7511_board_info,
+				ARRAY_SIZE(adv7511_board_info));
+#endif
+
+#if defined(CONFIG_EEPROM_AT24)
 	i2c_register_board_info(3, m24c08_board_info,
 				ARRAY_SIZE(m24c08_board_info));
 #endif
 
-#if	defined(CONFIG_GPIO_PCA953X)
+#if defined(CONFIG_GPIO_PCA953X)
 	i2c_register_board_info(4, tca6416_board_info,
 				ARRAY_SIZE(tca6416_board_info));
 #endif
 
-#if	defined(CONFIG_RTC_DRV_PCF8563)
+#if defined(CONFIG_RTC_DRV_PCF8563)
 	i2c_register_board_info(5, rtc8564_board_info,
 				ARRAY_SIZE(rtc8564_board_info));
 #endif
diff -uNr linux-xlnx//arch/arm/mach-zynq/board_zc770.c linux-xlnx_xfb_14.1_build3//arch/arm/mach-zynq/board_zc770.c
--- linux-xlnx//arch/arm/mach-zynq/board_zc770.c	2012-05-15 03:09:09.000000000 +0200
+++ linux-xlnx_xfb_14.1_build3//arch/arm/mach-zynq/board_zc770.c	2012-09-18 10:58:49.272070000 +0200
@@ -21,6 +21,24 @@
 #include <mach/hardware.h>
 #include "common.h"
 
+#include <linux/i2c/adv7511.h>
+
+
+#if defined(CONFIG_ADV7511)
+
+/* Initial ADV7511 DVI output format is set to RGB */
+static struct adv7511_platform_data adv7511_0 = {
+	.format = "RGB",
+};
+
+static struct i2c_board_info __initdata adv7511_board_info[] = {
+	{
+		I2C_BOARD_INFO("adv7511", 0x39),
+		.platform_data = &adv7511_0,
+	}
+};
+
+#endif /* CONFIG_ADV7511 */
 
 extern struct sys_timer xttcpss_sys_timer;
 
@@ -31,6 +49,11 @@
 	 * specific
 	 */
 	xilinx_init_machine();
+
+#if defined(CONFIG_ADV7511)
+	i2c_register_board_info(0, adv7511_board_info,
+				ARRAY_SIZE(adv7511_board_info));
+#endif
 }
 
 static const char *xilinx_dt_match[] = {
diff -uNr linux-xlnx//arch/arm/mach-zynq/Kconfig linux-xlnx_xfb_14.1_build3//arch/arm/mach-zynq/Kconfig
--- linux-xlnx//arch/arm/mach-zynq/Kconfig	2012-05-15 03:09:09.000000000 +0200
+++ linux-xlnx_xfb_14.1_build3//arch/arm/mach-zynq/Kconfig	2012-09-18 12:36:23.634547309 +0200
@@ -42,6 +42,18 @@
 	  in many cases. This may not always be the best performance depending on
 	  the usage.
 
+config XILINX_ZED
+	bool "Using USB OTG on the Digilent ZED board"
+	default n
+	depends on USB_SUPPORT
+	select USB_ULPI if USB_SUPPORT
+	select USB_ULPI_VIEWPORT if USB_SUPPORT
+	help
+	  Select this option if using the USB OTG port on the Digilent ZED board
+	  as a USB on-the-go port. This option is necessary to properly
+	  initialize the TUSB1210 USB PHY used on the ZED board as an
+	  on-the-go USB port that can supply power to a USB slave device. 
+
 config XILINX_TEST
 	bool "Testing On Kernel Boot"
 	default n
diff -uNr linux-xlnx//.config linux-xlnx_xfb_14.1_build3//.config
--- linux-xlnx//.config	1970-01-01 01:00:00.000000000 +0100
+++ linux-xlnx_xfb_14.1_build3//.config	2012-09-18 12:42:13.418547264 +0200
@@ -0,0 +1,2110 @@
+#
+# Automatically generated make config: don't edit
+# Linux/arm 3.0.0-14.1-build3 Kernel Configuration
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+# CONFIG_ARCH_USES_GETTIMEOFFSET is not set
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+CONFIG_KTIME_SCALAR=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_LOCKBREAK=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ZONE_DMA=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_VECTORS_BASE=0xffff0000
+# CONFIG_ARM_PATCH_PHYS_VIRT is not set
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_HAVE_IRQ_WORK=y
+CONFIG_IRQ_WORK=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_LZO is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_FHANDLE is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_HAVE_SPARSE_IRQ=y
+CONFIG_GENERIC_IRQ_SHOW=y
+# CONFIG_SPARSE_IRQ is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_PREEMPT_RCU=y
+CONFIG_PREEMPT_RCU=y
+# CONFIG_RCU_TRACE is not set
+CONFIG_RCU_FANOUT=32
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_RCU_BOOST is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_CGROUPS is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_SCHED_AUTOGROUP is not set
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_EMBEDDED=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_PERF_COUNTERS is not set
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_COMPAT_BRK=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_USE_GENERIC_SMP_HELPERS=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_HW_BREAKPOINT=y
+
+#
+# GCOV-based kernel profiling
+#
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_STOP_MACHINE=y
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+# CONFIG_INLINE_SPIN_TRYLOCK is not set
+# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK is not set
+# CONFIG_INLINE_SPIN_LOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_SPIN_UNLOCK is not set
+# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_READ_TRYLOCK is not set
+# CONFIG_INLINE_READ_LOCK is not set
+# CONFIG_INLINE_READ_LOCK_BH is not set
+# CONFIG_INLINE_READ_LOCK_IRQ is not set
+# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_READ_UNLOCK is not set
+# CONFIG_INLINE_READ_UNLOCK_BH is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQ is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_WRITE_TRYLOCK is not set
+# CONFIG_INLINE_WRITE_LOCK is not set
+# CONFIG_INLINE_WRITE_LOCK_BH is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_WRITE_UNLOCK is not set
+# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+# CONFIG_FREEZER is not set
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_VEXPRESS is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_BCMRING is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CNS3XXX is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_MXS is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_LPC32XX is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_NUC93X is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_SHMOBILE is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_S5P64X0 is not set
+# CONFIG_ARCH_S5PC100 is not set
+# CONFIG_ARCH_S5PV210 is not set
+# CONFIG_ARCH_EXYNOS4 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_TCC_926 is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_U8500 is not set
+# CONFIG_ARCH_NOMADIK is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_PLAT_SPEAR is not set
+# CONFIG_ARCH_VT8500 is not set
+CONFIG_ARCH_ZYNQ=y
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_KEYBOARD_GPIO_POLLED is not set
+
+#
+# System MMU
+#
+
+#
+# Xilinx Specific Options
+#
+CONFIG_ZYNQ_EARLY_UART1=y
+# CONFIG_ZYNQ_EARLY_UART_EP107 is not set
+CONFIG_XILINX_FIXED_DEVTREE_ADDR=y
+CONFIG_XILINX_L1_PREFETCH=y
+CONFIG_XILINX_L2_PREFETCH=y
+CONFIG_XILINX_ZED=y
+# CONFIG_XILINX_TEST is not set
+CONFIG_ZYNQ_DEFAULT_KERNEL=y
+# CONFIG_ZYNQ_AMP_CPU0_MASTER is not set
+# CONFIG_ZYNQ_AMP_CPU1_SLAVE is not set
+# CONFIG_ZYNQ_CPU1_TEST is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_V7=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_32v7=y
+CONFIG_CPU_ABRT_EV7=y
+CONFIG_CPU_PABRT_V7=y
+CONFIG_CPU_CACHE_V7=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V7=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_ARM_THUMBEE is not set
+CONFIG_SWP_EMULATE=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_OUTER_CACHE=y
+CONFIG_OUTER_CACHE_SYNC=y
+CONFIG_CACHE_L2X0=y
+CONFIG_CACHE_PL310=y
+CONFIG_ARM_L1_CACHE_SHIFT=5
+CONFIG_ARM_DMA_MEM_BUFFERABLE=y
+CONFIG_CPU_HAS_PMU=y
+# CONFIG_ARM_ERRATA_430973 is not set
+# CONFIG_ARM_ERRATA_458693 is not set
+# CONFIG_ARM_ERRATA_460075 is not set
+# CONFIG_ARM_ERRATA_742230 is not set
+# CONFIG_ARM_ERRATA_742231 is not set
+# CONFIG_PL310_ERRATA_588369 is not set
+# CONFIG_ARM_ERRATA_720789 is not set
+# CONFIG_PL310_ERRATA_727915 is not set
+# CONFIG_ARM_ERRATA_743622 is not set
+# CONFIG_ARM_ERRATA_751472 is not set
+CONFIG_ARM_ERRATA_753970=y
+# CONFIG_ARM_ERRATA_754322 is not set
+# CONFIG_ARM_ERRATA_754327 is not set
+CONFIG_ARM_GIC=y
+CONFIG_ICST=y
+
+#
+# Bus support
+#
+CONFIG_ARM_AMBA=y
+CONFIG_ISA_DMA_API=y
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+# CONFIG_NO_HZ is not set
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_SMP=y
+CONFIG_SMP_ON_UP=y
+CONFIG_HAVE_ARM_SCU=y
+CONFIG_HAVE_ARM_TWD=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_NR_CPUS=4
+# CONFIG_HOTPLUG_CPU is not set
+CONFIG_LOCAL_TIMERS=y
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_HZ=100
+# CONFIG_THUMB2_KERNEL is not set
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_HAVE_ARCH_PFN_VALID=y
+CONFIG_HIGHMEM=y
+# CONFIG_HIGHPTE is not set
+CONFIG_HW_PERF_EVENTS=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_COMPACTION is not set
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+# CONFIG_CLEANCACHE is not set
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_SECCOMP is not set
+# CONFIG_CC_STACKPROTECTOR is not set
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
+
+#
+# Boot options
+#
+CONFIG_USE_OF=y
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="console=ttyPS0,115200n8 root=/dev/ram rw initrd=0x00800000,16M earlyprintk mtdparts=physmap-flash.0:512K(nor-fsbl),512K(nor-u-boot),5M(nor-linux),9M(nor-user),1M(nor-scratch),-(nor-rootfs)"
+CONFIG_CMDLINE_FROM_BOOTLOADER=y
+# CONFIG_CMDLINE_EXTEND is not set
+# CONFIG_CMDLINE_FORCE is not set
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+# CONFIG_CRASH_DUMP is not set
+# CONFIG_AUTO_ZRELADDR is not set
+
+#
+# CPU Power Management
+#
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_VFP=y
+CONFIG_VFPv3=y
+CONFIG_NEON=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+# CONFIG_SUSPEND is not set
+CONFIG_PM_RUNTIME=y
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+# CONFIG_APM_EMULATION is not set
+CONFIG_PM_RUNTIME_CLK=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+CONFIG_NET_IPIP=m
+# CONFIG_NET_IPGRE_DEMUX is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+CONFIG_INET_TUNNEL=m
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+CONFIG_INET_LRO=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=m
+# CONFIG_IPV6_PRIVACY is not set
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_IPCOMP is not set
+# CONFIG_IPV6_MIP6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+CONFIG_INET6_XFRM_MODE_TRANSPORT=m
+CONFIG_INET6_XFRM_MODE_TUNNEL=m
+CONFIG_INET6_XFRM_MODE_BEET=m
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+CONFIG_IPV6_SIT=m
+# CONFIG_IPV6_SIT_6RD is not set
+CONFIG_IPV6_NDISC_NODETYPE=y
+# CONFIG_IPV6_TUNNEL is not set
+# CONFIG_IPV6_MULTIPLE_TABLES is not set
+# CONFIG_IPV6_MROUTE is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+CONFIG_VLAN_8021Q=m
+# CONFIG_VLAN_8021Q_GVRP is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+# CONFIG_BATMAN_ADV is not set
+CONFIG_RPS=y
+CONFIG_RFS_ACCEL=y
+CONFIG_XPS=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_WIRELESS=y
+# CONFIG_CFG80211 is not set
+# CONFIG_LIB80211 is not set
+
+#
+# CFG80211 needs to be enabled for MAC80211
+#
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=m
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+CONFIG_CONNECTOR=y
+CONFIG_PROC_EVENTS=y
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+CONFIG_MTD_OF_PARTS=y
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_SM_FTL is not set
+# CONFIG_MTD_OOPS is not set
+# CONFIG_MTD_SWAP is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+CONFIG_MTD_CFI_AMDSTD=y
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+CONFIG_MTD_PHYSMAP=y
+# CONFIG_MTD_PHYSMAP_COMPAT is not set
+CONFIG_MTD_PHYSMAP_OF=y
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+CONFIG_MTD_M25P80=y
+# CONFIG_M25PXX_USE_FAST_READ is not set
+# CONFIG_MTD_SST25L is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND_ECC=y
+# CONFIG_MTD_NAND_ECC_SMC is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_BCH is not set
+# CONFIG_MTD_SM_COMMON is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+# CONFIG_MTD_NAND_GPIO is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+CONFIG_MTD_NAND_XILINX_PSS=y
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+# CONFIG_MTD_UBI is not set
+CONFIG_DTC=y
+CONFIG_OF=y
+
+#
+# Device Tree and Open Firmware support
+#
+CONFIG_PROC_DEVICETREE=y
+CONFIG_OF_FLATTREE=y
+CONFIG_OF_EARLY_FLATTREE=y
+CONFIG_OF_ADDRESS=y
+CONFIG_OF_IRQ=y
+CONFIG_OF_DEVICE=y
+CONFIG_OF_GPIO=y
+CONFIG_OF_I2C=y
+CONFIG_OF_NET=y
+CONFIG_OF_SPI=y
+CONFIG_OF_MDIO=y
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_DRBD is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=16384
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MG_DISK is not set
+# CONFIG_BLK_DEV_RBD is not set
+# CONFIG_SENSORS_LIS3LV02D is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_INTEL_MID_PTI is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1780 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_TI_DAC7512 is not set
+# CONFIG_BMP085 is not set
+CONFIG_SI570=y
+CONFIG_ADV7511=y
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+CONFIG_EEPROM_AT24=y
+CONFIG_EEPROM_AT25=y
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_IWMC3200TOP is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_TI_ST is not set
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+CONFIG_CHR_DEV_SG=y
+# CONFIG_CHR_DEV_SCH is not set
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+# CONFIG_TARGET_CORE is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+# CONFIG_MII is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+CONFIG_MARVELL_PHY=y
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_MICREL_PHY is not set
+# CONFIG_FIXED_PHY is not set
+CONFIG_MDIO_BITBANG=y
+# CONFIG_MDIO_GPIO is not set
+CONFIG_NET_ETHERNET=y
+# CONFIG_AX88796 is not set
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+# CONFIG_ENC28J60 is not set
+# CONFIG_ETHOC is not set
+# CONFIG_SMC911X is not set
+# CONFIG_SMSC911X is not set
+# CONFIG_DNET is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+# CONFIG_KS8851 is not set
+# CONFIG_KS8851_MLL is not set
+# CONFIG_FTMAC100 is not set
+CONFIG_NETDEV_1000=y
+CONFIG_XILINX_PS_EMAC=y
+# CONFIG_XILINX_PS_EMAC_HWTSTAMP is not set
+# CONFIG_XILINX_LLTEMAC_MARVELL_88E1111_RGMII is not set
+CONFIG_XILINX_LLTEMAC_MARVELL_88E1111_GMII=y
+# CONFIG_XILINX_LLTEMAC_MARVELL_88E1111_MII is not set
+# CONFIG_XILINX_LLTEMAC_NATIONAL_DP83865_GMII is not set
+# CONFIG_STMMAC_ETH is not set
+CONFIG_NETDEV_10000=y
+CONFIG_WLAN=y
+# CONFIG_USB_ZD1201 is not set
+# CONFIG_HOSTAP is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_IPHETH is not set
+# CONFIG_WAN is not set
+
+#
+# CAIF transport drivers
+#
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+CONFIG_INPUT_SPARSEKMAP=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ADP5588 is not set
+# CONFIG_KEYBOARD_ADP5589 is not set
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_QT1070 is not set
+# CONFIG_KEYBOARD_QT2160 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_GPIO is not set
+# CONFIG_KEYBOARD_TCA6416 is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_MCS is not set
+# CONFIG_KEYBOARD_MPR121 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+CONFIG_INPUT_MOUSE=y
+# CONFIG_MOUSE_PS2 is not set
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_APPLETOUCH is not set
+# CONFIG_MOUSE_BCM5974 is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_MOUSE_GPIO is not set
+# CONFIG_MOUSE_SYNAPTICS_I2C is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_AMBAKMI is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+# CONFIG_DEVKMEM is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_AMBA_PL010 is not set
+# CONFIG_SERIAL_AMBA_PL011 is not set
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX3107 is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_IFX6X60 is not set
+CONFIG_SERIAL_XILINX_PS_UART=y
+CONFIG_SERIAL_XILINX_PS_UART_CONSOLE=y
+# CONFIG_TTY_PRINTK is not set
+# CONFIG_HVC_DCC is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+CONFIG_XILINX_DEVCFG=y
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_RAMOOPS is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_MUX=y
+
+#
+# Multiplexer I2C Chip support
+#
+# CONFIG_I2C_MUX_GPIO is not set
+# CONFIG_I2C_MUX_PCA9541 is not set
+CONFIG_I2C_MUX_PCA954x=y
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_DESIGNWARE is not set
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_PXA_PCI is not set
+# CONFIG_I2C_SIMTEC is not set
+CONFIG_I2C_XILINX_PS=y
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_DIOLAN_U2C is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_ALTERA is not set
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_SPI_GPIO is not set
+# CONFIG_SPI_OC_TINY is not set
+# CONFIG_SPI_PL022 is not set
+# CONFIG_SPI_PXA2XX_PCI is not set
+# CONFIG_SPI_XILINX is not set
+CONFIG_SPI_XILINX_PS_QSPI=y
+# CONFIG_XILINX_PS_QSPI_USE_DUAL_FLASH is not set
+CONFIG_SPI_XILINX_PS_SPI=y
+# CONFIG_SPI_DESIGNWARE is not set
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+
+#
+# Enable Device Drivers -> PPS to see the PTP clock options.
+#
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_DEBUG_GPIO is not set
+CONFIG_GPIO_SYSFS=y
+
+#
+# Memory mapped GPIO drivers:
+#
+# CONFIG_GPIO_BASIC_MMIO is not set
+# CONFIG_GPIO_IT8761E is not set
+# CONFIG_GPIO_PL061 is not set
+# CONFIG_GPIO_XILINX is not set
+CONFIG_GPIO_XILINX_PS=y
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_SX150X is not set
+# CONFIG_GPIO_ADP5588 is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+# CONFIG_GPIO_MC33880 is not set
+# CONFIG_GPIO_74X164 is not set
+
+#
+# AC97 GPIO expanders:
+#
+
+#
+# MODULbus GPIO expanders:
+#
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+# CONFIG_ARM_SP805_WATCHDOG is not set
+# CONFIG_MPCORE_WATCHDOG is not set
+CONFIG_XILINX_PS_WATCHDOG=y
+# CONFIG_XILINX_SCU_WATCHDOG is not set
+# CONFIG_MAX63XX_WATCHDOG is not set
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+CONFIG_MFD_SUPPORT=y
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_STMPE is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM831X_SPI is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_MC13XXX is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_TPS65910 is not set
+# CONFIG_REGULATOR is not set
+CONFIG_MEDIA_SUPPORT=y
+
+#
+# Multimedia core support
+#
+# CONFIG_MEDIA_CONTROLLER is not set
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2_COMMON=y
+# CONFIG_DVB_CORE is not set
+CONFIG_VIDEO_MEDIA=y
+
+#
+# Multimedia drivers
+#
+# CONFIG_RC_CORE is not set
+# CONFIG_MEDIA_ATTACH is not set
+CONFIG_MEDIA_TUNER=y
+# CONFIG_MEDIA_TUNER_CUSTOMISE is not set
+CONFIG_MEDIA_TUNER_SIMPLE=y
+CONFIG_MEDIA_TUNER_TDA8290=y
+CONFIG_MEDIA_TUNER_TDA827X=y
+CONFIG_MEDIA_TUNER_TDA18271=y
+CONFIG_MEDIA_TUNER_TDA9887=y
+CONFIG_MEDIA_TUNER_TEA5761=y
+CONFIG_MEDIA_TUNER_TEA5767=y
+CONFIG_MEDIA_TUNER_MT20XX=y
+CONFIG_MEDIA_TUNER_XC2028=y
+CONFIG_MEDIA_TUNER_XC5000=y
+CONFIG_MEDIA_TUNER_MC44S803=y
+CONFIG_VIDEO_V4L2=y
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+# CONFIG_VIDEO_HELPER_CHIPS_AUTO is not set
+
+#
+# Encoders, decoders, sensors and other helper chips
+#
+
+#
+# Audio decoders, processors and mixers
+#
+# CONFIG_VIDEO_TVAUDIO is not set
+# CONFIG_VIDEO_TDA7432 is not set
+# CONFIG_VIDEO_TDA9840 is not set
+# CONFIG_VIDEO_TEA6415C is not set
+# CONFIG_VIDEO_TEA6420 is not set
+# CONFIG_VIDEO_MSP3400 is not set
+# CONFIG_VIDEO_CS5345 is not set
+# CONFIG_VIDEO_CS53L32A is not set
+# CONFIG_VIDEO_TLV320AIC23B is not set
+# CONFIG_VIDEO_WM8775 is not set
+# CONFIG_VIDEO_WM8739 is not set
+# CONFIG_VIDEO_VP27SMPX is not set
+
+#
+# RDS decoders
+#
+# CONFIG_VIDEO_SAA6588 is not set
+
+#
+# Video decoders
+#
+# CONFIG_VIDEO_ADV7180 is not set
+# CONFIG_VIDEO_BT819 is not set
+# CONFIG_VIDEO_BT856 is not set
+# CONFIG_VIDEO_BT866 is not set
+# CONFIG_VIDEO_KS0127 is not set
+# CONFIG_VIDEO_SAA7110 is not set
+# CONFIG_VIDEO_SAA711X is not set
+# CONFIG_VIDEO_SAA7191 is not set
+# CONFIG_VIDEO_TVP514X is not set
+# CONFIG_VIDEO_TVP5150 is not set
+# CONFIG_VIDEO_TVP7002 is not set
+# CONFIG_VIDEO_VPX3220 is not set
+
+#
+# Video and audio decoders
+#
+# CONFIG_VIDEO_SAA717X is not set
+# CONFIG_VIDEO_CX25840 is not set
+
+#
+# MPEG video encoders
+#
+# CONFIG_VIDEO_CX2341X is not set
+
+#
+# Video encoders
+#
+# CONFIG_VIDEO_SAA7127 is not set
+# CONFIG_VIDEO_SAA7185 is not set
+# CONFIG_VIDEO_ADV7170 is not set
+# CONFIG_VIDEO_ADV7175 is not set
+# CONFIG_VIDEO_ADV7343 is not set
+# CONFIG_VIDEO_AK881X is not set
+
+#
+# Camera sensor devices
+#
+# CONFIG_VIDEO_OV7670 is not set
+# CONFIG_VIDEO_MT9V011 is not set
+# CONFIG_VIDEO_TCM825X is not set
+
+#
+# Video improvement chips
+#
+# CONFIG_VIDEO_UPD64031A is not set
+# CONFIG_VIDEO_UPD64083 is not set
+
+#
+# Miscelaneous helper chips
+#
+# CONFIG_VIDEO_THS7303 is not set
+# CONFIG_VIDEO_M52790 is not set
+# CONFIG_VIDEO_VIVI is not set
+# CONFIG_VIDEO_CPIA2 is not set
+# CONFIG_VIDEO_SR030PC30 is not set
+# CONFIG_VIDEO_NOON010PC30 is not set
+# CONFIG_SOC_CAMERA is not set
+CONFIG_V4L_USB_DRIVERS=y
+CONFIG_USB_VIDEO_CLASS=y
+CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y
+CONFIG_USB_GSPCA=y
+# CONFIG_USB_M5602 is not set
+# CONFIG_USB_STV06XX is not set
+# CONFIG_USB_GL860 is not set
+# CONFIG_USB_GSPCA_BENQ is not set
+# CONFIG_USB_GSPCA_CONEX is not set
+# CONFIG_USB_GSPCA_CPIA1 is not set
+# CONFIG_USB_GSPCA_ETOMS is not set
+# CONFIG_USB_GSPCA_FINEPIX is not set
+# CONFIG_USB_GSPCA_JEILINJ is not set
+# CONFIG_USB_GSPCA_KINECT is not set
+# CONFIG_USB_GSPCA_KONICA is not set
+# CONFIG_USB_GSPCA_MARS is not set
+# CONFIG_USB_GSPCA_MR97310A is not set
+# CONFIG_USB_GSPCA_NW80X is not set
+# CONFIG_USB_GSPCA_OV519 is not set
+# CONFIG_USB_GSPCA_OV534 is not set
+# CONFIG_USB_GSPCA_OV534_9 is not set
+# CONFIG_USB_GSPCA_PAC207 is not set
+# CONFIG_USB_GSPCA_PAC7302 is not set
+# CONFIG_USB_GSPCA_PAC7311 is not set
+# CONFIG_USB_GSPCA_SN9C2028 is not set
+# CONFIG_USB_GSPCA_SN9C20X is not set
+# CONFIG_USB_GSPCA_SONIXB is not set
+# CONFIG_USB_GSPCA_SONIXJ is not set
+# CONFIG_USB_GSPCA_SPCA500 is not set
+# CONFIG_USB_GSPCA_SPCA501 is not set
+# CONFIG_USB_GSPCA_SPCA505 is not set
+# CONFIG_USB_GSPCA_SPCA506 is not set
+# CONFIG_USB_GSPCA_SPCA508 is not set
+# CONFIG_USB_GSPCA_SPCA561 is not set
+# CONFIG_USB_GSPCA_SPCA1528 is not set
+# CONFIG_USB_GSPCA_SQ905 is not set
+# CONFIG_USB_GSPCA_SQ905C is not set
+# CONFIG_USB_GSPCA_SQ930X is not set
+# CONFIG_USB_GSPCA_STK014 is not set
+# CONFIG_USB_GSPCA_STV0680 is not set
+# CONFIG_USB_GSPCA_SUNPLUS is not set
+# CONFIG_USB_GSPCA_T613 is not set
+# CONFIG_USB_GSPCA_TV8532 is not set
+# CONFIG_USB_GSPCA_VC032X is not set
+# CONFIG_USB_GSPCA_VICAM is not set
+# CONFIG_USB_GSPCA_XIRLINK_CIT is not set
+# CONFIG_USB_GSPCA_ZC3XX is not set
+# CONFIG_VIDEO_PVRUSB2 is not set
+# CONFIG_VIDEO_HDPVR is not set
+# CONFIG_VIDEO_USBVISION is not set
+# CONFIG_USB_ET61X251 is not set
+# CONFIG_USB_SN9C102 is not set
+# CONFIG_USB_PWC is not set
+# CONFIG_USB_ZR364XX is not set
+# CONFIG_USB_STKWEBCAM is not set
+# CONFIG_USB_S2255 is not set
+# CONFIG_V4L_MEM2MEM_DRIVERS is not set
+# CONFIG_RADIO_ADAPTERS is not set
+
+#
+# Graphics support
+#
+# CONFIG_DRM is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_WMT_GE_ROPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_ARMCLCD is not set
+# CONFIG_FB_UVESA is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_XILINX is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_BROADSHEET is not set
+CONFIG_FB_XYLON=y
+# CONFIG_FB_XYLON_PLATFORM is not set
+CONFIG_FB_XYLON_OF=y
+# CONFIG_FB_XYLON_EXT_PIXCLK is not set
+# CONFIG_FB_XYLON_ZYNQ_PS_PIXCLK is not set
+CONFIG_FB_XYLON_CLKGEN_PIXCLK=y
+# CONFIG_FB_XYLON_ZC702_PIXCLK is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+CONFIG_FONTS=y
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_7x14 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+# CONFIG_FONT_MINI_4x6 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+# CONFIG_FONT_10x18 is not set
+# CONFIG_LOGO is not set
+# CONFIG_SOUND is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_ACRUX is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_KEYTOUCH is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LCPOWER is not set
+# CONFIG_HID_LOGITECH is not set
+CONFIG_HID_MICROSOFT=y
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_QUANTA is not set
+# CONFIG_HID_ROCCAT is not set
+# CONFIG_HID_ROCCAT_ARVO is not set
+# CONFIG_HID_ROCCAT_KONE is not set
+# CONFIG_HID_ROCCAT_KONEPLUS is not set
+# CONFIG_HID_ROCCAT_KOVAPLUS is not set
+# CONFIG_HID_ROCCAT_PYRA is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SONY is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+CONFIG_USB_SUSPEND=y
+CONFIG_USB_OTG=y
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+# CONFIG_USB_EHCI_TT_NEWSCHED is not set
+CONFIG_USB_XUSBPS_DR_OF=y
+CONFIG_USB_EHCI_XUSBPS=y
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+# CONFIG_USB_MUSB_HDRC is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_REALTEK is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_STORAGE_ENE_UB6250 is not set
+# CONFIG_USB_UAS is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_SELECTED=y
+CONFIG_USB_GADGET_XUSBPS=y
+CONFIG_USB_XUSBPS=y
+# CONFIG_USB_GADGET_FUSB300 is not set
+# CONFIG_USB_GADGET_R8A66597 is not set
+# CONFIG_USB_GADGET_XILINX is not set
+# CONFIG_USB_GADGET_PXA_U2O is not set
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+CONFIG_USB_ZERO=m
+# CONFIG_USB_ZERO_HNPTEST is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_G_NCM is not set
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_FUNCTIONFS is not set
+CONFIG_USB_FILE_STORAGE=m
+# CONFIG_USB_FILE_STORAGE_TEST is not set
+# CONFIG_USB_MASS_STORAGE is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_CDC_COMPOSITE is not set
+# CONFIG_USB_G_MULTI is not set
+# CONFIG_USB_G_HID is not set
+# CONFIG_USB_G_DBGP is not set
+# CONFIG_USB_G_WEBCAM is not set
+
+#
+# OTG and related infrastructure
+#
+CONFIG_USB_OTG_UTILS=y
+# CONFIG_USB_GPIO_VBUS is not set
+CONFIG_USB_ULPI=y
+CONFIG_USB_ULPI_VIEWPORT=y
+# CONFIG_NOP_USB_XCEIV is not set
+CONFIG_USB_XUSBPS_OTG=y
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+# CONFIG_MMC_CLKGATE is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_MINORS=8
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_ARMMMCI is not set
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_OF=y
+CONFIG_MMC_SDHCI_PLTFM=y
+# CONFIG_MMC_WBSD is not set
+# CONFIG_MMC_DW is not set
+# CONFIG_MMC_VUB300 is not set
+# CONFIG_MMC_USHC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_NFC_DEVICES is not set
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+CONFIG_RTC_DRV_PCF8563=y
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T93 is not set
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_DS3234 is not set
+# CONFIG_RTC_DRV_PCF2123 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_PL030 is not set
+# CONFIG_RTC_DRV_PL031 is not set
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+# CONFIG_STAGING is not set
+CONFIG_CLKDEV_LOOKUP=y
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+# CONFIG_EXT4_FS is not set
+CONFIG_JBD=y
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+# CONFIG_DNOTIFY is not set
+CONFIG_INOTIFY_USER=y
+# CONFIG_FANOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTACTL is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_TMPFS_XATTR is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+CONFIG_JFFS2_SUMMARY=y
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+# CONFIG_LOGFS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_PSTORE is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_FRAME_WARN=1024
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_HARDLOCKUP_DETECTOR is not set
+# CONFIG_DETECT_HUNG_TASK is not set
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_PREEMPT is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_HIGHMEM is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=60
+# CONFIG_RCU_CPU_STALL_VERBOSE is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_STRICT_DEVMEM is not set
+CONFIG_ARM_UNWIND=y
+# CONFIG_DEBUG_USER is not set
+CONFIG_DEBUG_LL=y
+CONFIG_EARLY_PRINTK=y
+# CONFIG_DEBUG_ICEDCC is not set
+# CONFIG_OC_ETM is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_ALGAPI=m
+CONFIG_CRYPTO_ALGAPI2=m
+CONFIG_CRYPTO_RNG=m
+CONFIG_CRYPTO_RNG2=m
+# CONFIG_CRYPTO_MANAGER is not set
+# CONFIG_CRYPTO_MANAGER2 is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_PCRYPT is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=m
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+CONFIG_CRYPTO_ANSI_CPRNG=m
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+# CONFIG_XZ_DEC is not set
+# CONFIG_XZ_DEC_BCJ is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_CPU_RMAP=y
+CONFIG_NLATTR=y
+# CONFIG_AVERAGE is not set
diff -uNr linux-xlnx//devicetree.dts linux-xlnx_xfb_14.1_build3//devicetree.dts
--- linux-xlnx//devicetree.dts	1970-01-01 01:00:00.000000000 +0100
+++ linux-xlnx_xfb_14.1_build3//devicetree.dts	2012-09-19 15:46:07.195918000 +0200
@@ -0,0 +1,318 @@
+/dts-v1/;
+
+/ {
+	model = "Xilinx Zynq ZC770";
+	compatible = "xlnx,zynq-zc770";
+	#address-cells = <0x1>;
+	#size-cells = <0x1>;
+	interrupt-parent = <0x1>;
+
+	memory {
+		device_type = "memory";
+		reg = <0x00000000 0x20000000>; 
+	};
+	chosen {
+		bootargs = "console=ttyPS0,115200n8 console=tty0 root=/dev/ram rw initrd=0x800000,8M ip=192.168.0.77:::255.255.255.0:ZED:eth0 earlyprintk mem=256M memmap=256M$0x10000000 vmalloc=256M";
+		linux,stdout-path = "/amba@0/uart@E0001000";
+	};
+
+	amba@0 {
+		compatible = "simple-bus";
+		#address-cells = <0x1>;
+		#size-cells = <0x1>;
+		ranges;
+
+		intc@f8f01000 {
+			interrupt-controller;
+			compatible = "arm,gic";
+			reg = <0xf8f01000 0x1000>;
+			#interrupt-cells = <0x2>;
+			linux,phandle = <0x1>;
+			phandle = <0x1>;
+		};
+
+		uart@e0001000 {
+			compatible = "xlnx,ps7-uart-1.00.a";
+			reg = <0xe0001000 0x1000>;
+			interrupts = <0x52 0x0>;
+			clock = <50000000>;
+		};
+
+		timer@0xf8001000 {
+			clock-frequency-timer0 = <111111111>;
+			clock-frequency-timer1 = <111111111>;
+			clock-frequency-timer2 = <111111111>;
+			compatible = "xlnx,ps7-ttc-1.00.a";
+			interrupts = < 42 0 43 0 44 0 >;
+			reg = < 0xf8001000 0x1000 >;
+		};
+
+		swdt@f8005000 {
+			device_type = "watchdog";
+			compatible = "xlnx,ps7-wdt-1.00.a";
+			reg = <0xf8005000 0x100>;
+			clock-frequency = <111111111>;
+		};
+
+		eth@e000b000 {
+			compatible = "xlnx,ps7-ethernet-1.00.a";
+			reg = <0xe000b000 0x1000>;
+			interrupts = <0x36 0x0>;
+			phy-handle = <&phy0>;
+			xlnx,ptp-enet-clock = <111111111>;
+			xlnx,slcr-div0-1000Mbps = <8>;
+			xlnx,slcr-div0-100Mbps = <8>;
+			xlnx,slcr-div0-10Mbps = <8>;
+			xlnx,slcr-div1-1000Mbps = <1>;
+			xlnx,slcr-div1-100Mbps = <5>;
+			xlnx,slcr-div1-10Mbps = <50>;
+			#address-cells = <0x1>;
+			#size-cells = <0x0>;
+
+			phy0: phy@0 {
+				compatible = "marvell,88e1510";
+				device_type = "ethernet-phy";
+				reg = <0x0>;
+				marvell,reg-init = <0x03 0x10 0xFF00 0x1E 0x03 0x11 0xFFF0 0x0A>;
+				linux,phandle = <0x2>;
+			};
+		};
+
+		i2c0: i2c@e0004000 {
+			compatible = "xlnx,ps7-i2c-1.00.a";
+			reg = <0xE0004000 0x1000>;
+			interrupts = <57 0>;
+			bus-id = <0>;
+			input-clk = <111111111>;
+			i2c-clk = <100000>;
+			
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		sdhci@e0100000 {
+			compatible = "generic-sdhci";
+			reg = <0xe0100000 0x1000>;
+			interrupts = <0x38 0x0>;
+			clock-frequency = <33333000>;
+		};
+
+		usb@e0002000 {
+			compatible = "xlnx,ps7-usb-1.00.a";
+			reg = <0xe0002000 0x1000>;
+			interrupts = <0x35 0x0>;
+			dr_mode = "host";
+			phy_type = "ulpi";
+		};
+
+		gpio@e000a000 {
+			compatible = "xlnx,ps7-gpio-1.00.a";
+			reg = <0xe000a000 0x1000>;
+			interrupts = <0x34 0x0>;
+		};
+
+		qspi0: spi@e000d000 {
+			compatible = "xlnx,ps7-qspi-1.00.a";
+			reg = <0xE000D000 0x1000>;
+			interrupts = <51 0>;
+			speed-hz = <200000000>;
+			bus-num = <1>;
+			num-chip-select = <1>;
+			is-dual = <0>;
+		};
+
+		devcfg@f8007000 {
+			compatible = "xlnx,ps7-dev-cfg-1.00.a";
+			reg = <0xf8007000 0x1000>;
+			interrupts = <0x28 0x0>;
+		};
+
+		logicvc0: logicvc@40030000 {
+			compatible = "xylon,logicvc-2.05.c";
+			reg = <0x40030000 0x6000>;
+			interrupts = <91 0>;
+			buffer-0-offset = <1080>;
+			buffer-1-offset = <1080>;
+			buffer-2-offset = <1080>;
+			buffer-3-offset = <1080>;
+			buffer-4-offset = <1080>;
+			display-interface = <0>;
+			e-data-width = <24>;
+			e-layer = <0>;
+			interconnect-m-axi-arb-priority = <0xf>;
+			ip-license-type = <0>;
+			ip-major-revision = <2>;
+			ip-minor-revision = <5>;
+			ip-patch-level = <0>;
+			layer-0-alpha-mode = <1>;
+			layer-0-data-width = <24>;
+			layer-0-offset = <7290>;
+			layer-1-alpha-mode = <0>;
+			layer-1-data-width = <24>;
+			layer-1-offset = <4050>;
+			layer-2-alpha-mode = <0>;
+			layer-2-data-width = <24>;
+			layer-2-offset = <0>;
+			layer-3-alpha-mode = <3>;
+			layer-3-data-width = <8>;
+			layer-3-offset = <12960>;
+			layer-4-alpha-mode = <0>;
+			layer-4-data-width = <24>;
+			layer-4-offset = <11340>;
+			little-endian = <1>;
+			lvds-data-width = <4>;
+			mem-burst = <4>;
+			mplb-awidth = <32>;
+			mplb-dwidth = <64>;
+			mplb-native-dwidth = <32>;
+			mplb-num-masters = <8>;
+			mplb-p2p = <0>;
+			mplb-priority = <3>;
+			mplb-smallest-slave = <32>;
+			mplb-support-bursts = <1>;
+			num-of-layers = <5>;
+			pixel-data-width = <24>;
+			readable-regs = <1>;
+			regs-interface = <2>;
+			regs-little-endian = <1>;
+			row-stride = <2048>;
+			use-background = <1>;
+			use-e-rgb-input = <0>;
+			use-e-vclk-bufgmux = <1>;
+			use-io-hw-serializer = <0>;
+			use-multiplier = <2>;
+			use-serialized-blender = <0>;
+			use-size-position = <1>;
+			use-xtreme-dsp = <2>;
+			vmem-baseaddr = <0x10000000>;
+			vmem-highaddr = <0x1FFFFFFF>;
+			vmem-data-bus-width = <64>;
+			vmem-interface = <2>;
+		};
+
+		xylon-video-params {
+			pixel-data-invert = <0>;
+			pixel-clock-active-high = <1>;
+			pixel-component-format = "ARGB";
+			pixel-component-layer = <0>,<1>,<2>;
+			active-layer = <3>;
+			videomode = "1024x768";
+			800x480_TM050RBH01 {
+				name = "800x480_TM050RBH01";
+				refresh = <60>;
+				xres = <800>;
+				yres = <480>;
+				pixclock-khz = <30000>;
+				left-margin = <40>;
+				right-margin = <40>;
+				upper-margin = <29>;
+				lower-margin = <13>;
+				hsync-len = <48>;
+				vsync-len = <3>;
+				sync = <0>;
+				vmode = <0>;
+			};
+			1280x720 {
+				name = "1280x720";
+				refresh = <60>;
+				xres = <1280>;
+				yres = <720>;
+				pixclock-khz = <74250>;
+				left-margin = <220>;
+				right-margin = <110>;
+				upper-margin = <20>;
+				lower-margin = <5>;
+				hsync-len = <40>;
+				vsync-len = <5>;
+				sync = <0>;
+				vmode = <0>;
+			};
+			1680x1050 {
+				name = "1680x1050";
+				refresh = <60>;
+				xres = <1680>;
+				yres = <1050>;
+				pixclock-khz = <119000>;
+				left-margin = <80>;
+				right-margin = <48>;
+				upper-margin = <21>;
+				lower-margin = <3>;
+				hsync-len = <32>;
+				vsync-len = <6>;
+				sync = <0>;
+				vmode = <0>;
+			};
+			1920x1080 {
+				name = "1920x1080";
+				refresh = <60>;
+				xres = <1920>;
+				yres = <1080>;
+				pixclock-khz = <148500>;
+				left-margin = <148>;
+				right-margin = <88>;
+				upper-margin = <36>;
+				lower-margin = <4>;
+				hsync-len = <44>;
+				vsync-len = <5>;
+				sync = <0>;
+				vmode = <0>;
+			};
+		};
+
+		logibitblt0: logibitblt@40080000 {
+			compatible = "xylon,logibitblt-3.00.a";
+			reg = <0x40080000 0xffff>;
+			interrupts = <90 0>;
+			bb-baseaddr = <0x30000000>;
+			bb-highaddr = <0x37FFFFFF>;
+			use-move-neg = <0>;
+			use-expand = <0>;
+			use-patt-fill = <1>;
+			use-rle = <0>;
+			use-porter-duff = <1>;
+			use-aa-font-expand = <1>;
+			use-global-alpha = <1>;
+		};
+
+		logibmp0: logibmp@40090000 {
+			compatible = "xylon,logibmp-2.01.a";
+			interrupts = <89 0>;
+			reg = <0x40090000 0xffff>;
+			video-stride-width = <11>;
+			use-video-stride-reg = <1>;
+			xy-width = <11>;
+			uv-width = <11>;
+		};
+
+		logi3d0: logi3d@0x400b0000 {
+			compatible = "xylon,logi3d-1.00.a";
+			ip-major-revision = <1>;
+			ip-minor-revision = <0>;
+			ip-patch-revision = <0>;
+			reg3dSize = <1024>;
+			pReg3dPhys = <0x400B0000>;
+			pReg3dVirt = <0>;
+			mem3dSize = <0xB000000>;
+			pMem3dPhys = <0x15000000>;
+			pMem3dVirt = <0>;
+			fbSize = <26542080>;
+			pFbPhys = <0>;
+			pFbVirt = <0>;
+			bufferOffset = <1080>;
+			xyLength = <11>;
+			uvLength = <10>;
+			pLength = <32>;
+			zLength = <16>;
+			stencilLength = <8>;
+			rgbLength = <8>;
+			useMimap = <1>;
+			useMultitexture = <1>;
+		};
+
+		clkgen@40010000 {
+			compatible = "xylon,clkgen-1.01.a";
+			reg = <0x40010000 0xffff>;
+			osc-clk-freq-hz = <100000000>;
+		};
+	};
+};
diff -uNr linux-xlnx//drivers/misc/adv7511.c linux-xlnx_xfb_14.1_build3//drivers/misc/adv7511.c
--- linux-xlnx//drivers/misc/adv7511.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-xlnx_xfb_14.1_build3//drivers/misc/adv7511.c	2012-07-09 16:55:12.131936000 +0200
@@ -0,0 +1,356 @@
+/*
+ * Simple I2C driver for initalizing ADV7511 HDMI transmitter
+ *
+ * Author: Xylon d.o.o.
+ * e-mail: davor.joja@logicbricks.com
+ *
+ * 2012 (c) Xylon d.o.o.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+
+/*
+ * This file implements I2C functionality for controlling ADV7511 confguration
+ * used with logiCVC.
+ */
+
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/of_i2c.h>
+#include <linux/i2c/adv7511.h>
+
+
+#define FORMAT_RGB "RGB"
+#define FORMAT_YCbCr "YCbCr"
+
+struct adv7511_config_data {
+	u8 address;
+	u8 value;
+};
+
+struct adv7511_data {
+	struct attribute_group attrs;
+	struct mutex lock;
+	const struct adv7511_config_data *adv7511_cfg_data;
+	size_t adv7511_cfg_size;
+	char format[FORMAT_NAME_SZ];
+};
+
+
+static const struct adv7511_config_data adv7511_rgb_config[] = {
+	{0x41, 0x10},
+	{0xD6, 0xC0},
+	{0x15, 0x01},
+	{0x16, 0x38},
+	{0x18, 0xAB},
+	{0x19, 0x37},
+	{0x1A, 0x08},
+	{0x1B, 0x00},
+	{0x1C, 0x00},
+	{0x1D, 0x00},
+	{0x1E, 0x1A},
+	{0x1F, 0x86},
+	{0x20, 0x1A},
+	{0x21, 0x49},
+	{0x22, 0x08},
+	{0x23, 0x00},
+	{0x24, 0x1D},
+	{0x25, 0x3F},
+	{0x26, 0x04},
+	{0x27, 0x22},
+	{0x28, 0x00},
+	{0x29, 0x00},
+	{0x2A, 0x08},
+	{0x2B, 0x00},
+	{0x2C, 0x0E},
+	{0x2D, 0x2D},
+	{0x2E, 0x19},
+	{0x2F, 0x14},
+	{0x48, 0x08},
+	{0x55, 0x00},
+	{0x56, 0x28},
+	{0x98, 0x03},
+	{0x9A, 0xE0},
+	{0x9C, 0x30},
+	{0x9D, 0x61},
+	{0xA2, 0xA4},
+	{0xA3, 0xA4},
+	{0xAF, 0x04},
+	{0xE0, 0xD0},
+	{0xF9, 0x00}
+};
+
+static const struct adv7511_config_data adv7511_ycbcr_config[] = {
+	{0x41, 0x10},
+	{0xD6, 0xC0},
+	{0x15, 0x01},
+	{0x16, 0xB9},
+	{0x48, 0x08},
+	{0x55, 0x20},
+	{0x56, 0x28},
+	{0x98, 0x03},
+	{0x9A, 0xE0},
+	{0x9C, 0x30},
+	{0x9D, 0x61},
+	{0xA2, 0xA4},
+	{0xA3, 0xA4},
+	{0xAF, 0x06},
+	{0xE0, 0xD0},
+	{0xF9, 0x00} 
+};
+
+static struct i2c_client *adv7511_client;
+
+
+static int adv7511_configure(struct i2c_client *client)
+{
+	struct adv7511_data *data = i2c_get_clientdata(client);
+	int i, ret;
+
+	for (i = 0; i < data->adv7511_cfg_size; i++) {
+		ret = i2c_smbus_write_byte_data(client,
+			data->adv7511_cfg_data[i].address, data->adv7511_cfg_data[i].value);
+		if (ret)
+			break;
+	}
+
+	if (ret) {
+		dev_warn(&client->dev,
+			"failed configuring %s for %s\n",
+				client->driver->id_table->name, data->format);
+	} else {
+		dev_info(&client->dev,
+			"%s configured for DVI (%s)\n",
+				client->driver->id_table->name, data->format);
+	}
+
+	return 0;
+}
+
+struct i2c_client *adv7511_get_client(void)
+{
+	return adv7511_client;
+}
+EXPORT_SYMBOL(adv7511_get_client);
+
+static ssize_t show_format_attr(struct device *dev,
+	struct device_attribute *devattr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct adv7511_data *data = i2c_get_clientdata(client);
+
+	return sprintf(buf, "%s\n", data->format);
+}
+
+int adv7511_get_format(struct device *dev)
+{
+	int ret;
+	char buf[FORMAT_NAME_SZ];
+
+	if ((!dev) || (to_i2c_client(dev) != adv7511_client))
+		return -EINVAL;
+
+	show_format_attr(dev, NULL, buf);
+
+	ret = strncmp(FORMAT_RGB, buf, (sizeof(FORMAT_RGB)-1));
+	if (!ret)
+		return ADV7511_RGB;
+	ret = strncmp(FORMAT_YCbCr, buf, (sizeof(FORMAT_YCbCr)-1));
+	if (!ret)
+		return ADV7511_YCbCr;
+
+	return 0;
+}
+EXPORT_SYMBOL(adv7511_get_format);
+
+static ssize_t set_format_attr(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct adv7511_data *data = i2c_get_clientdata(client);
+	char *c;
+	int ret;
+
+	mutex_lock(&data->lock);
+
+	ret = 0;
+	/* remove "new line" character */
+	strcpy(data->format, buf);
+	c = strchr(data->format, 0x0A);
+	if (c)
+		*c = 0;
+
+	if (!strcmp(data->format, FORMAT_RGB)) {
+		data->adv7511_cfg_data = adv7511_rgb_config;
+		data->adv7511_cfg_size = ARRAY_SIZE(adv7511_rgb_config);
+	} else if (!strcmp(data->format, FORMAT_YCbCr)) {
+		data->adv7511_cfg_data = adv7511_ycbcr_config;
+		data->adv7511_cfg_size = ARRAY_SIZE(adv7511_ycbcr_config);
+	} else {
+		ret = -EINVAL;
+		pr_err("%s string error!\n", client->driver->id_table->name);
+	}
+
+	if (!ret)
+		ret = adv7511_configure(client);
+
+	data->adv7511_cfg_data = NULL;
+	data->adv7511_cfg_size = 0;
+
+	mutex_unlock(&data->lock);
+
+	if (!ret)
+		ret = count;
+
+	return ret;
+}
+
+int adv7511_set_format(struct device *dev, int type)
+{
+	int ret;
+
+	if ((!dev) || (to_i2c_client(dev) != adv7511_client))
+		return -EINVAL;
+
+	ret = ADV7511_UNDEFINED;
+
+	if (ADV7511_RGB == type)
+		ret = set_format_attr(dev, NULL, FORMAT_RGB, 0);
+	else if (ADV7511_YCbCr == type)
+		ret = set_format_attr(dev, NULL, FORMAT_YCbCr, 0);
+
+	return ret;
+}
+EXPORT_SYMBOL(adv7511_set_format);
+
+static DEVICE_ATTR(format, (S_IWUSR | S_IRUGO),
+	show_format_attr, set_format_attr);
+
+static struct attribute *adv7511_attr[] = {
+	&dev_attr_format.attr,
+	NULL
+};
+
+static const struct i2c_device_id adv7511_id[] = {
+	{ "adv7511", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, adv7511_id);
+
+static int adv7511_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	struct adv7511_platform_data *pdata = client->dev.platform_data;
+	struct adv7511_data *data;
+	u32 const *prop;
+	char *cptr;
+	int ret, size;
+	bool platform, of;
+
+	if (client->dev.of_node) {
+		of = true;
+	} else {
+		of = false;
+		if (pdata)
+			platform = true;
+		else
+			return -ENODEV;
+	}
+
+	data = kzalloc(sizeof(struct adv7511_data), GFP_KERNEL);
+	if (!data) {
+		ret = -ENOMEM;
+		goto exit;
+	}
+
+	i2c_set_clientdata(client, data);
+
+	mutex_init(&data->lock);
+
+	/* Register sysfs hooks */
+	data->attrs.attrs = adv7511_attr;
+	ret = sysfs_create_group(&client->dev.kobj, &data->attrs);
+	if (ret)
+		goto exit_free;
+
+	cptr = NULL;
+	if (of) {
+		prop = of_get_property(client->dev.of_node, "format", &size);
+		if (prop)
+			cptr = (char *)prop;
+	} else if (platform) {
+		cptr = pdata->format;
+	}
+
+	if (!cptr)
+		goto exit_free;
+
+	ret = set_format_attr(&client->dev, NULL, cptr, 0);
+	if (ret)
+		goto exit_free;
+
+	data->adv7511_cfg_data = NULL;
+	data->adv7511_cfg_size = 0;
+
+	adv7511_client = client;
+
+	return 0;
+
+exit_free:
+	kfree(data);
+exit:
+	return ret;
+}
+
+static int adv7511_remove(struct i2c_client *client)
+{
+	struct adv7511_data *data = i2c_get_clientdata(client);
+
+	sysfs_remove_group(&client->dev.kobj, &data->attrs);
+
+	kfree(data);
+
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id i2c_adv7511_of_match[] = {
+	{ .compatible = "adv7511" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, i2c_adv7511_of_match);
+#else
+static const struct of_device_id i2c_adv7511_of_match = NULL;
+#endif
+
+static struct i2c_driver adv7511_driver = {
+	.driver = {
+		.name = "adv7511",
+		.of_match_table = i2c_adv7511_of_match,
+	},
+	.probe = adv7511_probe,
+	.remove = adv7511_remove,
+	.id_table = adv7511_id,
+};
+
+static int __init adv7511_init(void)
+{
+	return i2c_add_driver(&adv7511_driver);
+}
+
+static void __exit adv7511_exit(void)
+{
+	i2c_del_driver(&adv7511_driver);
+}
+
+module_init(adv7511_init);
+module_exit(adv7511_exit);
+
+MODULE_AUTHOR("Davor Joja <davor.joja@logicbricks.com>");
+MODULE_DESCRIPTION("Basic ADV7511 I2C driver");
+MODULE_LICENSE("GPL v2");
diff -uNr linux-xlnx//drivers/misc/Kconfig linux-xlnx_xfb_14.1_build3//drivers/misc/Kconfig
--- linux-xlnx//drivers/misc/Kconfig	2012-05-15 03:09:09.000000000 +0200
+++ linux-xlnx_xfb_14.1_build3//drivers/misc/Kconfig	2012-07-09 13:37:17.486221124 +0200
@@ -500,6 +500,16 @@
 	  To compile this driver as a module, choose M here: the module
 	  will be called si570
 
+config ADV7511
+	tristate "Analog Devices ADV7511 HDMI transmitter"
+	depends on I2C && SYSFS
+	help
+	  If you say yes here you get support for the Analog Devices ADV7511
+	  HDMI transmitter.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called adv7511
+
 source "drivers/misc/c2port/Kconfig"
 source "drivers/misc/eeprom/Kconfig"
 source "drivers/misc/cb710/Kconfig"
diff -uNr linux-xlnx//drivers/misc/Makefile linux-xlnx_xfb_14.1_build3//drivers/misc/Makefile
--- linux-xlnx//drivers/misc/Makefile	2012-05-15 03:09:09.000000000 +0200
+++ linux-xlnx_xfb_14.1_build3//drivers/misc/Makefile	2012-07-09 13:37:17.494221120 +0200
@@ -47,3 +47,4 @@
 obj-y				+= lis3lv02d/
 obj-y				+= carma/
 obj-$(CONFIG_SI570)		+= si570.o
+obj-$(CONFIG_ADV7511)	+= adv7511.o
diff -uNr linux-xlnx//drivers/misc/si570.c linux-xlnx_xfb_14.1_build3//drivers/misc/si570.c
--- linux-xlnx//drivers/misc/si570.c	2012-05-15 03:09:09.000000000 +0200
+++ linux-xlnx_xfb_14.1_build3//drivers/misc/si570.c	2012-07-09 13:37:17.498221119 +0200
@@ -77,7 +77,7 @@
 };
 
 
-static struct i2c_client *client_i2c;
+static struct i2c_client *si570_client;
 
 
 static int si570_get_defaults(struct i2c_client *client)
@@ -285,6 +285,9 @@
 	int err;
 	char buf[10+1];
 
+	if ((!dev) || (to_i2c_client(dev) != si570_client))
+		return -EINVAL;
+
 	show_frequency_attr(dev, NULL, buf);
 
 	err = strict_strtoul(buf, 10, freq);
@@ -339,6 +342,9 @@
 {
 	char buf[10+1];
 
+	if ((!dev) || (to_i2c_client(dev) != si570_client))
+		return -EINVAL;
+
 	sprintf(buf, "%lu", freq);
 
 	return set_frequency_attr(dev, NULL, buf,  0);
@@ -376,18 +382,21 @@
 	return count;
 }
 
-void reset_si570(struct device *dev, int id)
+int reset_si570(struct device *dev, int id)
 {
 	char buf[4];
 
+	if ((!dev) || (to_i2c_client(dev) != si570_client))
+		return -EINVAL;
+
 	sprintf(buf, "%lu", (unsigned long)id);
-	set_reset_attr(dev, NULL, buf, 0);
+	return set_reset_attr(dev, NULL, buf, 0);
 }
 EXPORT_SYMBOL(reset_si570);
 
 struct i2c_client *get_i2c_client_si570(void)
 {
-	return client_i2c;
+	return si570_client;
 }
 EXPORT_SYMBOL(get_i2c_client_si570);
 
@@ -482,7 +491,7 @@
 			pdata->initial_fout);
 	}
 
-	client_i2c = client;
+	si570_client = client;
 
 	return 0;
 
diff -uNr linux-xlnx//drivers/usb/host/ehci.h linux-xlnx_xfb_14.1_build3//drivers/usb/host/ehci.h
--- linux-xlnx//drivers/usb/host/ehci.h	2012-05-15 03:09:09.000000000 +0200
+++ linux-xlnx_xfb_14.1_build3//drivers/usb/host/ehci.h	2012-09-18 12:36:23.650547173 +0200
@@ -110,6 +110,9 @@
 
 #ifdef CONFIG_USB_XUSBPS_OTG
 	void (*start_hnp)(struct ehci_hcd *ehci);
+#ifdef CONFIG_XILINX_ZED
+	struct otg_transceiver	*ulpi;
+#endif
 #endif
 
 	/* per-HC memory pools (could be per-bus, but ...) */
diff -uNr linux-xlnx//drivers/usb/host/ehci-hcd.c linux-xlnx_xfb_14.1_build3//drivers/usb/host/ehci-hcd.c
--- linux-xlnx//drivers/usb/host/ehci-hcd.c	2012-05-15 03:09:09.000000000 +0200
+++ linux-xlnx_xfb_14.1_build3//drivers/usb/host/ehci-hcd.c	2012-09-18 12:36:23.634547309 +0200
@@ -771,6 +771,13 @@
 	/* Modifying FIFO Burst Threshold value from 2 to 8 */
 	temp = readl(non_ehci + 0x164);
 	ehci_writel(ehci, 0x00080000, non_ehci + 0x164);
+#if CONFIG_XILINX_ZED
+	if (ehci->ulpi) {
+		struct otg_transceiver *otg = ehci->ulpi;
+
+		otg_set_vbus(otg, 1);
+	}
+#endif
 #endif
 	/* GRR this is run-once init(), being done every time the HC starts.
 	 * So long as they're part of class devices, we can't do it init()
diff -uNr linux-xlnx//drivers/usb/host/ehci-xilinx-usbps.c linux-xlnx_xfb_14.1_build3//drivers/usb/host/ehci-xilinx-usbps.c
--- linux-xlnx//drivers/usb/host/ehci-xilinx-usbps.c	2012-05-15 03:09:09.000000000 +0200
+++ linux-xlnx_xfb_14.1_build3//drivers/usb/host/ehci-xilinx-usbps.c	2012-09-18 12:36:23.650547173 +0200
@@ -23,6 +23,9 @@
 #include <linux/platform_device.h>
 #include <linux/xilinx_devices.h>
 #include <linux/usb/otg.h>
+#ifdef CONFIG_XILINX_ZED
+#include <linux/usb/ulpi.h>
+#endif
 #include <linux/usb/xilinx_usbps_otg.h>
 
 #include "ehci-xilinx-usbps.h"
@@ -165,6 +168,16 @@
 #ifdef CONFIG_USB_XUSBPS_OTG
 	ehci = hcd_to_ehci(hcd);
 	if (pdata->otg) {
+#ifdef CONFIG_XILINX_ZED
+		pr_info ("usb_hcd_xusbps_probe: Have OTG assigned.\n");
+
+		retval = otg_init(pdata->otg);
+		if (retval) {
+			dev_err(&pdev->dev, "Unable to init transceiver, probably missing\n");
+			return ENODEV;
+		}
+#endif
+
 		ehci->transceiver = pdata->otg;
 		retval = otg_set_host(ehci->transceiver,
 				&ehci_to_hcd(ehci)->self);
@@ -177,6 +190,19 @@
 		/* inform otg driver about host driver */
 		xusbps_update_transceiver();
 	} else {
+#ifdef CONFIG_XILINX_ZED
+		pr_info ("usb_hcd_xusbps_probe: No OTG assigned!\n");
+		if (!pdata->otg) {
+			pdata->otg = otg_ulpi_create (&ulpi_viewport_access_ops,
+				ULPI_OTG_DRVVBUS | ULPI_OTG_DRVVBUS_EXT);
+			if (pdata->otg) {
+				pdata->otg->io_priv = hcd->regs + XUSBPS_SOC_USB_ULPIVP;
+				ehci->ulpi = pdata->otg;
+			}
+		}
+		pr_info ("usb_hcd_xusbps_probe: OTG now assigned!\n");
+#endif
+
 		retval = usb_add_hcd(hcd, irq, IRQF_DISABLED | IRQF_SHARED);
 		if (retval != 0)
 			goto err2;
diff -uNr linux-xlnx//drivers/usb/otg/ulpi.c linux-xlnx_xfb_14.1_build3//drivers/usb/otg/ulpi.c
--- linux-xlnx//drivers/usb/otg/ulpi.c	2012-05-15 03:09:09.000000000 +0200
+++ linux-xlnx_xfb_14.1_build3//drivers/usb/otg/ulpi.c	2012-09-18 12:36:23.650547173 +0200
@@ -46,6 +46,7 @@
 static struct ulpi_info ulpi_ids[] = {
 	ULPI_INFO(ULPI_ID(0x04cc, 0x1504), "NXP ISP1504"),
 	ULPI_INFO(ULPI_ID(0x0424, 0x0006), "SMSC USB331x"),
+	ULPI_INFO(ULPI_ID(0x0451, 0x1507), "TI TUSB1210"),
 };
 
 static int ulpi_set_otg_flags(struct otg_transceiver *otg)
diff -uNr linux-xlnx//drivers/video/xylon/xylonfb/core/clkgen.c linux-xlnx_xfb_14.1_build3//drivers/video/xylon/xylonfb/core/clkgen.c
--- linux-xlnx//drivers/video/xylon/xylonfb/core/clkgen.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-xlnx_xfb_14.1_build3//drivers/video/xylon/xylonfb/core/clkgen.c	2012-09-13 17:05:43.071452000 +0200
@@ -0,0 +1,482 @@
+/*
+ * Xylon logiCVC frame buffer driver - pixel clock generation using clkgen IP core
+ *
+ * Author: Xylon d.o.o.
+ * e-mail: gpantar@logicbricks.com
+ *
+ * 2012 (c) Xylon d.o.o.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#if	defined(CONFIG_FB_XYLON_CLKGEN_PIXCLK)
+
+#include <linux/module.h>
+#include <linux/io.h>
+#include <asm/io.h>
+#include <linux/kernel.h>
+#include "clkgen.h"
+
+#define	FRAC_PRECISION 10
+#define	FIXED_WIDTH		32
+
+#define	DEBUG_PRINTF(format, ...) //do { printk(KERN_INFO format, ## __VA_ARGS__); }while(0)
+
+/* Clkgen register ofsets (4byte distance) */
+#define	CKLGEN_RST_REG_OFF		(0)
+#define	CKLGEN_PLL_OFF			(1)
+#define	CKLGEN_RAM_OFF			(3)
+#define	CLKGEN_PLL_RST_MASK		0x1
+
+static inline long get_bits(long long input, long msb, long	lsb)
+{
+	return (input>>lsb) & ( (1<<(msb-lsb+1))-1 );
+}
+
+static long	round_frac(	long decimal, long precision)
+{
+	long ret;
+	DEBUG_PRINTF("round_frac - decimal:	%lx, precision:	%ld\n",	decimal, precision);
+	if( decimal & (1<<(FRAC_PRECISION-precision-1))){
+		ret = decimal + (1<<(FRAC_PRECISION-precision-1));
+	}
+	else{
+		ret = decimal;
+	}
+
+	DEBUG_PRINTF("round_frac: %lx\n", ret);
+	return ret;
+}
+
+static long	pll_divider(long divide, long duty_cycle){
+	long  duty_cycle_fix;
+	long	high_time;
+	long	low_time;
+	long	w_edge;
+	long	no_count;
+	long	temp;
+
+	if(duty_cycle <=0 || duty_cycle	>= 100000) {
+		DEBUG_PRINTF("ERROR: duty_cycle: %ld is	invalid", duty_cycle);
+		return -1;
+	}
+	duty_cycle_fix = (duty_cycle <<	FRAC_PRECISION)	/ 100000;
+
+	if(divide == 1) {
+		high_time	= 1;
+		w_edge		= 0;
+		low_time	= 1;
+		no_count	= 1;
+	}
+	else{
+		temp = round_frac(duty_cycle_fix*divide, 1);
+		high_time =	get_bits(temp,FRAC_PRECISION+7 -1, FRAC_PRECISION+1-1);
+		w_edge = get_bits(temp,FRAC_PRECISION-1, FRAC_PRECISION-1);
+
+		if(high_time ==	0) {
+		high_time	= 1;
+		w_edge		= 0;
+		}
+		if(high_time ==	divide)	{
+		high_time	= divide - 1;
+		w_edge		= 1;
+		}
+		low_time	= divide - high_time;
+		no_count	= 0;
+	}
+
+	return ( ((low_time&0x3f) <<  0) |
+			 ((high_time&0x3f) <<  6) |
+			 ((no_count&0x1	) << 12) |
+			 ((w_edge  &0x1	 ) << 13) );
+}
+
+
+static long pll_phase(long	divide,	long phase)
+{
+	long phase_in_cycles;
+	long phase_fixed;
+	long mx;
+	long delay_time;
+	long phase_mux;
+	long temp;
+
+	if((phase < -360000) || (phase	> 360000)) {
+		return -1;
+	}
+
+	if(phase < 0){
+		phase_fixed	= (	(phase + 360000) <<	FRAC_PRECISION ) / 1000;
+	}else{
+		phase_fixed	= (	phase << FRAC_PRECISION	) /	1000;
+	}
+
+	phase_in_cycles	= (	phase_fixed	* divide ) / 360;
+
+	temp  =	 round_frac(phase_in_cycles, 3);
+
+	mx			= 0;
+	phase_mux	= get_bits(temp	   , FRAC_PRECISION-1  ,FRAC_PRECISION-2-1);
+	delay_time	= get_bits(temp	   , FRAC_PRECISION+6-1,FRAC_PRECISION+1-1);
+
+	return (((delay_time &0x3f) << 0)|
+			((phase_mux  &0x07) << 6)|
+			((mx		 &0x3 ) << 9));
+}
+
+
+
+static long	long pll_lock_lookup(long divide)
+{
+	long long lookup[] ={
+	0x31BE8FA401,
+	0x31BE8FA401,
+	0x423E8FA401,
+	0x5AFE8FA401,
+	0x73BE8FA401,
+	0x8C7E8FA401,
+	0x9CFE8FA401,
+	0xB5BE8FA401,
+	0xCE7E8FA401,
+	0xE73E8FA401,
+	0xFFF84FA401,
+	0xFFF39FA401,
+	0xFFEEEFA401,
+	0xFFEBCFA401,
+	0xFFE8AFA401,
+	0xFFE71FA401,
+	0xFFE3FFA401,
+	0xFFE26FA401,
+	0xFFE0DFA401,
+	0xFFDF4FA401,
+	0xFFDDBFA401,
+	0xFFDC2FA401,
+	0xFFDA9FA401,
+	0xFFD90FA401,
+	0xFFD90FA401,
+	0xFFD77FA401,
+	0xFFD5EFA401,
+	0xFFD5EFA401,
+	0xFFD45FA401,
+	0xFFD45FA401,
+	0xFFD2CFA401,
+	0xFFD2CFA401,
+	0xFFD2CFA401,
+	0xFFD13FA401,
+	0xFFD13FA401,
+	0xFFD13FA401,
+	0xFFCFAFA401,
+	0xFFCFAFA401,
+	0xFFCFAFA401,
+	0xFFCFAFA401,
+	0xFFCFAFA401,
+	0xFFCFAFA401,
+	0xFFCFAFA401,
+	0xFFCFAFA401,
+	0xFFCFAFA401,
+	0xFFCFAFA401,
+	0xFFCFAFA401,
+	0xFFCFAFA401,
+	0xFFCFAFA401,
+	0xFFCFAFA401,
+	0xFFCFAFA401,
+	0xFFCFAFA401,
+	0xFFCFAFA401,
+	0xFFCFAFA401,
+	0xFFCFAFA401,
+	0xFFCFAFA401,
+	0xFFCFAFA401,
+	0xFFCFAFA401,
+	0xFFCFAFA401,
+	0xFFCFAFA401,
+	0xFFCFAFA401,
+	0xFFCFAFA401,
+	0xFFCFAFA401,
+	0xFFCFAFA401 };
+	return lookup[divide-1];
+}
+
+static long	pll_filter_lookup(long divide, int bandwithIsLow )
+{
+	long lookup_entry;
+	long  lookup_low[] = {
+		 0x5F,
+		 0x57,
+		 0x7B,
+		 0x5B,
+		 0x6B,
+		 0x73,
+		 0x73,
+		 0x73,
+		 0x73,
+		 0x4B,
+		 0x4B,
+		 0x4B,
+		 0xB3,
+		 0x53,
+		 0x53,
+		 0x53,
+		 0x53,
+		 0x53,
+		 0x53,
+		 0x53,
+		 0x53,
+		 0x53,
+		 0x53,
+		 0x63,
+		 0x63,
+		 0x63,
+		 0x63,
+		 0x63,
+		 0x63,
+		 0x63,
+		 0x63,
+		 0x63,
+		 0x63,
+		 0x63,
+		 0x63,
+		 0x63,
+		 0x63,
+		 0x93,
+		 0x93,
+		 0x93,
+		 0x93,
+		 0x93,
+		 0x93,
+		 0x93,
+		 0x93,
+		 0x93,
+		 0x93,
+		 0xA3,
+		 0xA3,
+		 0xA3,
+		 0xA3,
+		 0xA3,
+		 0xA3,
+		 0xA3,
+		 0xA3,
+		 0xA3,
+		 0xA3,
+		 0xA3,
+		 0xA3,
+		 0xA3,
+		 0xA3,
+		 0xA3,
+		 0xA3,
+		 0xA3 };
+	long  lookup_high[]	= {
+		 0x17C,
+		 0x3FC,
+		 0x3F4,
+		 0x3E4,
+		 0x3F8,
+		 0x3C4,
+		 0x3C4,
+		 0x3D8,
+		 0x3E8,
+		 0x3E8,
+		 0x3E8,
+		 0x3B0,
+		 0x3F0,
+		 0x3F0,
+		 0x3F0,
+		 0x3F0,
+		 0x3F0,
+		 0x3F0,
+		 0x3F0,
+		 0x3F0,
+		 0x3B0,
+		 0x3B0,
+		 0x3B0,
+		 0x3E8,
+		 0x370,
+		 0x308,
+		 0x370,
+		 0x370,
+		 0x3E8,
+		 0x3E8,
+		 0x3E8,
+		 0x1C8,
+		 0x330,
+		 0x330,
+		 0x3A8,
+		 0x188,
+		 0x188,
+		 0x188,
+		 0x1F0,
+		 0x188,
+		 0x110,
+		 0x110,
+		 0x110,
+		 0x110,
+		 0x110,
+		 0x110,
+		 0x0E0,
+		 0x0E0,
+		 0x0E0,
+		 0x0E0,
+		 0x0E0,
+		 0x0E0,
+		 0x0E0,
+		 0x0E0,
+		 0x0E0,
+		 0x0E0,
+		 0x0E0,
+		 0x0E0,
+		 0x0E0,
+		 0x0E0,
+		 0x0E0,
+		 0x0E0,
+		 0x0E0,
+		 0x0E0};
+
+	if(bandwithIsLow) {
+		lookup_entry =	lookup_low[divide-1];
+	} else{
+		lookup_entry =	lookup_high[divide-1];
+	}
+	return lookup_entry;
+}
+
+static long	pll_count_calc(long	divide,	long phase,	long duty_cycle)
+{
+	long div_calc;
+	long phase_calc;
+	long ret;
+
+	div_calc = pll_divider(divide, duty_cycle);
+	phase_calc = pll_phase(divide, phase);
+
+	ret= ( (get_bits(div_calc,	 11, 0)	<<	0)	|
+		 (get_bits(phase_calc,	8, 6) <<  13) |
+		 (get_bits(phase_calc,	5, 0) <<  16) |
+		 (get_bits(div_calc	 , 13,12) <<  22) |
+		 (get_bits(phase_calc, 10, 9) <<  24) );
+
+	return ret;
+}
+
+static long	calc_pll_mult(long	osc_clk_freq, long out_clk_freq)
+{
+	long freq=0;
+	long freq_err=(1<<30)-1;
+	long freq_err_new=0;
+	long mult_const=0;
+	int	i,j;
+
+	freq_err = (1<<30)-1;
+	freq_err_new = 0;
+	for(j = 1;	j<=64; j++){
+		for(i = 1;	i<=52; i++){
+			freq = (osc_clk_freq/1000000*i)/j;
+			if((osc_clk_freq/1000000*i) < 800 || (osc_clk_freq/1000000*i) > 1600){
+				freq_err_new = (1<<30)-1;
+			}
+			else{
+				freq_err_new = abs (out_clk_freq*10	- freq*1000000);
+			}
+			if (freq_err_new < freq_err) {
+				freq_err = freq_err_new;
+				mult_const = i;
+			}
+		}
+	 }
+
+		return mult_const;
+
+}
+static long	calc_pll_div(long	osc_clk_freq, long out_clk_freq, long mult_const)
+{
+	long freq=0;
+	long freq_err=(1<<30)-1;
+	long freq_err_new=0;
+	long x1_divide_const=0;
+	int	j;
+
+
+	freq_err = (1<<30)-1;
+	freq_err_new = 0;
+	for(j = 1;	j<=64; j++){ //-- divide
+		freq = (osc_clk_freq/1000000*mult_const)/j;
+		freq_err_new = abs (out_clk_freq*1 - freq*1000000);
+		if(freq_err_new < freq_err) {
+			freq_err = freq_err_new;
+			x1_divide_const	= j;
+		}
+	}
+
+		return x1_divide_const;
+
+}
+
+void clkgen_calc_regs(struct clkgen_freq_out *freq_out, long c_clk_freq_init_hz, long c_osc_clk_freq_hz, long *regs_out)
+{
+	const long clkout_phase	= 0;
+	const long clkfbout_phase =	0;
+	const long clkout_duty = 50000;
+	const long bandwith	= 0; //	not	low	(optimised)
+	const long divclk_divide = 1;
+	long clkout_divide[NUM_CLK_OUTPUTS];
+	long clkfbout_mult;
+
+	long clkout[NUM_CLK_OUTPUTS];
+	long divclk;
+	long clkfbout;
+	long long lock;
+	long digital_filt;
+
+	int	i;
+
+    clkfbout_mult = calc_pll_mult(c_osc_clk_freq_hz, c_clk_freq_init_hz);
+
+
+	for(i=0;i<NUM_CLK_OUTPUTS;i++){
+		clkout_divide[i] = calc_pll_div(c_osc_clk_freq_hz, freq_out->freq_out_hz[i], clkfbout_mult);
+	}
+
+
+
+	for(i=0;i<NUM_CLK_OUTPUTS;i++){
+		clkout[i] =	pll_count_calc(clkout_divide[i], clkout_phase, clkout_duty);
+	}
+
+
+	divclk = pll_count_calc(divclk_divide, 0, 50000);
+	clkfbout = pll_count_calc(clkfbout_mult,clkfbout_phase,	clkout_duty);
+
+	digital_filt = pll_filter_lookup(clkfbout_mult, bandwith);
+	lock = pll_lock_lookup(clkfbout_mult);
+
+	regs_out[0]	= 0xFFFF;
+	for(i=0;i<NUM_CLK_OUTPUTS;i++){
+		regs_out[1+i*2 + 0 ] =	get_bits(clkout[i],	15,	0);
+		regs_out[1+i*2 + 1 ] =	get_bits(clkout[i],	31,	16);
+	}
+
+	regs_out[13] = (get_bits(divclk, 23, 22)<<12)|(get_bits(divclk,	11,	0)<<0);//DIVCLK[23:22] & DIVCLK[11:0]
+	regs_out[14] =  get_bits(clkfbout ,	15,	 0); //CLKFBOUT[15:0]
+	regs_out[15] =  get_bits(clkfbout ,	31,	16); //CLKFBOUT[31:16]
+	regs_out[16] =  get_bits(lock	  ,	29,	20); //LOCK[29:20]
+	regs_out[17] = (get_bits(lock	  ,	34,	30)<<10)|get_bits(lock , 9,	  0); //LOCK[34:30]	& LOCK[9:0]
+	regs_out[18] = (get_bits(lock	  ,	39,	35)<<10)|get_bits(lock , 19, 10); //LOCK[39:35]	& S10_LOCK[19:10]
+	regs_out[19] = (get_bits(digital_filt	  ,	6, 6)<<	8) |
+				   (get_bits(digital_filt	  ,	8, 7)<<11) |
+				   (get_bits(digital_filt	  ,	9, 9)<<15);
+					//DIGITAL_FILT[9] &	00 & DIGITAL_FILT[8:7] & 00	& DIGITAL_FILT[6] &	0000000
+
+
+	regs_out[20] = (get_bits(digital_filt	  ,	0, 0)<<	4) |
+				   (get_bits(digital_filt	  ,	2, 1)<<	7) |
+				   (get_bits(digital_filt	  ,	4, 3)<<11) |
+				   (get_bits(digital_filt	  ,	5, 5)<<15);
+					//DIGITAL_FILT[5] &	00 & DIGITAL_FILT[4:3] & 00	& DIGITAL_FILT[2:1]	& 00 & DIGITAL_FILT[0] & 0000
+
+	DEBUG_PRINTF("clkgen_calc_regs:	c_osc_clk_freq_hz %ld, freq_out->freq_out_hz[0]=%ld	\n", c_osc_clk_freq_hz,	freq_out->freq_out_hz[0] );
+	for(i=0;i<21;i++){
+		DEBUG_PRINTF("reg[%d]=0x%lx\n",	i, regs_out[i]);
+	}
+}
+
+#endif /* #if defined(FB_XYLON_CLKGEN_PIXCLK) */
\ No newline at end of file
diff -uNr linux-xlnx//drivers/video/xylon/xylonfb/core/clkgen.h linux-xlnx_xfb_14.1_build3//drivers/video/xylon/xylonfb/core/clkgen.h
--- linux-xlnx//drivers/video/xylon/xylonfb/core/clkgen.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-xlnx_xfb_14.1_build3//drivers/video/xylon/xylonfb/core/clkgen.h	2012-09-13 17:11:00.180093000 +0200
@@ -0,0 +1,35 @@
+/*
+ * Xylon logiCVC frame buffer driver - pixel clock generation using clkgen IP core
+ *
+ * Author: Xylon d.o.o.
+ * e-mail: gpantar@logicbricks.com
+ *
+ * 2012 (c) Xylon d.o.o.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+
+/***************************** Include Files *********************************/
+
+
+
+#define NUM_CLK_OUTPUTS 6
+#define NUM_CLK_REGS 21
+
+#define	CKLGEN_RST_REG_OFF		(0)
+#define	CKLGEN_PLL_OFF			(1)
+#define	CKLGEN_RAM_OFF			(3)
+#define	CLKGEN_PLL_RST_MASK		0x1
+
+struct clkgen_freq_out
+{
+    long freq_out_hz[NUM_CLK_OUTPUTS];
+};
+
+
+/** Calculates the output registers depending on the freq_out and  c_osc_clk_freq_hz inputs,
+ *  and writes them to array of NUM_CLK_REGS over regs_out pointer*/
+void clkgen_calc_regs(struct clkgen_freq_out *freq_out, long c_clk_freq_init_hz, long c_osc_clk_freq_hz, long *regs_out);
diff -uNr linux-xlnx//drivers/video/xylon/xylonfb/core/logicvc.h linux-xlnx_xfb_14.1_build3//drivers/video/xylon/xylonfb/core/logicvc.h
--- linux-xlnx//drivers/video/xylon/xylonfb/core/logicvc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-xlnx_xfb_14.1_build3//drivers/video/xylon/xylonfb/core/logicvc.h	2012-06-29 20:36:16.000000000 +0200
@@ -0,0 +1,165 @@
+/*
+ * Xylon logiCVC IP core v2.05c definitions
+ *
+ * Author: Xylon d.o.o.
+ * e-mail: davor.joja@logicbricks.com
+ *
+ * 2012 (c) Xylon d.o.o.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#ifndef __LOGICVC_H__
+#define __LOGICVC_H__
+
+/* All logiCVC registers are 32 bit registers */
+/* All logiCVC registers are at 8 byte distance */
+#define LOGICVC_REG_DIST_USED      8
+/* R_HSY_FP */
+#define LOGICVC_SHSY_FP_ROFF      (0  * LOGICVC_REG_DIST_USED)
+/* R_HSY */
+#define LOGICVC_SHSY_ROFF         (1  * LOGICVC_REG_DIST_USED)
+/* R_HSY_BP */
+#define LOGICVC_SHSY_BP_ROFF      (2  * LOGICVC_REG_DIST_USED)
+/* R_HSY_RES */
+#define LOGICVC_SHSY_RES_ROFF     (3  * LOGICVC_REG_DIST_USED)
+/* R_VSY_FP */
+#define LOGICVC_SVSY_FP_ROFF      (4  * LOGICVC_REG_DIST_USED)
+/* R_VSY */
+#define LOGICVC_SVSY_ROFF         (5  * LOGICVC_REG_DIST_USED)
+/* R_VSY_BP */
+#define LOGICVC_SVSY_BP_ROFF      (6  * LOGICVC_REG_DIST_USED)
+/* R_VSY_RES */
+#define LOGICVC_SVSY_RES_ROFF     (7  * LOGICVC_REG_DIST_USED)
+/* R_CTRL */
+#define LOGICVC_SCTRL_ROFF        (8  * LOGICVC_REG_DIST_USED)
+/* R_DTYPE */
+#define LOGICVC_SDTYPE_ROFF       (9  * LOGICVC_REG_DIST_USED)
+/* R_BACKGROUND */
+#define LOGICVC_BACKCOL_ROFF      (10 * LOGICVC_REG_DIST_USED)
+/* R_DOUBLE_VBUFF */
+#define LOGICVC_DOUBLE_VBUFF_ROFF (11 * LOGICVC_REG_DIST_USED)
+/* R_DOUBLE_CLUT */
+#define LOGICVC_DOUBLE_CLUT_ROFF  (12 * LOGICVC_REG_DIST_USED)
+/* R_INT */
+#define LOGICVC_INT_ROFF          (13 * LOGICVC_REG_DIST_USED)
+/* R_INT_MASK */
+#define LOGICVC_INT_MASK_ROFF     (14 * LOGICVC_REG_DIST_USED)
+/* R_PWRCTRL */
+#define LOGICVC_SPWRCTRL_ROFF     (15 * LOGICVC_REG_DIST_USED)
+
+/* logiCVC layer registers base and distance between the layers */
+/* distance between groups of layer registers */
+#define LOGICVC_LAYER_DISTANCE   (16  * LOGICVC_REG_DIST_USED)
+/* offset to the beginning of layer 0 registers */
+#define LOGICVC_LAYER0_BASE_ROFF (32  * LOGICVC_REG_DIST_USED)
+/* offset to the beginning of layer 1 registers */
+#define LOGICVC_LAYER1_BASE_ROFF \
+	(LOGICVC_LAYER0_BASE_ROFF + LOGICVC_LAYER_DISTANCE * 1)
+/* offset to the beginning of layer 2 registers */
+#define LOGICVC_LAYER2_BASE_ROFF \
+	(LOGICVC_LAYER0_BASE_ROFF + LOGICVC_LAYER_DISTANCE * 2)
+/* offset to the beginning of layer 3 registers */
+#define LOGICVC_LAYER3_BASE_ROFF \
+	(LOGICVC_LAYER0_BASE_ROFF + LOGICVC_LAYER_DISTANCE * 3)
+/* offset to the beginning of layer 4 registers */
+#define LOGICVC_LAYER4_BASE_ROFF \
+	(LOGICVC_LAYER0_BASE_ROFF + LOGICVC_LAYER_DISTANCE * 4)
+
+/* logiCVC layer registers offsets (common for each layer) */
+/*  LH_OFFSET */
+#define LOGICVC_LAYER_HOR_OFF_ROFF (0 * LOGICVC_REG_DIST_USED)
+/*  LV_OFFSET */
+#define LOGICVC_LAYER_VER_OFF_ROFF (1 * LOGICVC_REG_DIST_USED)
+/*  LH_POSITION */
+#define LOGICVC_LAYER_HOR_POS_ROFF (2 * LOGICVC_REG_DIST_USED)
+/*  LV_POSITION */
+#define LOGICVC_LAYER_VER_POS_ROFF (3 * LOGICVC_REG_DIST_USED)
+/*  LH_WIDTH */
+#define LOGICVC_LAYER_WIDTH_ROFF   (4 * LOGICVC_REG_DIST_USED)
+/*  LV_HEIGHT */
+#define LOGICVC_LAYER_HEIGHT_ROFF  (5 * LOGICVC_REG_DIST_USED)
+/*  ALPHA */
+#define LOGICVC_LAYER_ALPHA_ROFF   (6 * LOGICVC_REG_DIST_USED)
+/*  CTRL */
+#define LOGICVC_LAYER_CTRL_ROFF    (7 * LOGICVC_REG_DIST_USED)
+/*  TRANSPARENT */
+#define LOGICVC_LAYER_TRANSP_ROFF  (8 * LOGICVC_REG_DIST_USED)
+
+/* logiCVC interrupt bits */
+#define LOGICVC_L0_VBUFF_SW_INT   0x01
+#define LOGICVC_L1_VBUFF_SW_INT   0x02
+#define LOGICVC_L2_VBUFF_SW_INT   0x04
+#define LOGICVC_L3_VBUFF_SW_INT   0x08
+#define LOGICVC_L4_VBUFF_SW_INT   0x10
+#define LOGICVC_V_SYNC_INT        0x20
+#define LOGICVC_E_VIDEO_VALID_INT 0x40
+#define LOGICVC_L0_CLUT_SW_INT    0x100
+#define LOGICVC_L1_CLUT_SW_INT    0x200
+#define LOGICVC_L2_CLUT_SW_INT    0x400
+#define LOGICVC_L3_CLUT_SW_INT    0x800
+#define LOGICVC_L4_CLUT_SW_INT    0x1000
+
+/* logiCVC layer base offsets */
+#define LOGICVC_LAYER_BASE_OFFSET 0x100
+#define LOGICVC_LAYER_0_OFFSET    0
+#define LOGICVC_LAYER_1_OFFSET    0x80
+#define LOGICVC_LAYER_2_OFFSET    0x100
+#define LOGICVC_LAYER_3_OFFSET    0x180
+#define LOGICVC_LAYER_4_OFFSET    0x200
+
+/* logiCVC layer CLUT base offsets */
+#define LOGICVC_CLUT_BASE_OFFSET      0x1000
+#define LOGICVC_CLUT_L0_CLUT_0_OFFSET 0
+#define LOGICVC_CLUT_L0_CLUT_1_OFFSET 0x800
+#define LOGICVC_CLUT_L1_CLUT_0_OFFSET 0x1000
+#define LOGICVC_CLUT_L1_CLUT_1_OFFSET 0x1800
+#define LOGICVC_CLUT_L2_CLUT_0_OFFSET 0x2000
+#define LOGICVC_CLUT_L2_CLUT_1_OFFSET 0x2800
+#define LOGICVC_CLUT_L3_CLUT_0_OFFSET 0x3000
+#define LOGICVC_CLUT_L3_CLUT_1_OFFSET 0x3800
+#define LOGICVC_CLUT_L4_CLUT_0_OFFSET 0x4000
+#define LOGICVC_CLUT_L4_CLUT_1_OFFSET 0x4800
+#define LOGICVC_CLUT_REGISTER_SIZE    8
+#define LOGICVC_CLUT_0_INDEX_OFFSET   2
+#define LOGICVC_CLUT_1_INDEX_OFFSET   1
+
+/* logiCVC register and CLUT base offsets */
+#define LOGICVC_GENERAL_REGISTERS_RANGE 0x100
+#define LOGICVC_REGISTERS_RANGE         0x6000
+
+/* logiCVC register initial values */
+#define CTRL_REG_INIT 0x001F
+#define SD_REG_INIT   0
+
+/* logiCVC display power signals */
+#define LOGICVC_EN_BLIGHT_MSK 0x01
+#define LOGICVC_EN_VDD_MSK    0x02
+#define LOGICVC_EN_VEE_MSK    0x04
+#define LOGICVC_V_EN_MSK      0x08
+
+/* logiCVC various definitions */
+#define LOGICVC_PIX_DATA_INVERT        0x80
+#define LOGICVC_PIX_ACT_HIGH           0x100
+#define LOGICVC_SWAP_RB                0x10
+#define LOGICVC_MAX_LAYERS             5
+#define LOGICVC_LAYER_ON               0x10
+#define LOGICVC_MAX_XRES               2048
+#define LOGICVC_MAX_VRES               2048
+#define TRANSPARENT_COLOR_8BPP         0x25       /* dummy */
+#define TRANSPARENT_COLOR_8BPP_CLUT_16 0xF813     /* dummy */
+#define TRANSPARENT_COLOR_8BPP_CLUT_24 0x00FF009C /* dummy */
+#define TRANSPARENT_COLOR_16BPP        0xF813     /* dummy */
+#define TRANSPARENT_COLOR_24BPP        0x00FF009C /* dummy */
+#define BACKGROUND_COLOR               0x00000000
+
+enum xylonfb_alpha_format {
+	LOGICVC_LAYER_ALPHA = 0,
+	LOGICVC_PIXEL_ALPHA,
+	LOGICVC_CLUT_16BPP_ALPHA,
+	LOGICVC_CLUT_32BPP_ALPHA
+};
+
+#endif /* __LOGICVC_H__ */
diff -uNr linux-xlnx//drivers/video/xylon/xylonfb/core/xylonfb.c linux-xlnx_xfb_14.1_build3//drivers/video/xylon/xylonfb/core/xylonfb.c
--- linux-xlnx//drivers/video/xylon/xylonfb/core/xylonfb.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-xlnx_xfb_14.1_build3//drivers/video/xylon/xylonfb/core/xylonfb.c	2012-09-18 12:20:19.483062000 +0200
@@ -0,0 +1,1493 @@
+/*
+ * Xylon logiCVC frame buffer driver core functions
+ *
+ * Author: Xylon d.o.o.
+ * e-mail: davor.joja@logicbricks.com
+ *
+ * This driver was based on skeletonfb.c and other framebuffer video drivers.
+ * 2012 Xylon d.o.o.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+/*
+	Usefull driver information:
+	- driver does not support multiple instances of logiCVC-ML
+	- logiCVC-ML background layer is recomended
+	- platform driver default resolution is set with defines in xylonfb-vmode.h
+ */
+
+
+#include <linux/module.h>
+#include <linux/dma-mapping.h>
+#include <linux/delay.h>
+#include <linux/uaccess.h>
+#include <linux/console.h>
+#include "xylonfb.h"
+
+
+#define XYLONFB_PSEUDO_PALETTE_SZ 256
+
+
+static struct xylonfb_vmode_data xylonfb_vmode = {
+	.fb_vmode = {
+		.refresh = 60,
+		.xres = 1024,
+		.yres = 768,
+		.pixclock = KHZ2PICOS(65000),
+		.left_margin = 160,
+		.right_margin = 24,
+		.upper_margin = 29,
+		.lower_margin = 3,
+		.hsync_len = 136,
+		.vsync_len = 6,
+		.vmode = FB_VMODE_NONINTERLACED
+	},
+	.fb_vmode_name = "1024x768"
+};
+
+static unsigned short logicvc_layer_reg_offset[] = {
+	(LOGICVC_LAYER_BASE_OFFSET + LOGICVC_LAYER_0_OFFSET),
+	(LOGICVC_LAYER_BASE_OFFSET + LOGICVC_LAYER_1_OFFSET),
+	(LOGICVC_LAYER_BASE_OFFSET + LOGICVC_LAYER_2_OFFSET),
+	(LOGICVC_LAYER_BASE_OFFSET + LOGICVC_LAYER_3_OFFSET),
+	(LOGICVC_LAYER_BASE_OFFSET + LOGICVC_LAYER_4_OFFSET)
+};
+
+static unsigned short logicvc_clut_reg_offset[] = {
+	(LOGICVC_CLUT_BASE_OFFSET + LOGICVC_CLUT_L0_CLUT_0_OFFSET),
+	(LOGICVC_CLUT_BASE_OFFSET + LOGICVC_CLUT_L0_CLUT_1_OFFSET),
+	(LOGICVC_CLUT_BASE_OFFSET + LOGICVC_CLUT_L1_CLUT_0_OFFSET),
+	(LOGICVC_CLUT_BASE_OFFSET + LOGICVC_CLUT_L1_CLUT_1_OFFSET),
+	(LOGICVC_CLUT_BASE_OFFSET + LOGICVC_CLUT_L2_CLUT_0_OFFSET),
+	(LOGICVC_CLUT_BASE_OFFSET + LOGICVC_CLUT_L2_CLUT_1_OFFSET),
+	(LOGICVC_CLUT_BASE_OFFSET + LOGICVC_CLUT_L3_CLUT_0_OFFSET),
+	(LOGICVC_CLUT_BASE_OFFSET + LOGICVC_CLUT_L3_CLUT_1_OFFSET),
+	(LOGICVC_CLUT_BASE_OFFSET + LOGICVC_CLUT_L4_CLUT_0_OFFSET),
+	(LOGICVC_CLUT_BASE_OFFSET + LOGICVC_CLUT_L4_CLUT_1_OFFSET)
+};
+
+static char *xylonfb_mode_option;
+
+/* Function declarations */
+static int xylonfb_set_timings(struct fb_info *fbi, int bpp);
+static void xylonfb_logicvc_disp_ctrl(struct fb_info *fbi, bool enable);
+static void xylonfb_start_logicvc(struct fb_info *fbi);
+static void xylonfb_stop_logicvc(struct fb_info *fbi);
+static void xylonfb_enable_logicvc_layer(struct fb_info *fbi);
+static void xylonfb_disable_logicvc_layer(struct fb_info *fbi);
+
+
+extern int xylonfb_hw_pixclk_set(unsigned long pixclk_khz);
+extern bool xylonfb_hw_pixclk_change(void);
+
+
+static irqreturn_t xylonfb_isr(int irq, void *dev_id)
+{
+	struct fb_info **afbi = (struct fb_info **)dev_id;
+	struct fb_info *fbi = afbi[0];
+	struct xylonfb_layer_data *layer_data = fbi->par;
+	struct xylonfb_common_data *common_data = layer_data->xylonfb_cd;
+	u32 isr;
+
+	driver_devel("%s IRQ %d\n", __func__, irq);
+
+	isr = readl(layer_data->reg_base_virt + LOGICVC_INT_ROFF);
+	if (isr & LOGICVC_V_SYNC_INT) {
+		writel(LOGICVC_V_SYNC_INT,
+			layer_data->reg_base_virt + LOGICVC_INT_ROFF);
+		common_data->xylonfb_vsync.cnt++;
+		wake_up_interruptible(&common_data->xylonfb_vsync.wait);
+		return IRQ_HANDLED;
+	} else {
+		return IRQ_NONE;
+	}
+}
+
+static int xylonfb_open(struct fb_info *fbi, int user)
+{
+	struct xylonfb_layer_data *layer_data = fbi->par;
+
+	driver_devel("%s\n", __func__);
+
+	if (layer_data->layer_use_ref == 0) {
+		/* turn on layer */
+		xylonfb_enable_logicvc_layer(fbi);
+		/* set layer ON flag */
+		layer_data->layer_flags |= LOGICVC_LAYER_ON;
+	}
+	layer_data->layer_use_ref++;
+	layer_data->xylonfb_cd->xylonfb_use_ref++;
+
+	return 0;
+}
+
+static int xylonfb_release(struct fb_info *fbi, int user)
+{
+	struct xylonfb_layer_data *layer_data = fbi->par;
+
+	driver_devel("%s\n", __func__);
+
+	layer_data->layer_use_ref--;
+	if (layer_data->layer_use_ref == 0) {
+		/* turn off layer */
+		xylonfb_disable_logicvc_layer(fbi);
+		/* set layer OFF flag */
+		layer_data->layer_flags &= (~LOGICVC_LAYER_ON);
+	}
+	layer_data->xylonfb_cd->xylonfb_use_ref--;
+
+	return 0;
+}
+
+static int xylonfb_check_var(struct fb_var_screeninfo *var, struct fb_info *fbi)
+{
+	driver_devel("%s\n", __func__);
+
+	/* HW layer bpp value can not be changed */
+	if (var->bits_per_pixel != fbi->var.bits_per_pixel) {
+		if (var->bits_per_pixel == 24)
+			var->bits_per_pixel = 32;
+		else
+			return -EINVAL;
+	}
+
+	if (var->xres > LOGICVC_MAX_XRES)
+		var->xres = LOGICVC_MAX_XRES;
+	if (var->yres > LOGICVC_MAX_VRES)
+		var->yres = LOGICVC_MAX_VRES;
+
+	if (var->xres_virtual > fbi->var.xres_virtual)
+		var->xres_virtual = fbi->var.xres_virtual;
+	if (var->yres_virtual > fbi->var.yres_virtual)
+		var->yres_virtual = fbi->var.yres_virtual;
+
+	if (fbi->var.xres != 0)
+		if ((var->xoffset + fbi->var.xres) >= fbi->var.xres_virtual)
+			var->xoffset = fbi->var.xres_virtual - fbi->var.xres - 1;
+	if (fbi->var.yres != 0)
+		if ((var->yoffset + fbi->var.yres) >= fbi->var.yres_virtual)
+			var->yoffset = fbi->var.yres_virtual - fbi->var.yres - 1;
+
+	var->transp.offset = fbi->var.transp.offset;
+	var->transp.length = fbi->var.transp.length;
+	var->transp.msb_right = fbi->var.transp.msb_right;
+	var->red.offset = fbi->var.red.offset;
+	var->red.length = fbi->var.red.length;
+	var->red.msb_right = fbi->var.red.msb_right;
+	var->green.offset = fbi->var.green.offset;
+	var->green.length = fbi->var.green.length;
+	var->green.msb_right = fbi->var.green.msb_right;
+	var->blue.offset = fbi->var.blue.offset;
+	var->blue.length = fbi->var.blue.length;
+	var->blue.msb_right = fbi->var.blue.msb_right;
+	var->height = fbi->var.height;
+	var->width = fbi->var.width;
+	var->sync = fbi->var.sync;
+	var->rotate = fbi->var.rotate;
+
+	return 0;
+}
+
+static int xylonfb_set_par(struct fb_info *fbi)
+{
+	struct xylonfb_layer_data *layer_data = fbi->par;
+	struct xylonfb_common_data *common_data = layer_data->xylonfb_cd;
+	int rc;
+	char vmode_opt[20+1];
+
+	driver_devel("%s\n", __func__);
+
+	if ((fbi->var.xres > LOGICVC_MAX_XRES) ||
+		(fbi->var.yres > LOGICVC_MAX_VRES)) {
+		return -EINVAL;
+	}
+
+	if (common_data->xylonfb_flags & FB_VMODE_SET)
+		return 0;
+
+	xylonfb_stop_logicvc(fbi);
+	xylonfb_logicvc_disp_ctrl(fbi, false);
+
+	if (xylonfb_hw_pixclk_change()) {
+		if (!(common_data->xylonfb_flags & FB_VMODE_INIT)) {
+			sprintf(vmode_opt, "%dx%dM-%d@%d",
+				fbi->var.xres, fbi->var.yres,
+				fbi->var.bits_per_pixel,
+				common_data->vmode_data_current.fb_vmode.refresh);
+			if (!strcmp(common_data->vmode_data.fb_vmode_name, vmode_opt)) {
+				common_data->vmode_data_current = common_data->vmode_data;
+			} else {
+				xylonfb_mode_option = vmode_opt;
+				xylonfb_set_timings(fbi, fbi->var.bits_per_pixel);
+				xylonfb_mode_option = NULL;
+			}
+		}
+
+		rc = xylonfb_hw_pixclk_set(
+			PICOS2KHZ(common_data->vmode_data_current.fb_vmode.pixclock));
+		if (rc) {
+			pr_err("Error xylonfb changing pixel clock\n");
+			return rc;
+		}
+	}
+
+	xylonfb_start_logicvc(fbi);
+	xylonfb_logicvc_disp_ctrl(fbi, true);
+
+	pr_info("xylonfb video mode: %dx%d-%d@%d\n",
+		fbi->var.xres, fbi->var.yres, fbi->var.bits_per_pixel,
+		common_data->vmode_data_current.fb_vmode.refresh);
+
+	/* set flag used for finding video mode only once */
+	if (common_data->xylonfb_flags & FB_VMODE_INIT)
+		common_data->xylonfb_flags |= FB_VMODE_SET;
+	/* used only when resolution is changed */
+	if (!(common_data->xylonfb_flags & FB_VMODE_SET))
+		xylonfb_enable_logicvc_layer(fbi);
+
+	return 0;
+}
+
+static int xylonfb_set_color_hw(u16 *transp, u16 *red, u16 *green, u16 *blue,
+	int len, int idx, struct fb_info *fbi)
+{
+	struct xylonfb_layer_data *layer_data = fbi->par;
+	struct layer_fix_data *lfdata = &layer_data->layer_fix;
+	u32 pixel;
+	int bpp_virt, toff, roff, goff, boff;
+
+	driver_devel("%s\n", __func__);
+
+	bpp_virt = lfdata->bpp_virt;
+
+	toff = fbi->var.transp.offset;
+	roff = fbi->var.red.offset;
+	goff = fbi->var.green.offset;
+	boff = fbi->var.blue.offset;
+
+	if (fbi->fix.visual == FB_VISUAL_PSEUDOCOLOR) {
+		u32 clut_value;
+
+		if (idx > 255 || len > 256)
+			return -EINVAL;
+
+		if (lfdata->alpha_mode == LOGICVC_CLUT_16BPP_ALPHA) {
+			if (transp) {
+				while (len > 0) {
+					clut_value =
+						((((transp[idx] & 0xFC) >> 2) << toff) |
+						(((red[idx] & 0xF8) >> 3) << roff) |
+						(((green[idx] & 0xFC) >> 2) << goff) |
+						(((blue[idx] & 0xF8) >> 3) << boff));
+					writel(clut_value, layer_data->layer_clut_base_virt +
+						(idx*LOGICVC_CLUT_REGISTER_SIZE));
+					len--;
+					idx++;
+				}
+			} else {
+				while (len > 0) {
+					clut_value =
+						((0x3F << toff) |
+						(((red[idx] & 0xF8) >> 3) << roff) |
+						(((green[idx] & 0xFC) >> 2) << goff) |
+						(((blue[idx] & 0xF8) >> 3) << boff));
+					writel(clut_value, layer_data->layer_clut_base_virt +
+						(idx*LOGICVC_CLUT_REGISTER_SIZE));
+					len--;
+					idx++;
+				}
+			}
+		} else if (lfdata->alpha_mode == LOGICVC_CLUT_32BPP_ALPHA) {
+			if (transp) {
+				while (len > 0) {
+					clut_value =
+						(((transp[idx] & 0xFF) << toff) |
+						((red[idx] & 0xFF) << roff) |
+						((green[idx] & 0xFF) << goff) |
+						((blue[idx] & 0xFF) << boff));
+					writel(clut_value, layer_data->layer_clut_base_virt +
+						(idx*LOGICVC_CLUT_REGISTER_SIZE));
+					len--;
+					idx++;
+				}
+			} else {
+				while (len > 0) {
+					clut_value =
+						((0xFF << toff) |
+						((red[idx] & 0xFF) << roff) |
+						((green[idx] & 0xFF) << goff) |
+						((blue[idx] & 0xFF) << boff));
+					writel(clut_value, layer_data->layer_clut_base_virt +
+						(idx*LOGICVC_CLUT_REGISTER_SIZE));
+					len--;
+					idx++;
+				}
+			}
+		}
+	} else if (fbi->fix.visual == FB_VISUAL_TRUECOLOR) {
+		if (bpp_virt == 8) {
+			if (lfdata->alpha_mode == LOGICVC_LAYER_ALPHA) {
+				while (len > 0) {
+					pixel = ((((red[idx] & 0xE0) >> 5) << roff) |
+						(((green[idx] & 0xE0) >> 5) << goff) |
+						(((blue[idx] & 0xC0) >> 6) << boff));
+					((u32 *)(fbi->pseudo_palette))[idx] =
+						(pixel << 24) | (pixel << 16) | (pixel << 8) | pixel;
+					len--;
+					idx++;
+				}
+			} else if (lfdata->alpha_mode == LOGICVC_PIXEL_ALPHA) {
+				if (transp) {
+					while (len > 0) {
+						pixel = ((((transp[idx] & 0xE0) >> 5) << toff) |
+							(((red[idx] & 0xE0) >> 5) << roff) |
+							(((green[idx] & 0xE0) >> 5) << goff) |
+							(((blue[idx] & 0xC0) >> 6) << boff));
+						((u32 *)(fbi->pseudo_palette))[idx] =
+							(pixel << 16) | pixel;
+						len--;
+						idx++;
+					}
+				} else {
+					while (len > 0) {
+						pixel = ((0x07 << toff) |
+							(((red[idx] & 0xE0) >> 5) << roff) |
+							(((green[idx] & 0xE0) >> 5) << goff) |
+							(((blue[idx] & 0xC0) >> 6) << boff));
+						((u32 *)(fbi->pseudo_palette))[idx] =
+							(pixel << 16) | pixel;
+						len--;
+						idx++;
+					}
+				}
+			}
+		} else if (bpp_virt == 16) {
+			if (lfdata->alpha_mode == LOGICVC_LAYER_ALPHA) {
+				while (len > 0) {
+					pixel = ((((red[idx] & 0xF8) >> 3) << roff) |
+						(((green[idx] & 0xFC) >> 2) << goff) |
+						(((blue[idx] & 0xF8) >> 3) << boff));
+					((u32 *)(fbi->pseudo_palette))[idx] =
+						(pixel << 16) | pixel;
+					len--;
+					idx++;
+				}
+			} else if (lfdata->alpha_mode == LOGICVC_PIXEL_ALPHA) {
+				if (transp) {
+					while (len > 0) {
+						((u32 *)(fbi->pseudo_palette))[idx] =
+							((((transp[idx] & 0xFC) >> 2) << toff) |
+							(((red[idx] & 0xF8) >> 3) << roff) |
+							(((green[idx] & 0xFC) >> 2) << goff) |
+							(((blue[idx] & 0xF8) >> 3) << boff));
+						len--;
+						idx++;
+					}
+				} else {
+					while (len > 0) {
+						((u32 *)(fbi->pseudo_palette))[idx] =
+							((0x3F << toff) |
+							(((red[idx] & 0xF8) >> 3) << roff) |
+							(((green[idx] & 0xFC) >> 2) << goff) |
+							(((blue[idx] & 0xF8) >> 3) << boff));
+						len--;
+						idx++;
+					}
+				}
+			}
+		} else if (bpp_virt == 32) {
+			if (lfdata->alpha_mode == LOGICVC_LAYER_ALPHA) {
+				while (len > 0) {
+					((u32 *)(fbi->pseudo_palette))[idx] =
+						(((red[idx] & 0xFF) << roff) |
+						((green[idx] & 0xFF) << goff) |
+						((blue[idx] & 0xFF) << boff));
+					len--;
+					idx++;
+				}
+			} else if (lfdata->alpha_mode == LOGICVC_PIXEL_ALPHA) {
+				if (transp) {
+					while (len > 0) {
+						((u32 *)(fbi->pseudo_palette))[idx] =
+							(((transp[idx] & 0xFF) << toff) |
+							((red[idx] & 0xFF) << roff) |
+							((green[idx] & 0xFF) << goff) |
+							((blue[idx] & 0xFF) << boff));
+						len--;
+						idx++;
+					}
+				} else {
+					while (len > 0) {
+						((u32 *)(fbi->pseudo_palette))[idx] =
+							((0xFF << toff) |
+							((red[idx] & 0xFF) << roff) |
+							((green[idx] & 0xFF) << goff) |
+							((blue[idx] & 0xFF) << boff));
+						len--;
+						idx++;
+					}
+				}
+			}
+		}
+	} else {
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int xylonfb_set_color_reg(unsigned regno, unsigned red, unsigned green,
+	unsigned blue, unsigned transp, struct fb_info *fbi)
+{
+	driver_devel("%s\n", __func__);
+
+	return xylonfb_set_color_hw(
+			(u16 *)&transp,
+			(u16 *)&red,
+			(u16 *)&green,
+			(u16 *)&blue,
+			1, regno, fbi);
+}
+
+static int xylonfb_set_cmap(struct fb_cmap *cmap, struct fb_info *fbi)
+{
+	driver_devel("%s\n", __func__);
+
+	return
+		xylonfb_set_color_hw(cmap->transp, cmap->red, cmap->green, cmap->blue,
+			cmap->len, cmap->start, fbi);
+}
+
+static void xylonfb_set_pixels(struct fb_info *fbi,
+	struct xylonfb_layer_data *layer_data, int bpp, unsigned int pix)
+{
+	u32* vmem;
+	u8 *vmem8;
+	u16 *vmem16;
+	u32 *vmem32;
+	int x, y, pix_off;
+
+	driver_devel("%s\n", __func__);
+
+	vmem = layer_data->fb_virt +
+		(fbi->var.xoffset * (fbi->var.bits_per_pixel/4)) +
+		(fbi->var.yoffset * fbi->var.xres_virtual *
+		(fbi->var.bits_per_pixel/4));
+
+	switch (bpp) {
+	case 8:
+		vmem8 = (u8 *)vmem;
+		for (y = fbi->var.yoffset; y < fbi->var.yres; y++) {
+			pix_off = (y * fbi->var.xres_virtual);
+			for (x = fbi->var.xoffset; x < fbi->var.xres; x++)
+				vmem8[pix_off+x] = pix;
+		}
+		break;
+	case 16:
+		vmem16 = (u16 *)vmem;
+		for (y = fbi->var.yoffset; y < fbi->var.yres; y++) {
+			pix_off = (y * fbi->var.xres_virtual);
+			for (x = fbi->var.xoffset; x < fbi->var.xres; x++)
+				vmem16[pix_off+x] = pix;
+		}
+		break;
+	case 32:
+		vmem32 = (u32 *)vmem;
+		for (y = fbi->var.yoffset; y < fbi->var.yres; y++) {
+			pix_off = (y * fbi->var.xres_virtual);
+			for (x = fbi->var.xoffset; x < fbi->var.xres; x++)
+				vmem32[pix_off+x] = pix;
+		}
+		break;
+	}
+}
+
+static int xylonfb_blank(int blank_mode, struct fb_info *fbi)
+{
+	struct xylonfb_layer_data *layer_data = fbi->par;
+	struct layer_fix_data *lfdata = &layer_data->layer_fix;
+	u32 pix, reg;
+	int i;
+
+	driver_devel("%s\n", __func__);
+
+	switch (blank_mode) {
+	case FB_BLANK_UNBLANK:
+		driver_devel("FB_BLANK_UNBLANK\n");
+		reg = readl(layer_data->reg_base_virt + LOGICVC_SPWRCTRL_ROFF);
+		reg |= LOGICVC_V_EN_MSK;
+		writel(reg, layer_data->reg_base_virt + LOGICVC_SPWRCTRL_ROFF);
+		mdelay(50);
+		break;
+
+	case FB_BLANK_NORMAL:
+		driver_devel("FB_BLANK_NORMAL\n");
+		switch (lfdata->bpp_virt) {
+		case 8:
+			switch (lfdata->alpha_mode) {
+			case LOGICVC_LAYER_ALPHA:
+				xylonfb_set_pixels(fbi, layer_data, 8, 0x00);
+				break;
+			case LOGICVC_PIXEL_ALPHA:
+				xylonfb_set_pixels(fbi, layer_data, 16, 0xFF00);
+				break;
+			case LOGICVC_CLUT_16BPP_ALPHA:
+			case LOGICVC_CLUT_32BPP_ALPHA:
+				for (i = 0; i < 256; i++) {
+					pix = readl(layer_data->layer_clut_base_virt +
+						(i*LOGICVC_CLUT_REGISTER_SIZE));
+					pix &= 0x00FFFFFF;
+					if (pix == 0)
+						break;
+				}
+				xylonfb_set_pixels(fbi, layer_data, 8, i);
+				break;
+			}
+			break;
+		case 16:
+			switch (lfdata->alpha_mode) {
+			case LOGICVC_LAYER_ALPHA:
+				xylonfb_set_pixels(fbi, layer_data, 16, 0x0000);
+				break;
+			case LOGICVC_PIXEL_ALPHA:
+				xylonfb_set_pixels(fbi, layer_data, 32, 0xFF000000);
+				break;
+			}
+			break;
+		case 32:
+			xylonfb_set_pixels(fbi, layer_data, 32, 0xFF000000);
+			break;
+		}
+		break;
+
+	case FB_BLANK_POWERDOWN:
+		driver_devel("FB_BLANK_POWERDOWN\n");
+		reg = readl(layer_data->reg_base_virt + LOGICVC_SPWRCTRL_ROFF);
+		reg &= ~LOGICVC_V_EN_MSK;
+		writel(reg, layer_data->reg_base_virt + LOGICVC_SPWRCTRL_ROFF);
+		mdelay(50);
+		break;
+
+	case FB_BLANK_VSYNC_SUSPEND:
+	case FB_BLANK_HSYNC_SUSPEND:
+	default:
+		driver_devel("FB_BLANK_ not supported!\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int xylonfb_pan_display(struct fb_var_screeninfo *var,
+	struct fb_info *fbi)
+{
+	struct xylonfb_layer_data *layer_data = fbi->par;
+
+	driver_devel("%s\n", __func__);
+
+	if (fbi->var.xoffset == var->xoffset && fbi->var.yoffset == var->yoffset)
+		return 0;
+
+	/* check for negative values */
+	if (var->xoffset < 0)
+		var->xoffset += var->xres;
+	if (var->yoffset < 0)
+		var->yoffset += var->yres;
+
+	if (var->vmode & FB_VMODE_YWRAP) {
+		if (var->yoffset > fbi->var.yres_virtual ||
+			var->xoffset) {
+			return -EINVAL;
+		}
+	} else {
+		if (var->xoffset + var->xres > fbi->var.xres_virtual ||
+			var->yoffset + var->yres > fbi->var.yres_virtual) {
+			/* if smaller then physical layer video memory allow panning */
+			if ((var->xoffset + var->xres > layer_data->layer_fix.width)
+					||
+				(var->yoffset + var->yres > layer_data->layer_fix.height)) {
+				return -EINVAL;
+			}
+		}
+	}
+	fbi->var.xoffset = var->xoffset;
+	fbi->var.yoffset = var->yoffset;
+	if (var->vmode & FB_VMODE_YWRAP)
+		fbi->var.vmode |= FB_VMODE_YWRAP;
+	else
+		fbi->var.vmode &= ~FB_VMODE_YWRAP;
+	/* set layer memory X offset */
+	writel(var->xoffset,
+		(layer_data->layer_reg_base_virt + LOGICVC_LAYER_HOR_OFF_ROFF));
+	/* set layer memory Y offset */
+	writel(var->yoffset,
+		(layer_data->layer_reg_base_virt + LOGICVC_LAYER_VER_OFF_ROFF));
+	/* apply changes in logiCVC */
+	writel((var->yres-1),
+		(layer_data->layer_reg_base_virt + LOGICVC_LAYER_VER_POS_ROFF));
+
+	return 0;
+}
+
+
+static struct fb_ops xylonfb_ops = {
+	.owner = THIS_MODULE,
+	.fb_open = xylonfb_open,
+	.fb_release = xylonfb_release,
+	.fb_check_var = xylonfb_check_var,
+	.fb_set_par = xylonfb_set_par,
+	.fb_setcolreg = xylonfb_set_color_reg,
+	.fb_setcmap = xylonfb_set_cmap,
+	.fb_blank = xylonfb_blank,
+	.fb_pan_display = xylonfb_pan_display,
+	.fb_fillrect = cfb_fillrect,
+	.fb_copyarea = cfb_copyarea,
+	.fb_imageblit = cfb_imageblit,
+	.fb_cursor = NULL,
+	.fb_rotate = NULL,
+	.fb_sync = NULL,
+	.fb_ioctl = xylonfb_ioctl,
+	.fb_mmap = NULL,
+	.fb_get_caps = NULL,
+	.fb_destroy = NULL,
+};
+
+
+static int xylonfb_find_next_layer(struct layer_fix_data *lfdata,
+	int layers, int curr)
+{
+	u32 address, temp_address, loop_address;
+	int i, next;
+
+	driver_devel("%s\n", __func__);
+
+	address = lfdata[curr].offset * lfdata[curr].width * lfdata[curr].bpp;
+	temp_address = 0xFFFFFFFF;
+	next = -1;
+
+	for (i = 0; i < layers; i++) {
+		loop_address = lfdata[i].offset * lfdata[i].width * lfdata[i].bpp;
+		if (address < loop_address
+				&&
+			loop_address < temp_address) {
+			next = i;
+			temp_address = loop_address;
+		}
+	}
+
+	return next;
+}
+
+static void xylonfb_set_yvirt(struct layer_fix_data *lfdata,
+	unsigned long vmem_base_addr, unsigned long vmem_high_addr,
+	int layers, int curr)
+{
+	int next;
+
+	driver_devel("%s\n", __func__);
+
+	next = xylonfb_find_next_layer(lfdata, layers, curr);
+
+	if (next != -1) {
+		lfdata[curr].height =
+			((lfdata[next].width * (lfdata[next].bpp/8) *
+			lfdata[next].offset)
+				-
+			(lfdata[curr].width * (lfdata[curr].bpp/8) *
+			lfdata[curr].offset)) /
+			(lfdata[curr].width * (lfdata[curr].bpp/8));
+	} else { /* last physical logiCVC layer */
+		/* FIXME - this is fixed for 1920x1080 tripple buffering,
+			but it should be read from somewhere */
+		lfdata[curr].height = 3240;
+		while (1) {
+			if (((lfdata[curr].width * (lfdata[curr].bpp/8) *
+				lfdata[curr].height)
+					+
+				(lfdata[curr].width * (lfdata[curr].bpp/8) *
+				lfdata[curr].offset))
+					<=
+				(vmem_high_addr - vmem_base_addr))
+				break;
+			lfdata[curr].height -= 64; /* FIXME - magic number? */
+		}
+	}
+
+	lfdata[curr].layer_fix_info |=
+		((lfdata[curr].height / lfdata[curr].buffer_offset) << 4);
+}
+
+static int xylonfb_map(int id, int layers, struct device *dev,
+	struct xylonfb_layer_data *layer_data,
+	unsigned long vmem_base_addr, u32 reg_base_phys, void *reg_base_virt)
+{
+	struct layer_fix_data *lfdata = &layer_data->layer_fix;
+
+	driver_devel("%s\n", __func__);
+
+	/* logiCVC register mapping */
+	layer_data->reg_base_phys = reg_base_phys;
+	layer_data->reg_base_virt = reg_base_virt;
+	/* Video memory mapping */
+	layer_data->fb_phys = vmem_base_addr +
+		(lfdata->width * (lfdata->bpp/8) * lfdata->offset);
+	layer_data->fb_size =
+		lfdata->width * (lfdata->bpp/8) * lfdata->height;
+
+	if (layer_data->xylonfb_cd->xylonfb_flags & FB_DMA_BUFFER) {
+		/* NOT USED FOR NOW! */
+		layer_data->fb_virt = dma_alloc_writecombine(dev,
+			PAGE_ALIGN(layer_data->fb_size),
+			&layer_data->fb_phys, GFP_KERNEL);
+	} else {
+		layer_data->fb_virt =
+			ioremap_wc(layer_data->fb_phys, layer_data->fb_size);
+	}
+	/* check memory mappings */
+	if (!layer_data->reg_base_virt || !layer_data->fb_virt) {
+		pr_err("Error xylonfb ioremap REGS 0x%X FB 0x%X\n",
+			(unsigned int)layer_data->reg_base_virt,
+			(unsigned int)layer_data->fb_virt);
+		return -ENOMEM;
+	}
+	//memset_io((void __iomem *)layer_data->fb_virt, 0, layer_data->fb_size);
+	layer_data->layer_reg_base_virt =
+		layer_data->reg_base_virt + logicvc_layer_reg_offset[id];
+	layer_data->layer_clut_base_virt =
+		layer_data->reg_base_virt +
+		logicvc_clut_reg_offset[id*LOGICVC_CLUT_0_INDEX_OFFSET];
+	layer_data->layer_use_ref = 0;
+	layer_data->layer_flags = 0;
+
+	return 0;
+}
+
+static void xylonfb_set_fbi_timings(struct fb_info *fbi)
+{
+	struct xylonfb_layer_data *layer_data = fbi->par;
+	struct xylonfb_common_data *common_data = layer_data->xylonfb_cd;
+	struct fb_var_screeninfo *var = &fbi->var;
+
+	driver_devel("%s\n", __func__);
+
+	var->xres = common_data->vmode_data_current.fb_vmode.xres;
+	var->yres = common_data->vmode_data_current.fb_vmode.yres;
+	var->pixclock = common_data->vmode_data_current.fb_vmode.pixclock;
+	var->left_margin = common_data->vmode_data_current.fb_vmode.left_margin;
+	var->right_margin = common_data->vmode_data_current.fb_vmode.right_margin;
+	var->upper_margin = common_data->vmode_data_current.fb_vmode.upper_margin;
+	var->lower_margin = common_data->vmode_data_current.fb_vmode.lower_margin;
+	var->hsync_len = common_data->vmode_data_current.fb_vmode.hsync_len;
+	var->vsync_len = common_data->vmode_data_current.fb_vmode.vsync_len;
+	var->sync = common_data->vmode_data_current.fb_vmode.sync;
+	var->vmode = common_data->vmode_data_current.fb_vmode.vmode;
+}
+
+static void xylonfb_set_hw_specifics(struct fb_info *fbi,
+	struct xylonfb_layer_data *layer_data, struct layer_fix_data *lfdata,
+	u32 reg_base_phys)
+{
+	driver_devel("%s\n", __func__);
+
+	fbi->fix.smem_start = layer_data->fb_phys;
+	fbi->fix.smem_len = layer_data->fb_size;
+	fbi->fix.type = FB_TYPE_PACKED_PIXELS;
+	if ((lfdata->bpp == 8) &&
+		((lfdata->alpha_mode == LOGICVC_CLUT_16BPP_ALPHA) ||
+		(lfdata->alpha_mode == LOGICVC_CLUT_32BPP_ALPHA))) {
+		fbi->fix.visual = FB_VISUAL_PSEUDOCOLOR;
+	} else {
+		/*
+			Other logiCVC layer pixel formats:
+			- 8 bpp: LAYER or PIXEL alpha
+			  It is not true color, RGB triplet is stored in 8 bits.
+			- 16 bpp:
+			  LAYER alpha: RGB triplet is stored in 16 bits
+			  PIXEL alpha: ARGB quadriplet is stored in 32 bits
+			- 32 bpp: LAYER or PIXEL alpha
+			  True color, RGB triplet or ARGB quadriplet is stored in 32 bits.
+		*/
+		fbi->fix.visual = FB_VISUAL_TRUECOLOR;
+	}
+	/* sanity check */
+	if ((lfdata->bpp != 8) &&
+		((lfdata->alpha_mode == LOGICVC_CLUT_16BPP_ALPHA) ||
+		(lfdata->alpha_mode == LOGICVC_CLUT_32BPP_ALPHA))) {
+		pr_warning("xylonfb invalid layer alpha!\n");
+		lfdata->alpha_mode = LOGICVC_LAYER_ALPHA;
+	}
+
+	fbi->fix.xpanstep = 1;
+	fbi->fix.ypanstep = 1;
+	fbi->fix.ywrapstep = LOGICVC_MAX_VRES;
+	fbi->fix.line_length = lfdata->width * (lfdata->bpp/8);
+	fbi->fix.mmio_start = reg_base_phys;
+	fbi->fix.mmio_len = LOGICVC_REGISTERS_RANGE;
+	fbi->fix.accel = FB_ACCEL_NONE;
+
+	fbi->var.xres_virtual = lfdata->width;
+	if (lfdata->height <= LOGICVC_MAX_VRES)
+		fbi->var.yres_virtual = lfdata->height;
+	else
+		fbi->var.yres_virtual = LOGICVC_MAX_VRES;
+	fbi->var.bits_per_pixel = lfdata->bpp;
+
+	/*	Set values according to logiCVC layer data width configuration:
+		- layer data width can be 1, 2, 4 bytes
+		- layer data width for 16 bpp can be 2 or 4 bytes */
+	if (lfdata->alpha_mode == LOGICVC_LAYER_ALPHA) {
+		fbi->var.transp.offset = 0;
+		fbi->var.transp.length = 0;
+	}
+	switch (lfdata->bpp_virt) {
+	case 8:
+		switch (lfdata->alpha_mode) {
+		case LOGICVC_PIXEL_ALPHA:
+			fbi->var.transp.offset = 8;
+			fbi->var.transp.length = 3;
+
+		case LOGICVC_LAYER_ALPHA:
+			fbi->var.red.offset = 5;
+			fbi->var.red.length = 3;
+			fbi->var.green.offset = 2;
+			fbi->var.green.length = 3;
+			fbi->var.blue.offset = 0;
+			fbi->var.blue.length = 2;
+			break;
+
+		case LOGICVC_CLUT_16BPP_ALPHA:
+			fbi->var.transp.offset = 24;
+			fbi->var.transp.length = 6;
+			fbi->var.red.offset = 19;
+			fbi->var.red.length = 5;
+			fbi->var.green.offset = 10;
+			fbi->var.green.length = 6;
+			fbi->var.blue.offset = 3;
+			fbi->var.blue.length = 5;
+			break;
+
+		case LOGICVC_CLUT_32BPP_ALPHA:
+			fbi->var.transp.offset = 24;
+			fbi->var.transp.length = 8;
+			fbi->var.red.offset = 16;
+			fbi->var.red.length = 8;
+			fbi->var.green.offset = 8;
+			fbi->var.green.length = 8;
+			fbi->var.blue.offset = 0;
+			fbi->var.blue.length = 8;
+			break;
+		}
+		break;
+	case 16:
+		switch (lfdata->alpha_mode) {
+		case LOGICVC_PIXEL_ALPHA:
+			fbi->var.transp.offset = 24;
+			fbi->var.transp.length = 6;
+
+		case LOGICVC_LAYER_ALPHA:
+			fbi->var.red.offset = 11;
+			fbi->var.red.length = 5;
+			fbi->var.green.offset = 5;
+			fbi->var.green.length = 6;
+			fbi->var.blue.offset = 0;
+			fbi->var.blue.length = 5;
+			break;
+		}
+		break;
+	case 32:
+		switch (lfdata->alpha_mode) {
+		case LOGICVC_PIXEL_ALPHA:
+			fbi->var.transp.offset = 24;
+			fbi->var.transp.length = 8;
+
+		case LOGICVC_LAYER_ALPHA:
+			fbi->var.red.offset = 16;
+			fbi->var.red.length = 8;
+			fbi->var.green.offset = 8;
+			fbi->var.green.length = 8;
+			fbi->var.blue.offset = 0;
+			fbi->var.blue.length = 8;
+			break;
+		}
+		break;
+	}
+	fbi->var.transp.msb_right = 0;
+	fbi->var.red.msb_right = 0;
+	fbi->var.green.msb_right = 0;
+	fbi->var.blue.msb_right = 0;
+	fbi->var.activate = FB_ACTIVATE_NOW;
+	fbi->var.height = 0;
+	fbi->var.width = 0;
+	fbi->var.sync = 0;
+	fbi->var.rotate = 0;
+}
+
+static int xylonfb_set_timings(struct fb_info *fbi, int bpp)
+{
+	struct xylonfb_layer_data *layer_data = fbi->par;
+	struct xylonfb_common_data *common_data = layer_data->xylonfb_cd;
+	struct fb_var_screeninfo fb_var;
+	int rc;
+
+	driver_devel("%s\n", __func__);
+
+	if ((common_data->xylonfb_flags & FB_VMODE_INIT) &&
+		memchr(common_data->vmode_data.fb_vmode_name, 'x', 10)) {
+		common_data->vmode_data_current = common_data->vmode_data;
+		return 0;
+	}
+
+	rc = fb_find_mode(&fb_var, fbi, xylonfb_mode_option, NULL, 0,
+		&xylonfb_vmode.fb_vmode, bpp);
+#ifdef DEBUG
+	switch (rc) {
+	case 0:
+		pr_err("Error xylonfb video mode\n"
+			"using driver default mode %dx%d-%d@%d\n",
+			xylonfb_vmode.fb_vmode.xres, xylonfb_vmode.fb_vmode.yres,
+			bpp, xylonfb_vmode.fb_vmode.refresh);
+		break;
+	case 1:
+		driver_devel("xylonfb video mode %s\n", xylonfb_mode_option);
+		break;
+	case 2:
+		pr_notice("xylonfb video mode %s with ignored refresh rate\n",
+			xylonfb_mode_option);
+		break;
+	case 3:
+		pr_notice("xylonfb default video mode %dx%d-%d@%d\n",
+			xylonfb_vmode.fb_vmode.xres,
+			xylonfb_vmode.fb_vmode.yres,
+			bpp, xylonfb_vmode.fb_vmode.refresh);
+		break;
+	case 4:
+		pr_notice("xylonfb video mode fallback\n");
+		break;
+	}
+#endif
+
+	common_data->vmode_data_current.ctrl_reg =
+		common_data->vmode_data.ctrl_reg;
+	common_data->vmode_data_current.fb_vmode.refresh =
+		common_data->vmode_data.fb_vmode.refresh;
+	sprintf(common_data->vmode_data_current.fb_vmode_name,
+		"%dx%dM-%d@%d",
+		fb_var.xres, fb_var.yres, fb_var.bits_per_pixel,
+		common_data->vmode_data_current.fb_vmode.refresh);
+	common_data->vmode_data_current.fb_vmode.xres = fb_var.xres;
+	common_data->vmode_data_current.fb_vmode.yres = fb_var.yres;
+	common_data->vmode_data_current.fb_vmode.pixclock = fb_var.pixclock;
+	common_data->vmode_data_current.fb_vmode.left_margin = fb_var.left_margin;
+	common_data->vmode_data_current.fb_vmode.right_margin = fb_var.right_margin;
+	common_data->vmode_data_current.fb_vmode.upper_margin = fb_var.upper_margin;
+	common_data->vmode_data_current.fb_vmode.lower_margin = fb_var.lower_margin;
+	common_data->vmode_data_current.fb_vmode.hsync_len = fb_var.hsync_len;
+	common_data->vmode_data_current.fb_vmode.vsync_len = fb_var.vsync_len;
+	common_data->vmode_data_current.fb_vmode.sync = fb_var.sync;
+	common_data->vmode_data_current.fb_vmode.vmode = fb_var.vmode;
+
+	if (!memchr(common_data->vmode_data.fb_vmode_name, 'x', 10))
+		common_data->vmode_data = common_data->vmode_data_current;
+
+	return rc;
+}
+
+static int xylonfb_register_fb(struct fb_info *fbi,
+	struct xylonfb_layer_data *layer_data,
+	u32 reg_base_phys, int id, int *regfb)
+{
+	struct xylonfb_common_data *common_data = layer_data->xylonfb_cd;
+	struct layer_fix_data *lfdata = &layer_data->layer_fix;
+	int alpha;
+
+	driver_devel("%s\n", __func__);
+
+	fbi->flags = FBINFO_DEFAULT;
+	fbi->screen_base = (char __iomem *)layer_data->fb_virt;
+	fbi->screen_size = layer_data->fb_size;
+	fbi->pseudo_palette = kzalloc(sizeof(u32) * XYLONFB_PSEUDO_PALETTE_SZ,
+		GFP_KERNEL);
+	fbi->fbops = &xylonfb_ops;
+
+	sprintf(fbi->fix.id, "Xylon FB%d", id);
+	xylonfb_set_hw_specifics(fbi, layer_data, lfdata, reg_base_phys);
+	if (!(common_data->xylonfb_flags & FB_DEFAULT_VMODE_SET)) {
+		xylonfb_set_timings(fbi, fbi->var.bits_per_pixel);
+		common_data->xylonfb_flags |= FB_DEFAULT_VMODE_SET;
+	}
+	xylonfb_set_fbi_timings(fbi);
+
+	if (lfdata->alpha_mode == LOGICVC_LAYER_ALPHA)
+		alpha = 0;
+	else
+		alpha = 1;
+	if (fb_alloc_cmap(&fbi->cmap, 256, alpha))
+		return -ENOMEM;
+
+	*regfb = register_framebuffer(fbi);
+	if (*regfb) {
+		pr_err("Error xylonfb registering xylonfb %d\n", id);
+		return -EINVAL;
+	}
+	pr_info("xylonfb %d registered\n", id);
+	/* after fb driver registration, values in struct fb_info
+		must not be changed anywhere else except in xylonfb_set_par */
+
+	return 0;
+}
+
+static void xylonfb_init_layer_regs(struct xylonfb_layer_data *layer_data)
+{
+	u32 reg_val;
+
+	switch (layer_data->layer_fix.bpp_virt) {
+	case 8:
+		switch (layer_data->layer_fix.alpha_mode) {
+		case LOGICVC_CLUT_16BPP_ALPHA:
+			reg_val = TRANSPARENT_COLOR_8BPP_CLUT_16;
+			break;
+		case LOGICVC_CLUT_32BPP_ALPHA:
+			reg_val = TRANSPARENT_COLOR_8BPP_CLUT_24;
+			break;
+		default:
+			reg_val = TRANSPARENT_COLOR_8BPP;
+			break;
+		}
+		break;
+	case 16:
+		reg_val = TRANSPARENT_COLOR_16BPP;
+		break;
+	case 32:
+		reg_val = TRANSPARENT_COLOR_24BPP;
+		break;
+	default:
+		reg_val = TRANSPARENT_COLOR_24BPP;
+		break;
+	}
+	writel(reg_val,
+		(layer_data->layer_reg_base_virt + LOGICVC_LAYER_TRANSP_ROFF));
+
+	reg_val = layer_data->layer_ctrl;
+	writel(reg_val,
+		(layer_data->layer_reg_base_virt + LOGICVC_LAYER_CTRL_ROFF));
+}
+
+static void xylonfb_logicvc_disp_ctrl(struct fb_info *fbi, bool enable)
+{
+	struct xylonfb_layer_data *layer_data = fbi->par;
+	struct xylonfb_common_data *common_data = layer_data->xylonfb_cd;
+	u32 val;
+
+	driver_devel("%s\n", __func__);
+
+	if (enable) {
+		val = LOGICVC_EN_VDD_MSK;
+		writel(val, layer_data->reg_base_virt + LOGICVC_SPWRCTRL_ROFF);
+		mdelay(common_data->power_on_delay);
+		val |= LOGICVC_V_EN_MSK;
+		writel(val, layer_data->reg_base_virt + LOGICVC_SPWRCTRL_ROFF);
+		mdelay(common_data->signal_on_delay);
+		val |= LOGICVC_EN_BLIGHT_MSK;
+		writel(val, layer_data->reg_base_virt + LOGICVC_SPWRCTRL_ROFF);
+	} else {
+		writel(0, layer_data->reg_base_virt + LOGICVC_SPWRCTRL_ROFF);
+	}
+}
+
+static void xylonfb_enable_logicvc_layer(struct fb_info *fbi)
+{
+	struct xylonfb_layer_data *layer_data = fbi->par;
+	u32 reg;
+
+	driver_devel("%s\n", __func__);
+
+	reg = readl(layer_data->layer_reg_base_virt + LOGICVC_LAYER_CTRL_ROFF);
+	reg |= 0x01;
+	writel(reg, (layer_data->layer_reg_base_virt + LOGICVC_LAYER_CTRL_ROFF));
+}
+
+static void xylonfb_disable_logicvc_layer(struct fb_info *fbi)
+{
+	struct xylonfb_layer_data *layer_data = fbi->par;
+	u32 reg;
+
+	driver_devel("%s\n", __func__);
+
+	reg = readl(layer_data->layer_reg_base_virt + LOGICVC_LAYER_CTRL_ROFF);
+	reg &= ~0x01;
+	writel(reg, (layer_data->layer_reg_base_virt + LOGICVC_LAYER_CTRL_ROFF));
+}
+
+static void xylonfb_start_logicvc(struct fb_info *fbi)
+{
+	struct xylonfb_layer_data *layer_data = fbi->par;
+	struct xylonfb_common_data *common_data = layer_data->xylonfb_cd;
+
+	driver_devel("%s\n", __func__);
+
+	writel(common_data->vmode_data_current.fb_vmode.right_margin-1,
+		layer_data->reg_base_virt + LOGICVC_SHSY_FP_ROFF);
+	writel(common_data->vmode_data_current.fb_vmode.hsync_len-1,
+		layer_data->reg_base_virt + LOGICVC_SHSY_ROFF);
+	writel(common_data->vmode_data_current.fb_vmode.left_margin-1,
+		layer_data->reg_base_virt + LOGICVC_SHSY_BP_ROFF);
+	writel(common_data->vmode_data_current.fb_vmode.xres-1,
+		layer_data->reg_base_virt + LOGICVC_SHSY_RES_ROFF);
+	writel(common_data->vmode_data_current.fb_vmode.lower_margin-1,
+		layer_data->reg_base_virt + LOGICVC_SVSY_FP_ROFF);
+	writel(common_data->vmode_data_current.fb_vmode.vsync_len-1,
+		layer_data->reg_base_virt + LOGICVC_SVSY_ROFF);
+	writel(common_data->vmode_data_current.fb_vmode.upper_margin-1,
+		layer_data->reg_base_virt + LOGICVC_SVSY_BP_ROFF);
+	writel(common_data->vmode_data_current.fb_vmode.yres-1,
+		layer_data->reg_base_virt + LOGICVC_SVSY_RES_ROFF);
+	writel(common_data->vmode_data_current.ctrl_reg,
+		layer_data->reg_base_virt + LOGICVC_SCTRL_ROFF);
+	writel(SD_REG_INIT, layer_data->reg_base_virt + LOGICVC_SDTYPE_ROFF);
+
+	driver_devel("\n" \
+		"logiCVC HW parameters:\n" \
+		"    Horizontal Front Porch: %d pixclks\n" \
+		"    Horizontal Sync:        %d pixclks\n" \
+		"    Horizontal Back Porch:  %d pixclks\n" \
+		"    Vertical Front Porch:   %d pixclks\n" \
+		"    Vertical Sync:          %d pixclks\n" \
+		"    Vertical Back Porch:    %d pixclks\n" \
+		"    Pixel Clock:            %d ps\n" \
+		"    Horizontal Res:         %d\n" \
+		"    Vertical Res:           %d\n" \
+		"\n", \
+		common_data->vmode_data_current.fb_vmode.right_margin,
+		common_data->vmode_data_current.fb_vmode.hsync_len,
+		common_data->vmode_data_current.fb_vmode.left_margin,
+		common_data->vmode_data_current.fb_vmode.lower_margin,
+		common_data->vmode_data_current.fb_vmode.vsync_len,
+		common_data->vmode_data_current.fb_vmode.upper_margin,
+		common_data->vmode_data_current.fb_vmode.pixclock,
+		common_data->vmode_data_current.fb_vmode.xres,
+		common_data->vmode_data_current.fb_vmode.yres);
+}
+
+static void xylonfb_stop_logicvc(struct fb_info *fbi)
+{
+	struct xylonfb_layer_data *layer_data = fbi->par;
+	struct xylonfb_common_data *common_data = layer_data->xylonfb_cd;
+	struct fb_info **afbi =
+		(struct fb_info **)dev_get_drvdata(common_data->dev);
+	int i;
+
+	driver_devel("%s\n", __func__);
+
+	if (afbi) {
+		for (i = 0; i < common_data->layers; i++)
+			xylonfb_disable_logicvc_layer(afbi[i]);
+	}
+}
+
+static void xylonfb_start(struct fb_info **afbi, int layers)
+{
+	struct xylonfb_layer_data *layer_data;
+	int i;
+
+	driver_devel("%s\n", __func__);
+
+	/* turn OFF all layers except already used ones */
+	for (i = 0; i < layers; i++) {
+		layer_data = (struct xylonfb_layer_data *)afbi[i]->par;
+		if (layer_data->layer_flags & LOGICVC_LAYER_ON)
+			continue;
+		/* turn off layer */
+		xylonfb_disable_logicvc_layer(afbi[i]);
+	}
+	/* print layer parameters */
+	for (i = 0; i < layers; i++) {
+		layer_data = (struct xylonfb_layer_data *)afbi[i]->par;
+		driver_devel("logiCVC layer %d\n" \
+			"    Registers Base Address:     0x%X\n" \
+			"    Layer Video Memory Address: 0x%X\n" \
+			"    X resolution:               %d\n" \
+			"    Y resolution:               %d\n" \
+			"    X resolution (virtual):     %d\n" \
+			"    Y resolution (virtual):     %d\n" \
+			"    Line length (bytes):        %d\n" \
+			"    Bits per Pixel:             %d\n" \
+			"\n", \
+			i,
+			(unsigned int)layer_data->reg_base_phys,
+			(unsigned int)layer_data->fb_phys,
+			afbi[i]->var.xres,
+			afbi[i]->var.yres,
+			afbi[i]->var.xres_virtual,
+			afbi[i]->var.yres_virtual,
+			afbi[i]->fix.line_length,
+			afbi[i]->var.bits_per_pixel);
+	}
+}
+
+int xylonfb_init_driver(struct xylonfb_init_data *init_data)
+{
+	struct device *dev;
+	struct fb_info **afbi;
+	struct fb_info *fbi;
+	struct xylonfb_common_data *common_data;
+	struct xylonfb_layer_data *layer_data;
+	struct resource *reg_res, *irq_res;
+	void *reg_base_virt;
+	u32 reg_base_phys;
+	int reg_range, layers, active_layer;
+	int i, rc;
+	int regfb[LOGICVC_MAX_LAYERS];
+	driver_devel("%s\n", __func__);
+
+	dev = &init_data->pdev->dev;
+
+	reg_res = platform_get_resource(init_data->pdev, IORESOURCE_MEM, 0);
+	irq_res = platform_get_resource(init_data->pdev, IORESOURCE_IRQ, 0);
+	if ((!reg_res) || (!irq_res)) {
+		pr_err("Error xylonfb resources\n");
+		return -ENODEV;
+	}
+
+	layers = init_data->layers;
+	active_layer = init_data->active_layer;
+	if (active_layer >= layers) {
+		pr_err("Error xylonfb default layer (set 0)\n");
+		active_layer = 0;
+	}
+
+	afbi = kzalloc(sizeof(struct fb_info *) * layers, GFP_KERNEL);
+	common_data = kzalloc(sizeof(struct xylonfb_common_data), GFP_KERNEL);
+	if (!afbi || !common_data) {
+		pr_err("Error xylonfb allocating internal data\n");
+		rc = -ENOMEM;
+		goto err_mem;
+	}
+
+	common_data->layers = layers;
+	common_data->xylonfb_flags |= FB_VMODE_INIT;
+
+	sprintf(init_data->vmode_data.fb_vmode_name, "%sM-%d@%d",
+		init_data->vmode_data.fb_vmode_name,
+		init_data->lfdata[active_layer].bpp,
+		init_data->vmode_data.fb_vmode.refresh);
+	if (init_data->vmode_params_set) {
+		common_data->vmode_data = init_data->vmode_data;
+	} else {
+		xylonfb_mode_option = init_data->vmode_data.fb_vmode_name;
+		common_data->vmode_data.ctrl_reg = init_data->vmode_data.ctrl_reg;
+		common_data->vmode_data.fb_vmode.refresh =
+			init_data->vmode_data.fb_vmode.refresh;
+	}
+
+	layer_data = NULL;
+
+	reg_base_phys = reg_res->start;
+	reg_range = reg_res->end - reg_res->start;
+	reg_base_virt = ioremap_nocache(reg_base_phys, reg_range);
+
+	/* load layer parameters for all layers */
+	for (i = 0; i < layers; i++)
+		regfb[i] = -1;
+
+	/* make /dev/fb0 to be default active layer
+	   no matter how hw layers are organized */
+	for (i = active_layer; i < layers; i++) {
+		if (regfb[i] != -1)
+			continue;
+
+		fbi = framebuffer_alloc(sizeof(struct xylonfb_layer_data), dev);
+		if (!fbi) {
+			pr_err("Error xylonfb allocate info\n");
+			rc = -ENOMEM;
+			goto err_fb;
+		}
+		afbi[i] = fbi;
+		layer_data = fbi->par;
+		layer_data->xylonfb_cd = common_data;
+
+		xylonfb_set_yvirt(init_data->lfdata,
+			init_data->vmem_base_addr, init_data->vmem_high_addr, layers, i);
+
+		layer_data->layer_fix = init_data->lfdata[i];
+
+		rc = xylonfb_map(i, layers, dev, layer_data,
+			init_data->vmem_base_addr, reg_base_phys, reg_base_virt);
+		if (rc)
+			goto err_fb;
+
+		layer_data->layer_ctrl = init_data->layer_ctrl[i];
+		xylonfb_init_layer_regs(layer_data);
+
+		rc = xylonfb_register_fb(fbi, layer_data, reg_base_phys, i, &regfb[i]);
+		if (rc)
+			goto err_fb;
+
+		mutex_init(&layer_data->layer_mutex);
+
+		/* register following layers in HW configuration order */
+		if (active_layer > 0) {
+			i = -1; /* after for loop increment i will be zero */
+			active_layer = -1;
+		}
+
+		driver_devel( \
+			"    Layer ID %d\n" \
+			"    Layer offset %u\n" \
+			"    Layer buffer offset %hd\n" \
+			"    Layer buffers %d\n" \
+			"    Layer width %d pixels\n" \
+			"    Layer height %d lines\n" \
+			"    Layer bits per pixel %d\n" \
+			"    Layer bits per pixel (virtual) %d\n" \
+			"    Layer FB size %ld bytes\n", \
+			(layer_data->layer_fix.layer_fix_info & 0x0F),
+			layer_data->layer_fix.offset,
+			layer_data->layer_fix.buffer_offset,
+			(layer_data->layer_fix.layer_fix_info >> 4),
+			layer_data->layer_fix.width,
+			layer_data->layer_fix.height,
+			layer_data->layer_fix.bpp,
+			layer_data->layer_fix.bpp_virt,
+			layer_data->fb_size);
+	}
+
+	common_data->bg_layer_bpp = init_data->bg_layer_bpp;
+	common_data->bg_layer_alpha_mode = init_data->bg_layer_alpha_mode;
+	driver_devel("BG layer %dbpp\n", init_data->bg_layer_bpp);
+
+	common_data->xylonfb_irq = irq_res->start;
+	if (request_irq(common_data->xylonfb_irq, xylonfb_isr,
+			IRQF_TRIGGER_HIGH, DEVICE_NAME, afbi)) {
+		common_data->xylonfb_irq = 0;
+		goto err_fb;
+	}
+
+#if defined(__LITTLE_ENDIAN)
+	common_data->xylonfb_flags |= FB_MEMORY_LE;
+#endif
+	mutex_init(&common_data->irq_mutex);
+	init_waitqueue_head(&common_data->xylonfb_vsync.wait);
+	common_data->xylonfb_use_ref = 0;
+
+	common_data->xylonfb_flags &=
+		~(FB_VMODE_INIT | FB_DEFAULT_VMODE_SET | FB_VMODE_SET);
+	xylonfb_mode_option = NULL;
+
+	common_data->dev = dev;
+	dev_set_drvdata(dev, (void *)afbi);
+
+	/* start HW */
+	xylonfb_start(afbi, layers);
+
+	return 0;
+
+err_fb:
+	if (common_data->xylonfb_irq != 0)
+		free_irq(common_data->xylonfb_irq, afbi);
+	if (layer_data->reg_base_virt)
+		iounmap(layer_data->reg_base_virt);
+	for (i = layers-1; i >= 0; i--) {
+		fbi = afbi[i];
+		if (!fbi)
+			continue;
+		layer_data = fbi->par;
+		if (regfb[i] == 0)
+			unregister_framebuffer(fbi);
+		else
+			regfb[i] = 0;
+		if (fbi->cmap.red)
+			fb_dealloc_cmap(&fbi->cmap);
+		if (layer_data) {
+			if (common_data->xylonfb_flags & FB_DMA_BUFFER) {
+				/* NOT USED FOR NOW! */
+				dma_free_coherent(dev, PAGE_ALIGN(fbi->fix.smem_len),
+					layer_data->fb_virt, layer_data->fb_phys);
+			} else {
+				if (layer_data->fb_virt)
+					iounmap(layer_data->fb_virt);
+			}
+			kfree(fbi->pseudo_palette);
+			framebuffer_release(fbi);
+		}
+	}
+
+err_mem:
+	if (common_data)
+		kfree(common_data);
+	if (afbi)
+		kfree(afbi);
+
+	dev_set_drvdata(dev, NULL);
+
+	return rc;
+}
+
+int xylonfb_deinit_driver(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct fb_info **afbi = (struct fb_info **)dev_get_drvdata(dev);
+	struct fb_info *fbi = afbi[0];
+	struct xylonfb_layer_data *layer_data = fbi->par;
+	struct xylonfb_common_data *common_data = layer_data->xylonfb_cd;
+	int i;
+	bool logicvc_unmap;
+
+	driver_devel("%s\n", __func__);
+
+	if (common_data->xylonfb_use_ref) {
+		pr_err("Error xylonfb in use\n");
+		return -EINVAL;
+	}
+
+	logicvc_unmap = false;
+
+	free_irq(common_data->xylonfb_irq, afbi);
+	for (i = common_data->layers-1; i >= 0; i--) {
+		fbi = afbi[i];
+		layer_data = fbi->par;
+		xylonfb_disable_logicvc_layer(fbi);
+		if (!logicvc_unmap) {
+			iounmap(layer_data->reg_base_virt);
+			logicvc_unmap = true;
+		}
+		unregister_framebuffer(fbi);
+		fb_dealloc_cmap(&fbi->cmap);
+		if (common_data->xylonfb_flags & FB_DMA_BUFFER) {
+			dma_free_coherent(dev, PAGE_ALIGN(fbi->fix.smem_len),
+				layer_data->fb_virt, layer_data->fb_phys);
+		} else {
+			iounmap(layer_data->fb_virt);
+		}
+		kfree(fbi->pseudo_palette);
+		framebuffer_release(fbi);
+	}
+
+	kfree(common_data);
+	kfree(afbi);
+
+	dev_set_drvdata(dev, NULL);
+
+	return 0;
+}
+
+#ifndef MODULE
+int xylonfb_get_params(char *options)
+{
+	char *this_opt;
+
+	driver_devel("%s\n", __func__);
+
+	if (!options || !*options)
+		return 0;
+
+	while ((this_opt = strsep(&options, ",")) != NULL) {
+		if (!*this_opt)
+			continue;
+		xylonfb_mode_option = this_opt;
+	}
+	return 0;
+}
+#endif
diff -uNr linux-xlnx//drivers/video/xylon/xylonfb/core/xylonfb.h linux-xlnx_xfb_14.1_build3//drivers/video/xylon/xylonfb/core/xylonfb.h
--- linux-xlnx//drivers/video/xylon/xylonfb/core/xylonfb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-xlnx_xfb_14.1_build3//drivers/video/xylon/xylonfb/core/xylonfb.h	2012-07-26 14:08:36.000000000 +0200
@@ -0,0 +1,130 @@
+/*
+ * Xylon logiCVC frame buffer driver internal data structures
+ *
+ * Author: Xylon d.o.o.
+ * e-mail: davor.joja@logicbricks.com
+ *
+ * 2012 (c) Xylon d.o.o.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#ifndef __XYLON_FB_DATA_H__
+#define __XYLON_FB_DATA_H__
+
+
+#include <linux/wait.h>
+#include <linux/mutex.h>
+#include <linux/fb.h>
+#include "logicvc.h"
+
+
+#define DRIVER_NAME "xylonfb"
+#define DEVICE_NAME "logicvc"
+#define DRIVER_DESCRIPTION "Xylon logiCVC frame buffer driver"
+#define DRIVER_VERSION "1.1"
+
+/* FB driver flags */
+#define FB_DMA_BUFFER        0x01
+#define FB_MEMORY_LE         0x02
+#define FB_VMODE_INIT        0x10
+#define FB_DEFAULT_VMODE_SET 0x20
+#define FB_VMODE_SET         0x40
+
+
+#ifdef DEBUG
+#define driver_devel(format, ...) \
+	do { \
+		printk(KERN_INFO format, ## __VA_ARGS__); \
+	} while (0)
+#else
+#define driver_devel(format, ...)
+#endif
+
+
+#define VMODE_NAME_SZ 20
+struct xylonfb_vmode_data {
+	u32 ctrl_reg;
+	struct fb_videomode fb_vmode;
+	char fb_vmode_name[VMODE_NAME_SZ+1];
+};
+
+struct layer_fix_data {
+	unsigned int offset;
+	unsigned short buffer_offset;
+	unsigned short width;
+	unsigned short height;
+	unsigned char bpp;
+	unsigned char bpp_virt;
+	unsigned char alpha_mode;
+	unsigned char layer_fix_info;	/* higher 4 bits: number of layer buffers */
+									/* lower 4 bits: layer ID */
+};
+
+struct xylonfb_sync {
+	wait_queue_head_t wait;
+	unsigned int cnt;
+};
+
+struct xylonfb_common_data {
+	struct device *dev;
+	struct mutex irq_mutex;
+	struct xylonfb_sync xylonfb_vsync;
+	struct xylonfb_vmode_data vmode_data;
+	struct xylonfb_vmode_data vmode_data_current;
+	/* Delay after applying display power and
+		before applying display signals */
+	unsigned int power_on_delay;
+	/* Delay after applying display signal and
+		before applying display backlight power supply */
+	unsigned int signal_on_delay;
+	unsigned char layers;
+	unsigned char xylonfb_irq;
+	unsigned char xylonfb_use_ref;
+	unsigned char xylonfb_flags;
+	unsigned char xylonfb_used_layer;
+	unsigned char bg_layer_bpp;
+	unsigned char bg_layer_alpha_mode;
+};
+
+struct xylonfb_layer_data {
+	struct xylonfb_common_data *xylonfb_cd;
+	struct mutex layer_mutex;
+	dma_addr_t reg_base_phys;
+	dma_addr_t fb_phys;
+	void *reg_base_virt;
+	void *fb_virt;
+	unsigned long fb_size;
+	void *layer_reg_base_virt;
+	void *layer_clut_base_virt;
+	struct layer_fix_data layer_fix;
+	unsigned char layer_ctrl;
+	unsigned char layer_flags;
+	unsigned char layer_use_ref;
+};
+
+struct xylonfb_init_data {
+	struct platform_device *pdev;
+	struct xylonfb_vmode_data vmode_data;
+	struct layer_fix_data lfdata[LOGICVC_MAX_LAYERS];
+	unsigned long vmem_base_addr;
+	unsigned long vmem_high_addr;
+	unsigned char layer_ctrl[LOGICVC_MAX_LAYERS];
+	unsigned char layers;
+	unsigned char active_layer;
+	unsigned char bg_layer_bpp;
+	unsigned char bg_layer_alpha_mode;
+	bool vmode_params_set;
+};
+
+
+/* xylonfb core interface functions */
+extern int xylonfb_get_params(char *options);
+extern int xylonfb_init_driver(struct xylonfb_init_data *init_data);
+extern int xylonfb_deinit_driver(struct platform_device *pdev);
+extern int xylonfb_ioctl(struct fb_info *fbi,
+	unsigned int cmd, unsigned long arg);
+
+#endif /* __XYLON_FB_DATA_H__ */
diff -uNr linux-xlnx//drivers/video/xylon/xylonfb/core/xylonfb-ioctl.c linux-xlnx_xfb_14.1_build3//drivers/video/xylon/xylonfb/core/xylonfb-ioctl.c
--- linux-xlnx//drivers/video/xylon/xylonfb/core/xylonfb-ioctl.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-xlnx_xfb_14.1_build3//drivers/video/xylon/xylonfb/core/xylonfb-ioctl.c	2012-07-02 16:40:26.000000000 +0200
@@ -0,0 +1,515 @@
+/*
+ * Xylon logiCVC frame buffer driver IOCTL functions
+ *
+ * Author: Xylon d.o.o.
+ * e-mail: davor.joja@logicbricks.com
+ *
+ * This driver was based on skeletonfb.c and other fb video drivers.
+ * 2012 Xylon d.o.o.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+
+#include <linux/uaccess.h>
+#include <linux/xylonfb.h>
+#include "logicvc.h"
+#include "xylonfb.h"
+
+
+static int xylonfb_get_vblank(struct fb_vblank *vblank, struct fb_info *fbi)
+{
+	vblank->flags |= FB_VBLANK_HAVE_VSYNC;
+
+	return 0;
+}
+
+static int xylonfb_wait_for_vsync(u32 crt, struct fb_info *fbi)
+{
+	struct xylonfb_layer_data *layer_data = fbi->par;
+	struct xylonfb_common_data *common_data = layer_data->xylonfb_cd;
+	u32 imr;
+	int ret, cnt;
+
+	mutex_lock(&common_data->irq_mutex);
+
+	cnt = common_data->xylonfb_vsync.cnt;
+
+	/* prepare LOGICVC V-sync interrupt */
+	imr = readl(layer_data->reg_base_virt + LOGICVC_INT_MASK_ROFF);
+	imr &= (~LOGICVC_V_SYNC_INT);
+	/* clear LOGICVC V-sync interrupt */
+	writel(LOGICVC_V_SYNC_INT, layer_data->reg_base_virt + LOGICVC_INT_ROFF);
+	/* enable LOGICVC V-sync interrupt */
+	writel(imr, layer_data->reg_base_virt + LOGICVC_INT_MASK_ROFF);
+
+	ret = wait_event_interruptible_timeout(
+			common_data->xylonfb_vsync.wait,
+			(cnt != common_data->xylonfb_vsync.cnt), HZ/10);
+
+	/* disable LOGICVC V-sync interrupt */
+	imr |= LOGICVC_V_SYNC_INT;
+	writel(imr, layer_data->reg_base_virt + LOGICVC_INT_MASK_ROFF);
+
+	mutex_unlock(&common_data->irq_mutex);
+
+	if (ret < 0)
+		return ret;
+	else if (ret == 0)
+		return -ETIMEDOUT;
+
+	return 0;
+}
+
+static unsigned int alpha_normalized(unsigned int alpha,
+	unsigned int used_bits, bool get)
+{
+	if (get)
+		return ((((255 << 16) / ((1 << used_bits)-1)) * alpha) >> 16);
+	else
+		return (alpha / (255 / ((1 << used_bits)-1)));
+}
+
+static int xylonfb_layer_alpha(struct xylonfb_layer_data *layer_data,
+	unsigned int *alpha, bool get)
+{
+	unsigned int used_bits;
+
+	if (layer_data->layer_fix.alpha_mode != LOGICVC_LAYER_ALPHA)
+		return -EPERM;
+
+	switch (layer_data->layer_fix.bpp_virt) {
+	case 8:
+		used_bits = 3;
+		break;
+	case 16:
+		used_bits = 6;
+		break;
+	case 32:
+		used_bits = 8;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (get) {
+		*alpha =
+			readl(layer_data->layer_reg_base_virt + LOGICVC_LAYER_ALPHA_ROFF);
+		*alpha &= (0xFF >> (8-used_bits));
+	}
+
+	/* get/set normalized alpha value */
+	*alpha = alpha_normalized(*alpha, used_bits, get);
+
+	if (!get)
+		writel(*alpha,
+			layer_data->layer_reg_base_virt + LOGICVC_LAYER_ALPHA_ROFF);
+
+	return 0;
+}
+
+static int xylonfb_layer_color_rgb(struct xylonfb_layer_data *layer_data,
+	struct xylonfb_layer_color *layer_color, unsigned int reg_offset, bool get)
+{
+	void *base;
+	u32 raw_rgb, r, g, b;
+	int bpp, alpha_mode;
+
+	if (reg_offset == LOGICVC_LAYER_TRANSP_ROFF) {
+		base = layer_data->layer_reg_base_virt;
+		bpp = layer_data->layer_fix.bpp_virt;
+		alpha_mode = layer_data->layer_fix.alpha_mode;
+	} else {
+		base = layer_data->reg_base_virt;
+		bpp = layer_data->xylonfb_cd->bg_layer_bpp;
+		alpha_mode = layer_data->xylonfb_cd->bg_layer_alpha_mode;
+	}
+
+	if (get) {
+		raw_rgb = readl(base + reg_offset);
+check_bpp_get:
+		/* convert HW color format to RGB-888 */
+		switch (bpp) {
+		case 8:
+			switch (alpha_mode) {
+			case LOGICVC_CLUT_16BPP_ALPHA:
+				/* RGB-565 */
+				bpp = 16;
+				goto check_bpp_get;
+				break;
+			case LOGICVC_CLUT_32BPP_ALPHA:
+				/* RGB-888 */
+				bpp = 32;
+				goto check_bpp_get;
+				break;
+			default:
+				/* RGB-332 */
+				r = raw_rgb >> 5;
+				r = (((r << 3) | r) << 2) | (r >> 1);
+				g = (raw_rgb >> 2) & 0x07;
+				g = (((g << 3) | g) << 2) | (g >> 1);
+				b = raw_rgb & 0x03;
+				b = (b << 6) | (b << 4) | (b << 2) | b;
+				break;
+			}
+			break;
+		case 16:
+			/* RGB-565 */
+			r = raw_rgb >> 11;
+			r = (r << 3) | (r >> 2);
+			g = (raw_rgb >> 5) & 0x3F;
+			g = (g << 2) | (g >> 4);
+			b = raw_rgb & 0x1F;
+			b = (b << 3) | (b >> 2);
+			break;
+		case 32:
+			/* RGB-888 */
+			r = raw_rgb >> 16;
+			g = (raw_rgb >> 8) & 0xFF;
+			b = raw_rgb & 0xFF;
+			break;
+		default:
+			raw_rgb = r = g = b = 0;
+		}
+		layer_color->raw_rgb = raw_rgb;
+		layer_color->r = (u8)r;
+		layer_color->g = (u8)g;
+		layer_color->b = (u8)b;
+	} else {
+		if (layer_color->use_raw) {
+			raw_rgb = layer_color->raw_rgb;
+		} else {
+			r = layer_color->r;
+			g = layer_color->g;
+			b = layer_color->b;
+check_bpp_set:
+			/* convert RGB-888 to HW color format */
+			switch (bpp) {
+			case 8:
+				switch (alpha_mode) {
+				case LOGICVC_CLUT_16BPP_ALPHA:
+					/* RGB-565 */
+					bpp = 16;
+					goto check_bpp_set;
+					break;
+				case LOGICVC_CLUT_32BPP_ALPHA:
+					/* RGB-888 */
+					bpp = 32;
+					goto check_bpp_set;
+					break;
+				default:
+					raw_rgb =
+						(r & 0xE0) | ((g & 0xE0) >> 3) | ((b & 0xC0) >> 6);
+					break;
+				}
+				break;
+			case 16:
+				raw_rgb =
+					((r & 0xF8) << 8) | ((g & 0xFC) << 3) | ((b & 0xF8) >> 3);
+				break;
+			case 32:
+				raw_rgb = (r << 16) | (g << 8) | b;
+				break;
+			default:
+				raw_rgb = 0;
+			}
+		}
+		writel(raw_rgb, base + reg_offset);
+	}
+
+	return 0;
+}
+
+static int xylonfb_layer_pos_sz(struct fb_info *fbi,
+	struct xylonfb_layer_pos_size *layer_pos_sz, bool get)
+{
+	struct xylonfb_layer_data *layer_data = fbi->par;
+	u32 x, y, width, height, xres, yres;
+
+	xres = fbi->var.xres;
+	yres = fbi->var.yres;
+
+	if (get) {
+		x = readl(layer_data->layer_reg_base_virt + LOGICVC_LAYER_HOR_POS_ROFF);
+		layer_pos_sz->x = xres - (x + 1);
+		y = readl(layer_data->layer_reg_base_virt + LOGICVC_LAYER_VER_POS_ROFF);
+		layer_pos_sz->y = yres - (y + 1);
+		layer_pos_sz->width =
+			readl(layer_data->layer_reg_base_virt + LOGICVC_LAYER_WIDTH_ROFF);
+		layer_pos_sz->width += 1;
+		layer_pos_sz->height =
+			readl(layer_data->layer_reg_base_virt + LOGICVC_LAYER_HEIGHT_ROFF);
+		layer_pos_sz->height += 1;
+	} else {
+		x = layer_pos_sz->x;
+		y = layer_pos_sz->y;
+		width = layer_pos_sz->width;
+		height = layer_pos_sz->height;
+
+		if ((x > xres) || (y > yres))
+			return -EINVAL;
+
+		if ((x + width) > xres) {
+			width = xres - x;
+			layer_pos_sz->width = width;
+		}
+		if ((y + height) > yres) {
+			height = yres - y;
+			layer_pos_sz->height = height;
+		}
+
+		writel((width - 1),
+			layer_data->layer_reg_base_virt + LOGICVC_LAYER_WIDTH_ROFF);
+		writel((height - 1),
+			layer_data->layer_reg_base_virt + LOGICVC_LAYER_HEIGHT_ROFF);
+		writel((xres - (x + 1)),
+			layer_data->layer_reg_base_virt + LOGICVC_LAYER_HOR_POS_ROFF);
+		writel((yres - (y + 1)),
+			layer_data->layer_reg_base_virt + LOGICVC_LAYER_VER_POS_ROFF);
+	}
+
+	return 0;
+}
+
+int xylonfb_ioctl(struct fb_info *fbi, unsigned int cmd, unsigned long arg)
+{
+	struct xylonfb_layer_data *layer_data = fbi->par;
+	union {
+		struct fb_vblank vblank;
+		struct xylonfb_layer_color layer_color;
+		struct xylonfb_layer_pos_size layer_pos_sz;
+		struct xylonfb_hw_access hw_access;
+	} ioctl;
+	void __user *argp = (void __user *)arg;
+	u32 var32;
+	unsigned long val, layer_buffs, layer_id;
+	int ret = 0;
+
+	switch (cmd) {
+	case FBIOGET_VBLANK:
+		driver_devel("FBIOGET_VBLANK\n");
+		if (copy_from_user(&ioctl.vblank, argp, sizeof(ioctl.vblank)))
+			return -EFAULT;
+		ret = xylonfb_get_vblank(&ioctl.vblank, fbi);
+		if (!ret)
+			if (copy_to_user(argp, &ioctl.vblank, sizeof(ioctl.vblank)))
+				ret = -EFAULT;
+		break;
+
+	case FBIO_WAITFORVSYNC:
+		driver_devel("FBIO_WAITFORVSYNC\n");
+		if (get_user(var32, (u32 __user *)arg))
+			return -EFAULT;
+		ret = xylonfb_wait_for_vsync(var32, fbi);
+		break;
+
+	case XYLONFB_GET_LAYER_IDX:
+		driver_devel("XYLONFB_GET_LAYER_IDX\n");
+		val = layer_data->layer_fix.layer_fix_info & 0x0F;
+		put_user(val, (unsigned long __user *)arg);
+		break;
+
+	case XYLONFB_GET_LAYER_ALPHA:
+		driver_devel("XYLONFB_GET_LAYER_ALPHA\n");
+		ret = xylonfb_layer_alpha(layer_data, (unsigned int *)&val, true);
+		if (!ret)
+			put_user(val, (unsigned long __user *)arg);
+		break;
+
+	case XYLONFB_SET_LAYER_ALPHA:
+		driver_devel("XYLONFB_SET_LAYER_ALPHA\n");
+		if (get_user(val, (unsigned long __user *)arg))
+			return -EFAULT;
+		mutex_lock(&layer_data->layer_mutex);
+		ret = xylonfb_layer_alpha(layer_data, (unsigned int *)&val, false);
+		mutex_unlock(&layer_data->layer_mutex);
+		break;
+
+	case XYLONFB_LAYER_COLOR_TRANSP:
+		driver_devel("XYLONFB_LAYER_COLOR_TRANSP\n");
+		if (get_user(val, (unsigned long __user *)arg))
+			return -EFAULT;
+		mutex_lock(&layer_data->layer_mutex);
+		var32 =
+			readl(layer_data->layer_reg_base_virt + LOGICVC_LAYER_CTRL_ROFF);
+		if (val)
+			var32 |= (1 << 1); /* logiCVC layer transparency disabled */
+		else
+			var32 &= ~(1 << 1); /* logiCVC layer transparency enabled */
+		writel(var32,
+			layer_data->layer_reg_base_virt + LOGICVC_LAYER_CTRL_ROFF);
+		mutex_unlock(&layer_data->layer_mutex);
+		break;
+
+	case XYLONFB_GET_LAYER_COLOR_TRANSP:
+		driver_devel("XYLONFB_GET_LAYER_COLOR_TRANSP\n");
+		if (copy_from_user(&ioctl.layer_color, argp,
+			sizeof(ioctl.layer_color)))
+			return -EFAULT;
+		ret = xylonfb_layer_color_rgb(layer_data, &ioctl.layer_color,
+			LOGICVC_LAYER_TRANSP_ROFF, true);
+		if (!ret)
+			if (copy_to_user(argp, &ioctl.layer_color,
+				sizeof(ioctl.layer_color)))
+				ret = -EFAULT;
+		break;
+
+	case XYLONFB_SET_LAYER_COLOR_TRANSP:
+		driver_devel("XYLONFB_SET_LAYER_COLOR_TRANSP\n");
+		if (copy_from_user(&ioctl.layer_color, argp,
+			sizeof(ioctl.layer_color)))
+			return -EFAULT;
+		mutex_lock(&layer_data->layer_mutex);
+		ret = xylonfb_layer_color_rgb(layer_data, &ioctl.layer_color,
+			LOGICVC_LAYER_TRANSP_ROFF, false);
+		mutex_unlock(&layer_data->layer_mutex);
+		break;
+
+	case XYLONFB_GET_LAYER_SIZE_POS:
+		driver_devel("XYLONFB_GET_LAYER_SIZE_POS\n");
+		if (copy_from_user(&ioctl.layer_pos_sz, argp,
+			sizeof(ioctl.layer_pos_sz)))
+			return -EFAULT;
+		ret = xylonfb_layer_pos_sz(fbi, &ioctl.layer_pos_sz, true);
+		if (!ret)
+			if (copy_to_user(argp, &ioctl.layer_pos_sz,
+				sizeof(ioctl.layer_pos_sz)))
+				ret = -EFAULT;
+		break;
+
+	case XYLONFB_SET_LAYER_SIZE_POS:
+		driver_devel("XYLONFB_SET_LAYER_SIZE_POS\n");
+		if (copy_from_user(&ioctl.layer_pos_sz, argp,
+			sizeof(ioctl.layer_pos_sz)))
+			return -EFAULT;
+		mutex_lock(&layer_data->layer_mutex);
+		ret = xylonfb_layer_pos_sz(fbi, &ioctl.layer_pos_sz, false);
+		if (!ret)
+			if (copy_to_user(argp, &ioctl.layer_pos_sz,
+				sizeof(ioctl.layer_pos_sz)))
+				ret = -EFAULT;
+		mutex_unlock(&layer_data->layer_mutex);
+		break;
+
+	case XYLONFB_GET_LAYER_BUFFER:
+		driver_devel("XYLONFB_GET_LAYER_BUFFER\n");
+		layer_id = layer_data->layer_fix.layer_fix_info & 0x0F;
+		var32 = readl(layer_data->reg_base_virt + LOGICVC_DOUBLE_VBUFF_ROFF);
+		var32 >>= ((layer_id << 1)); /* get buffer */
+		val = var32 & 0x03;
+		put_user(val, (unsigned long __user *)arg);
+		break;
+
+	case XYLONFB_SET_LAYER_BUFFER:
+		driver_devel("XYLONFB_SET_LAYER_BUFFER\n");
+		if (get_user(val, (unsigned long __user *)arg))
+			return -EFAULT;
+		layer_buffs = layer_data->layer_fix.layer_fix_info >> 4;
+		if (val >= layer_buffs)
+			return -EINVAL;
+		layer_id = layer_data->layer_fix.layer_fix_info & 0x0F;
+		mutex_lock(&layer_data->layer_mutex);
+		var32 = readl(layer_data->reg_base_virt + LOGICVC_DOUBLE_VBUFF_ROFF);
+		var32 |= (1 << (10 + layer_id)); /* set layer */
+		var32 &= ~(0x03 << (layer_id << 1)); /* clear previous buffer */
+		var32 |= (val << (layer_id << 1)); /* set buffer */
+		writel(var32, layer_data->reg_base_virt + LOGICVC_DOUBLE_VBUFF_ROFF);
+		ret = xylonfb_wait_for_vsync(var32, fbi);
+		mutex_unlock(&layer_data->layer_mutex);
+		break;
+
+	case XYLONFB_GET_LAYER_BUFFER_OFFSET:
+		driver_devel("XYLONFB_GET_LAYER_BUFFER_OFFSET\n");
+		layer_buffs = layer_data->layer_fix.layer_fix_info >> 4;
+		layer_id = layer_data->layer_fix.layer_fix_info & 0x0F;
+		var32 = readl(layer_data->reg_base_virt + LOGICVC_DOUBLE_VBUFF_ROFF);
+		var32 >>= ((layer_id << 1)); /* get buffer */
+		var32 &= 0x03;
+		val = layer_data->layer_fix.height / layer_buffs;
+		val *= var32;
+		put_user(val, (unsigned long __user *)arg);
+		break;
+
+	case XYLONFB_GET_LAYER_BUFFERS_NUM:
+		driver_devel("XYLONFB_GET_LAYER_BUFFERS_NUM\n");
+		layer_buffs = layer_data->layer_fix.layer_fix_info >> 4;
+		put_user(layer_buffs, (unsigned long __user *)arg);
+		break;
+
+	case XYLONFB_GET_BACKGROUND_COLOR:
+		driver_devel("XYLONFB_GET_BACKGROUND_COLOR\n");
+		if (layer_data->xylonfb_cd->bg_layer_bpp == 0)
+			return -EPERM;
+		if (copy_from_user(&ioctl.layer_color, argp,
+			sizeof(ioctl.layer_color)))
+			return -EFAULT;
+		ret = xylonfb_layer_color_rgb(layer_data, &ioctl.layer_color,
+			LOGICVC_BACKCOL_ROFF, true);
+		if (!ret)
+			if (copy_to_user(argp, &ioctl.layer_color,
+				sizeof(ioctl.layer_color)))
+				ret = -EFAULT;
+		break;
+
+	case XYLONFB_SET_BACKGROUND_COLOR:
+		driver_devel("XYLONFB_SET_BACKGROUND_COLOR\n");
+		if (layer_data->xylonfb_cd->bg_layer_bpp == 0)
+			return -EPERM;
+		if (copy_from_user(&ioctl.layer_color, argp,
+			sizeof(ioctl.layer_color)))
+			return -EFAULT;
+		mutex_lock(&layer_data->layer_mutex);
+		ret = xylonfb_layer_color_rgb(layer_data, &ioctl.layer_color,
+			LOGICVC_BACKCOL_ROFF, false);
+		mutex_unlock(&layer_data->layer_mutex);
+		break;
+
+	case XYLONFB_LAYER_EXT_BUFF_SWITCH:
+		driver_devel("XYLONFB_LAYER_EXT_BUFF_SWITCH\n");
+		if (get_user(val, (unsigned long __user *)arg))
+			return -EFAULT;
+		mutex_lock(&layer_data->layer_mutex);
+		var32 =
+			readl(layer_data->layer_reg_base_virt + LOGICVC_LAYER_CTRL_ROFF);
+		if (val)
+			var32 |= (1 << 2);
+		else
+			var32 &= ~(1 << 2);
+		writel(var32,
+			layer_data->layer_reg_base_virt + LOGICVC_LAYER_CTRL_ROFF);
+		mutex_unlock(&layer_data->layer_mutex);
+		break;
+
+	case XYLONFB_READ_HW_REG:
+		driver_devel("XYLONFB_READ_HW_REG\n");
+		if (copy_from_user(&ioctl.hw_access, argp,
+			sizeof(ioctl.hw_access)))
+			return -EFAULT;
+		ioctl.hw_access.value =
+			readl(layer_data->reg_base_virt + ioctl.hw_access.offset);
+		if (copy_to_user(argp, &ioctl.hw_access,
+			sizeof(ioctl.hw_access)))
+			ret = -EFAULT;
+		break;
+
+	case XYLONFB_WRITE_HW_REG:
+		driver_devel("XYLONFB_READ_HW_REG\n");
+		if (copy_from_user(&ioctl.hw_access, argp,
+			sizeof(ioctl.hw_access)))
+			return -EFAULT;
+		writel(ioctl.hw_access.value,
+			layer_data->reg_base_virt + ioctl.hw_access.offset);
+		if (copy_to_user(argp, &ioctl.hw_access,
+			sizeof(ioctl.hw_access)))
+			ret = -EFAULT;
+		break;
+
+	default:
+		driver_devel("IOCTL_ERROR\n");
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
diff -uNr linux-xlnx//drivers/video/xylon/xylonfb/core/xylonfb-pixclk.c linux-xlnx_xfb_14.1_build3//drivers/video/xylon/xylonfb/core/xylonfb-pixclk.c
--- linux-xlnx//drivers/video/xylon/xylonfb/core/xylonfb-pixclk.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-xlnx_xfb_14.1_build3//drivers/video/xylon/xylonfb/core/xylonfb-pixclk.c	2012-09-18 12:17:50.316231000 +0200
@@ -0,0 +1,215 @@
+/*
+ * Xylon logiCVC frame buffer driver pixel clock generation
+ *
+ * Author: Xylon d.o.o.
+ * e-mail: davor.joja@logicbricks.com
+ *
+ * 2012 (c) Xylon d.o.o.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+
+/*
+ * This file implements HW dependent functionality for controlling pixel clock
+ * generation on various HW platforms.
+ */
+
+
+#define HW_PIXEL_CLOCK_CHANGE_SUPPORTED 1
+
+
+#if defined(CONFIG_FB_XYLON_EXT_PIXCLK)
+
+#if defined (HW_PIXEL_CLOCK_CHANGE_SUPPORTED)
+#undef HW_PIXEL_CLOCK_CHANGE_SUPPORTED
+#endif
+#define HW_PIXEL_CLOCK_CHANGE_SUPPORTED 0
+
+#include <linux/kernel.h>
+
+int xylonfb_hw_pixclk_set(unsigned long pixclk_khz)
+{
+	pr_info("Pixel clock change not supported\n");
+	return 0;
+}
+
+#elif defined(CONFIG_FB_XYLON_CLKGEN_PIXCLK)
+
+#include <asm/io.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#ifdef CONFIG_OF
+/* For open firmware. */
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/of_platform.h>
+#endif
+#include "clkgen.h"
+
+int	xylonfb_hw_pixclk_set(unsigned long	pixclk_khz)
+{
+	long *clk_regs;
+	struct clkgen_freq_out freq_out;
+	long regs[NUM_CLK_REGS];
+	int i;
+	unsigned long address, size, osc_freq_hz;
+#ifdef CONFIG_OF
+	struct device_node *dn;
+	dn = of_find_node_by_name(NULL,	"clkgen");
+	if(dn) {
+		const unsigned int *val;
+		int	vallen;
+		val	 = of_get_property(dn, "reg", &vallen);
+		address	= be32_to_cpu(val[0]);
+		size	= be32_to_cpu(val[1]);
+		val	= of_get_property(dn, "osc-clk-freq-hz", &vallen);
+		osc_freq_hz	= be32_to_cpu(val[0]);
+	} else
+#endif
+	{
+		address	= 0x40010000;
+		size	= 22*4;
+		osc_freq_hz	= 100000000;
+	}
+
+	clk_regs = (long*)ioremap_nocache(address, size);
+	if(!clk_regs) {
+		pr_err("Error mapping SLCR\n");
+		return -EBUSY;
+	}
+
+	/* same freq on all outputs */
+	for(i=0;i<NUM_CLK_OUTPUTS;i++){
+		freq_out.freq_out_hz[i]=pixclk_khz*1000;
+	}
+
+	clkgen_calc_regs(&freq_out,	pixclk_khz*1000, osc_freq_hz, regs);
+
+	writel(1, clk_regs+CKLGEN_RST_REG_OFF);
+	udelay(10);
+	writel(0, clk_regs+CKLGEN_RST_REG_OFF);
+
+	for(i=0;i<21;i++){
+		writel(regs[i],	clk_regs+CKLGEN_RAM_OFF+i);
+	}
+
+	while(1){
+		if(readl(clk_regs+CKLGEN_PLL_OFF) &	CLKGEN_PLL_RST_MASK)
+		{
+			writel(((1	<< 1)	| CLKGEN_PLL_RST_MASK),	clk_regs+CKLGEN_PLL_OFF);
+			break;
+		}
+	}
+	iounmap(clk_regs);
+	return 0;
+}
+
+#elif defined(CONFIG_FB_XYLON_ZYNQ_PS_PIXCLK)
+
+#include <asm/io.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+
+int xylonfb_hw_pixclk_set(unsigned long pixclk_khz)
+{
+	unsigned long pllclk, sysclk;
+	unsigned long div, delta, delta_dec, delta_inc;
+	void *slcr_regs, *clk_regs, *rst_reg;
+
+	/* all clock values are in kHz */
+	pllclk = 1000000;
+	sysclk = 100000;
+
+	slcr_regs = ioremap_nocache(0xF8000004, 8);
+	if (!slcr_regs) {
+		pr_err("Error mapping SLCR\n");
+		return -EBUSY;
+	}
+	clk_regs = ioremap_nocache(0xF8000170, 32);
+	if (!clk_regs) {
+		pr_err("Error setting xylonfb pixelclock\n");
+		iounmap(slcr_regs);
+		return -EBUSY;
+	}
+	rst_reg = ioremap_nocache(0xF8000240, 4);
+	if (!rst_reg) {
+		pr_err("Error setting xylonfb pixelclock\n");
+		iounmap(clk_regs);
+		iounmap(slcr_regs);
+		return -EBUSY;
+	}
+
+	/* unlock register access */
+	writel(0xDF0D, (slcr_regs+4));
+	/* calculate system clock divisor */
+//	div = pllclk / sysclk;
+	/* prepare for register writting */
+//	div = (div + 0x1000) << 8;
+	/* set system clock */
+//	writel(div, clk_regs);
+	/* calculate video clock divisor */
+	div = pllclk / pixclk_khz;
+	delta = (pllclk / div) - pixclk_khz;
+	if (delta != 0) {
+		delta_inc = pixclk_khz - (pllclk / (div+1));
+		delta_dec = (pllclk / (div-1)) - pixclk_khz;
+		if (delta < delta_inc) {
+			if (delta > delta_dec)
+				div--;
+			//else
+			//	div = div;
+		} else {
+			if (delta > delta_dec) {
+				if (delta_inc > delta_dec)
+					div--;
+				else
+					div++;
+			} else {
+				div++;
+			}
+		}
+	}
+	/* prepare for register writting */
+	div = (div + 0x1000) << 8;
+	/* set video clock */
+	writel(div, (clk_regs+0x10));
+	/* reset FPGA */
+//	writel(0, rst_reg);
+//	writel(0x1, rst_reg);
+//	writel(0, rst_reg);
+	/* lock register access */
+	writel(0x767B, slcr_regs);
+
+	iounmap(rst_reg);
+	iounmap(clk_regs);
+	iounmap(slcr_regs);
+
+	return 0;
+}
+
+#elif defined(CONFIG_FB_XYLON_ZC702_PIXCLK)
+
+#include <linux/i2c/si570.h>
+
+int xylonfb_hw_pixclk_set(unsigned long pixclk_khz)
+{
+	struct i2c_client *si570_client;
+
+	si570_client = get_i2c_client_si570();
+	if (si570_client)
+		return set_frequency_si570(&si570_client->dev, (pixclk_khz * 1000));
+	else
+		return -EPERM;
+}
+
+#endif
+
+
+bool xylonfb_hw_pixclk_change(void)
+{
+	return HW_PIXEL_CLOCK_CHANGE_SUPPORTED;
+}
diff -uNr linux-xlnx//drivers/video/xylon/xylonfb/Kconfig linux-xlnx_xfb_14.1_build3//drivers/video/xylon/xylonfb/Kconfig
--- linux-xlnx//drivers/video/xylon/xylonfb/Kconfig	2012-05-15 03:09:09.000000000 +0200
+++ linux-xlnx_xfb_14.1_build3//drivers/video/xylon/xylonfb/Kconfig	2012-09-13 17:03:08.068711000 +0200
@@ -1,5 +1,5 @@
 menuconfig FB_XYLON
-	bool "Xylon logiCVC frame buffer support"
+	tristate "Xylon logiCVC frame buffer support"
 	depends on FB
 	default n
 	select FB_CFB_FILLRECT
@@ -9,41 +9,52 @@
 	  Choose this option if you want to use the Xylon logiCVC as frame
 	  buffer device. Without the support of PCI & AGP.
 
+choice
+	prompt "Xylon frame buffer driver type"
+	depends on FB_XYLON
+	default FB_XYLON_PLATFORM
+
 config FB_XYLON_PLATFORM
 	bool "Xylon logiCVC frame buffer platform driver"
-	default n
-	depends on FB_XYLON
 	help
 	  Choose this option if you want to use the Xylon frame buffer driver
-	  as platform driver type, regardless on Open Firmware (OF) support in
-	  kernel.
+	  as platform driver type. This is selected by default.
 
-config FB_XYLON_NUM_FBS
-	int "Number of framebuffers"
-	range 0 4
-	default 0
+config FB_XYLON_OF
+	bool "Xylon logiCVC frame buffer Open Firmware driver"
+	help
+	  Choose this option if you want to use the Xylon frame buffer driver
+	  as Open Firmware driver type.
+endchoice
+
+choice
+	prompt "Xylon logiCVC pixel clock source"
 	depends on FB_XYLON
+	default FB_XYLON_ZYNQ_PS_PIXCLK
+
+config FB_XYLON_EXT_PIXCLK
+	bool "External pixel clock"
 	help
-	  Select the number of framebuffers created. Xylon logiCVC has minimum 1
-	  and maximum 5 physical layers. If set to 0, number of frame buffers will
-	  be determined from Device Tree Script or platform parameters. If set to
-	  other valid value, this value will limit number of frame buffer devices
-	  created.
+	  Pixel clock is generated from external clock generator which is not
+	  controllable by Xylon framebuffer driver.
 
 config FB_XYLON_ZYNQ_PS_PIXCLK
 	bool "Zynq PS pixel clock"
-	depends on FB_XYLON
-	default n
 	help
 	  Support for pixel clock generation from Zynq PS internal clock generator.
 
+config FB_XYLON_CLKGEN_PIXCLK
+	bool "Xylon clkgen pixel clock"
+	help
+	  Support for pixel clock generation from Xylon clkgen FGPA IP core.
+
 config FB_XYLON_ZC702_PIXCLK
 	bool "ZC702 board pixel clock"
-	depends on FB_XYLON
-	default n
-	select I2C
 	select SYSFS
+	select I2C
 	select MISC_DEVICES
 	select SI570
+	select ADV7511
 	help
-	  Support for pixel clock generation from ZC702 external clock generator.
+	  Support for pixel clock generation from ZC702 SI570 clock generator.
+endchoice
diff -uNr linux-xlnx//drivers/video/xylon/xylonfb/logicvc.h linux-xlnx_xfb_14.1_build3//drivers/video/xylon/xylonfb/logicvc.h
--- linux-xlnx//drivers/video/xylon/xylonfb/logicvc.h	2012-05-15 03:09:09.000000000 +0200
+++ linux-xlnx_xfb_14.1_build3//drivers/video/xylon/xylonfb/logicvc.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,119 +0,0 @@
-/*
- * Xylon logiCVC IP core definitions
- *
- * Author: Xylon d.o.o.
- * e-mail: davor.joja@logicbricks.com
- *
- * 2012 (c) Xylon d.o.o.
- *
- * This file is licensed under the terms of the GNU General Public License
- * version 2.  This program is licensed "as is" without any warranty of any
- * kind, whether express or implied.
- */
-
-#ifndef	__LOGICVC_H__
-#define __LOGICVC_H__
-
-/* All logiCVC registers are 32 bit registers, at distance of 64 bit */
-#define LOGICVC_REG_DIST_USED      8                           /* All logicvc registers are spaced at 8 bytes */
-#define LOGICVC_SHSY_FP_ROFF      (0  * LOGICVC_REG_DIST_USED) /* R_HSY_FP */
-#define LOGICVC_SHSY_ROFF         (1  * LOGICVC_REG_DIST_USED) /* R_HSY */
-#define LOGICVC_SHSY_BP_ROFF      (2  * LOGICVC_REG_DIST_USED) /* R_HSY_BP */
-#define LOGICVC_SHSY_RES_ROFF     (3  * LOGICVC_REG_DIST_USED) /* R_HSY_RES */
-#define LOGICVC_SVSY_FP_ROFF      (4  * LOGICVC_REG_DIST_USED) /* R_VSY_FP */
-#define LOGICVC_SVSY_ROFF         (5  * LOGICVC_REG_DIST_USED) /* R_VSY */
-#define LOGICVC_SVSY_BP_ROFF      (6  * LOGICVC_REG_DIST_USED) /* R_VSY_BP */
-#define LOGICVC_SVSY_RES_ROFF     (7  * LOGICVC_REG_DIST_USED) /* R_VSY_RES */
-#define LOGICVC_SCTRL_ROFF        (8  * LOGICVC_REG_DIST_USED) /* R_CTRL */
-#define LOGICVC_SDTYPE_ROFF       (9  * LOGICVC_REG_DIST_USED) /* R_DTYPE */
-#define LOGICVC_BACKCOL_ROFF      (10 * LOGICVC_REG_DIST_USED) /* R_BACKGROUND */
-#define LOGICVC_DOUBLE_VBUFF_ROFF (11 * LOGICVC_REG_DIST_USED) /* R_DOUBLE_VBUFF */
-#define LOGICVC_DOUBLE_CLUT_ROFF  (12 * LOGICVC_REG_DIST_USED) /* R_DOUBLE_CLUT */
-#define LOGICVC_INT_ROFF          (13 * LOGICVC_REG_DIST_USED) /* R_INT */
-#define LOGICVC_INT_MASK_ROFF     (14 * LOGICVC_REG_DIST_USED) /* R_INT_MASK */
-#define LOGICVC_SPWRCTRL_ROFF     (15 * LOGICVC_REG_DIST_USED) /* R_PWRCTRL */
-
-/* logiCVC layer registers base and distance between the layers */
-//#define LOGICVC_LAYER_DISTANCE   (16  * LOGICVC_REG_DIST_USED)                           /* distance between groups of layer registers */
-//#define LOGICVC_LAYER0_BASE_ROFF (32  * LOGICVC_REG_DIST_USED)                           /* offset to the beginning of layer 0 registers */
-//#define LOGICVC_LAYER1_BASE_ROFF (LOGICVC_LAYER0_BASE_ROFF + LOGICVC_LAYER_DISTANCE * 1) /* offset to the beginning of layer 1 registers */
-//#define LOGICVC_LAYER2_BASE_ROFF (LOGICVC_LAYER0_BASE_ROFF + LOGICVC_LAYER_DISTANCE * 2) /* offset to the beginning of layer 2 registers */
-//#define LOGICVC_LAYER3_BASE_ROFF (LOGICVC_LAYER0_BASE_ROFF + LOGICVC_LAYER_DISTANCE * 3) /* offset to the beginning of layer 3 registers */
-//#define LOGICVC_LAYER4_BASE_ROFF (LOGICVC_LAYER0_BASE_ROFF + LOGICVC_LAYER_DISTANCE * 4) /* offset to the beginning of layer 4 registers */
-/* logiCVC layer registers offsets (common for each layer) */
-#define LOGICVC_LAYER_HOR_OFF_ROFF (0 * LOGICVC_REG_DIST_USED) /*  LH_OFFSET   */
-#define LOGICVC_LAYER_VER_OFF_ROFF (1 * LOGICVC_REG_DIST_USED) /*  LV_OFFSET   */
-#define LOGICVC_LAYER_HOR_POS_ROFF (2 * LOGICVC_REG_DIST_USED) /*  LH_POSITION */
-#define LOGICVC_LAYER_VER_POS_ROFF (3 * LOGICVC_REG_DIST_USED) /*  LV_POSITION */
-#define LOGICVC_LAYER_WIDTH_ROFF   (4 * LOGICVC_REG_DIST_USED) /*  LH_WIDTH    */
-#define LOGICVC_LAYER_HEIGHT_ROFF  (5 * LOGICVC_REG_DIST_USED) /*  LV_HEIGHT   */
-#define LOGICVC_LAYER_ALPHA_ROFF   (6 * LOGICVC_REG_DIST_USED) /*  ALPHA       */
-#define LOGICVC_LAYER_CTRL_ROFF    (7 * LOGICVC_REG_DIST_USED) /*  CTRL        */
-#define LOGICVC_LAYER_TRANSP_ROFF  (8 * LOGICVC_REG_DIST_USED) /*  TRANSPARENT */
-
-/* logiCVC interrupt bits */
-#define LOGICVC_L0_VBUFF_SW_INT   0x01
-#define LOGICVC_L1_VBUFF_SW_INT   0x02
-#define LOGICVC_L2_VBUFF_SW_INT   0x04
-#define LOGICVC_L3_VBUFF_SW_INT   0x08
-#define LOGICVC_L4_VBUFF_SW_INT   0x10
-#define LOGICVC_V_SYNC_INT        0x20
-#define LOGICVC_E_VIDEO_VALID_INT 0x40
-#define LOGICVC_L0_CLUT_SW_INT    0x100
-#define LOGICVC_L1_CLUT_SW_INT    0x200
-#define LOGICVC_L2_CLUT_SW_INT    0x400
-#define LOGICVC_L3_CLUT_SW_INT    0x800
-#define LOGICVC_L4_CLUT_SW_INT    0x1000
-
-/* logiCVC layer base offsets */
-#define LOGICVC_LAYER_BASE_OFFSET 0x100
-#define LOGICVC_LAYER_0_OFFSET    0
-#define LOGICVC_LAYER_1_OFFSET    0x80
-#define LOGICVC_LAYER_2_OFFSET    0x100
-#define LOGICVC_LAYER_3_OFFSET    0x180
-#define LOGICVC_LAYER_4_OFFSET    0x200
-
-/* logiCVC layer CLUT base offsets */
-#define LOGICVC_CLUT_BASE_OFFSET      0x1000
-#define LOGICVC_CLUT_L0_CLUT_0_OFFSET 0
-#define LOGICVC_CLUT_L0_CLUT_1_OFFSET 0x800
-#define LOGICVC_CLUT_L1_CLUT_0_OFFSET 0x1000
-#define LOGICVC_CLUT_L1_CLUT_1_OFFSET 0x1800
-#define LOGICVC_CLUT_L2_CLUT_0_OFFSET 0x2000
-#define LOGICVC_CLUT_L2_CLUT_1_OFFSET 0x2800
-#define LOGICVC_CLUT_L3_CLUT_0_OFFSET 0x3000
-#define LOGICVC_CLUT_L3_CLUT_1_OFFSET 0x3800
-#define LOGICVC_CLUT_L4_CLUT_0_OFFSET 0x4000
-#define LOGICVC_CLUT_L4_CLUT_1_OFFSET 0x4800
-#define LOGICVC_CLUT_REGISTER_SIZE    8
-
-/* logiCVC register and CLUT base offsets */
-#define LOGICVC_GENERAL_REGISTERS_RANGE 0x100
-#define LOGICVC_REGISTERS_RANGE         0x6000
-
-/* logiCVC register initial values */
-#define CTRL_REG_INIT 0x001F
-#define SD_REG_INIT   0
-
-/* logiCVC display power signals */
-#define LOGICVC_EN_BLIGHT_MSK 0x01
-#define LOGICVC_EN_VDD_MSK    0x02
-#define LOGICVC_EN_VEE_MSK    0x04
-#define LOGICVC_V_EN_MSK      0x08
-
-/* logiCVC various definitions */
-#define LOGICVC_MAX_LAYERS             5
-#define LOGICVC_LAYER_ON               0x10
-#define LOGICVC_MAX_VRES               4096 /* this value must be 2048! for now it's hacked */
-#define TRANSPARENT_COLOR_8BPP_CLUT_16 0xF813
-#define TRANSPARENT_COLOR_8BPP_CLUT_24 0x00FF009C
-#define TRANSPARENT_COLOR_16BPP        0xF813
-#define TRANSPARENT_COLOR_24BPP        0x00FF009C
-#define BACKGROUND_COLOR               0x00000000
-
-#define LOGICVC_LAYER_ALPHA      0
-#define LOGICVC_PIXEL_ALPHA      1
-#define LOGICVC_CLUT_16BPP_ALPHA 2
-#define LOGICVC_CLUT_32BPP_ALPHA 3
-
-#endif /* __LOGICVC_H__ */
diff -uNr linux-xlnx//drivers/video/xylon/xylonfb/Makefile linux-xlnx_xfb_14.1_build3//drivers/video/xylon/xylonfb/Makefile
--- linux-xlnx//drivers/video/xylon/xylonfb/Makefile	2012-05-15 03:09:09.000000000 +0200
+++ linux-xlnx_xfb_14.1_build3//drivers/video/xylon/xylonfb/Makefile	2012-06-29 20:36:16.000000000 +0200
@@ -1,2 +1,2 @@
-obj-$(CONFIG_FB_XYLON) += xylonfb.o
-xylonfb-y := xylonfb-main.o xylonfb-vmode.o xylonfb-pixclk.o
+obj-$(CONFIG_FB_XYLON_OF) += of/
+obj-$(CONFIG_FB_XYLON_PLATFORM) += platform/
diff -uNr linux-xlnx//drivers/video/xylon/xylonfb/of/Makefile linux-xlnx_xfb_14.1_build3//drivers/video/xylon/xylonfb/of/Makefile
--- linux-xlnx//drivers/video/xylon/xylonfb/of/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-xlnx_xfb_14.1_build3//drivers/video/xylon/xylonfb/of/Makefile	2012-09-13 17:02:54.487952000 +0200
@@ -0,0 +1,4 @@
+obj-$(CONFIG_FB_XYLON) += xylonfb.o
+xylonfb-objs := ../core/xylonfb.o ../core/xylonfb-ioctl.o \
+	../core/xylonfb-pixclk.o ../core/clkgen.o
+xylonfb-$(CONFIG_FB_XYLON_OF) += xylonfb-of.o
diff -uNr linux-xlnx//drivers/video/xylon/xylonfb/of/xylonfb-of.c linux-xlnx_xfb_14.1_build3//drivers/video/xylon/xylonfb/of/xylonfb-of.c
--- linux-xlnx//drivers/video/xylon/xylonfb/of/xylonfb-of.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-xlnx_xfb_14.1_build3//drivers/video/xylon/xylonfb/of/xylonfb-of.c	2012-09-13 16:46:36.159707000 +0200
@@ -0,0 +1,432 @@
+/*
+ * Xylon logiCVC frame buffer Open Firmware driver
+ *
+ * Author: Xylon d.o.o.
+ * e-mail: davor.joja@logicbricks.com
+ *
+ * 2012 Xylon d.o.o.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/errno.h>
+#include <linux/of.h>
+#include "../core/xylonfb.h"
+
+
+static void set_ctrl_reg(struct xylonfb_init_data *init_data,
+	unsigned long pix_data_invert, unsigned long pix_clk_act_high)
+{
+	u32 sync = init_data->vmode_data.fb_vmode.sync;
+	u32 ctrl = CTRL_REG_INIT;
+
+	if (sync & (1<<0)) {	//FB_SYNC_HOR_HIGH_ACT
+		ctrl &= (~(1<<1));
+	}
+	if (sync & (1<<1)) {	// FB_SYNC_VERT_HIGH_ACT
+		ctrl &= (~(1<<3));
+	}
+	if (pix_data_invert) {
+		ctrl |= LOGICVC_PIX_DATA_INVERT;
+	}
+	if (pix_clk_act_high) {
+		ctrl |= LOGICVC_PIX_ACT_HIGH;
+	}
+
+	init_data->vmode_data.ctrl_reg = ctrl;
+}
+
+static int xylonfb_parse_vram_info(struct device_node *np,
+	unsigned long *vmem_base_addr, unsigned long *vmem_high_addr)
+{
+	u32 const *prop;
+	int size;
+
+	prop = of_get_property(np, "vmem-baseaddr", &size);
+	if (!prop) {
+		pr_err("Error xylonfb getting VRAM address begin\n");
+		return -EINVAL;
+	}
+	*vmem_base_addr = be32_to_cpup(prop);
+
+	prop = of_get_property(np, "vmem-highaddr", &size);
+	if (!prop) {
+		pr_err("Error xylonfb getting VRAM address end\n");
+		return -EINVAL;
+	}
+	*vmem_high_addr = be32_to_cpup(prop);
+
+	return 0;
+}
+
+static int xylonfb_parse_layer_info(struct device_node *np,
+	struct xylonfb_init_data *init_data)
+{
+	u32 const *prop;
+	unsigned int layers, bg_bpp, bg_alpha_mode;
+	int size;
+	char bg_layer_name[25];
+
+	prop = of_get_property(np, "num-of-layers", &size);
+	if (!prop) {
+		pr_err("Error getting number of layers\n");
+		return -EINVAL;
+	}
+	layers = be32_to_cpup(prop);
+
+	prop = of_get_property(np, "use-background", &size);
+	if (!prop) {
+		pr_err("Error getting use background\n");
+		return -EINVAL;
+	}
+	if (be32_to_cpup(prop) == 1) {
+		layers--;
+
+		sprintf(bg_layer_name, "layer-%d-data-width", layers);
+		prop = of_get_property(np, bg_layer_name, &size);
+		if (!prop)
+			bg_bpp = 16;
+		else
+			bg_bpp = be32_to_cpup(prop);
+		if (bg_bpp == 24)
+			bg_bpp = 32;
+
+		sprintf(bg_layer_name, "layer-%d-alpha-mode", layers);
+		prop = of_get_property(np, bg_layer_name, &size);
+		if (!prop) {
+			bg_alpha_mode = LOGICVC_LAYER_ALPHA;
+		} else {
+			bg_alpha_mode = be32_to_cpup(prop);
+		}
+	} else {
+		bg_bpp = 0;
+		bg_alpha_mode = 0;
+		pr_debug("xylonfb no BG layer\n");
+	}
+
+	init_data->layers = (unsigned char)layers;
+	init_data->bg_layer_bpp = (unsigned char)bg_bpp;
+	init_data->bg_layer_alpha_mode = (unsigned char)bg_alpha_mode;
+
+	return 0;
+}
+
+static int xylonfb_parse_vmode_info(struct device_node *np,
+	struct xylonfb_init_data *init_data)
+{
+	struct device_node *dn, *vmode_dn;
+	u32 const *prop;
+	char *c;
+	unsigned long pix_data_invert, pix_clk_act_high;
+	int size, tmp;
+
+	init_data->active_layer = 0;
+	init_data->vmode_params_set = false;
+
+	dn = of_find_node_by_name(NULL, "xylon-video-params");
+	if (dn == NULL) {
+		pr_err("Error getting video mode parameters\n");
+		return -ENOENT;
+	}
+
+	pix_data_invert = 0;
+	prop = of_get_property(dn, "pixel-data-invert", &size);
+	if (!prop)
+		pr_err("Error getting pixel data invert\n");
+	else
+		pix_data_invert = be32_to_cpup(prop);
+	pix_clk_act_high = 0;
+	prop = of_get_property(dn, "pixel-clock-active-high", &size);
+	if (!prop)
+		pr_err("Error getting pixel active edge\n");
+	else
+		pix_clk_act_high = be32_to_cpup(prop);
+
+	prop = of_get_property(dn, "pixel-component-format", &size);
+	if (prop) {
+		if (!strcmp("ABGR", (char *)prop)) {
+			prop = of_get_property(dn, "pixel-component-layer", &size);
+			if (prop) {
+				while(size > 0) {
+					tmp = be32_to_cpup(prop);
+					init_data->layer_ctrl[tmp] = LOGICVC_SWAP_RB;
+					prop++;
+					size -= sizeof(prop);
+				}
+			}
+		}
+	}
+
+	prop = of_get_property(dn, "active-layer", &size);
+	if (prop) {
+		tmp = be32_to_cpup(prop);
+		init_data->active_layer = (unsigned char)tmp;
+	} else {
+		pr_info("xylonfb setting default layer to %d\n",
+			init_data->active_layer);
+	}
+
+	prop = of_get_property(dn, "videomode", &size);
+	if (prop) {
+		if (strlen((char *)prop) <= VMODE_NAME_SZ) {
+			strcpy(init_data->vmode_data.fb_vmode_name, (char *)prop);
+			vmode_dn =
+				of_find_node_by_name(dn, init_data->vmode_data.fb_vmode_name);
+			c = strchr((char *)prop, '_');
+			if (c)
+				*c = 0;
+			strcpy(init_data->vmode_data.fb_vmode_name, (char *)prop);
+		} else {
+			vmode_dn = NULL;
+			pr_err("Error videomode name to long\n");
+		}
+		if (vmode_dn) {
+			prop = of_get_property(vmode_dn, "refresh", &size);
+			if (!prop)
+				pr_err("Error getting refresh rate\n");
+			else
+				init_data->vmode_data.fb_vmode.refresh = be32_to_cpup(prop);
+
+			prop = of_get_property(vmode_dn, "xres", &size);
+			if (!prop)
+				pr_err("Error getting xres\n");
+			else
+				init_data->vmode_data.fb_vmode.xres = be32_to_cpup(prop);
+
+			prop = of_get_property(vmode_dn, "yres", &size);
+			if (!prop)
+				pr_err("Error getting yres\n");
+			else
+				init_data->vmode_data.fb_vmode.yres = be32_to_cpup(prop);
+
+			prop = of_get_property(vmode_dn, "pixclock-khz", &size);
+			if (!prop)
+				pr_err("Error getting pixclock-khz\n");
+			else
+				init_data->vmode_data.fb_vmode.pixclock =
+					KHZ2PICOS(be32_to_cpup(prop));
+
+			prop = of_get_property(vmode_dn, "left-margin", &size);
+			if (!prop)
+				pr_err("Error getting left-margin\n");
+			else
+				init_data->vmode_data.fb_vmode.left_margin = be32_to_cpup(prop);
+
+			prop = of_get_property(vmode_dn, "right-margin", &size);
+			if (!prop)
+				pr_err("Error getting right-margin\n");
+			else
+				init_data->vmode_data.fb_vmode.right_margin = be32_to_cpup(prop);
+
+			prop = of_get_property(vmode_dn, "upper-margin", &size);
+			if (!prop)
+				pr_err("Error getting upper-margin\n");
+			else
+				init_data->vmode_data.fb_vmode.upper_margin = be32_to_cpup(prop);
+
+			prop = of_get_property(vmode_dn, "lower-margin", &size);
+			if (!prop)
+				pr_err("Error getting lower-margin\n");
+			else
+				init_data->vmode_data.fb_vmode.lower_margin = be32_to_cpup(prop);
+
+			prop = of_get_property(vmode_dn, "hsync-len", &size);
+			if (!prop)
+				pr_err("Error getting hsync-len\n");
+			else
+				init_data->vmode_data.fb_vmode.hsync_len = be32_to_cpup(prop);
+
+			prop = of_get_property(vmode_dn, "vsync-len", &size);
+			if (!prop)
+				pr_err("Error getting vsync-len\n");
+			else
+				init_data->vmode_data.fb_vmode.vsync_len = be32_to_cpup(prop);
+
+			prop = of_get_property(vmode_dn, "sync", &size);
+			if (!prop)
+				pr_err("Error getting sync\n");
+			else
+				init_data->vmode_data.fb_vmode.sync = be32_to_cpup(prop);
+
+			prop = of_get_property(vmode_dn, "vmode", &size);
+			if (!prop)
+				pr_err("Error getting vmode\n");
+			else
+				init_data->vmode_data.fb_vmode.vmode = be32_to_cpup(prop);
+
+			init_data->vmode_params_set = true;
+		} else {
+			init_data->vmode_data.fb_vmode.refresh = 60;
+		}
+	} else {
+		pr_info("xylonfb using default driver video mode\n");
+	}
+
+	set_ctrl_reg(init_data, pix_data_invert, pix_clk_act_high);
+
+	return 0;
+}
+
+static int xylonfb_parse_layer_params(struct device_node *np,
+	int id, struct layer_fix_data *lfdata)
+{
+	u32 const *prop;
+	int size;
+	char layer_property_name[25];
+
+	sprintf(layer_property_name, "layer-%d-offset", id);
+	prop = of_get_property(np, layer_property_name, &size);
+	if (!prop) {
+		pr_err("Error getting layer offset\n");
+		return -EINVAL;
+	} else {
+		lfdata->offset = be32_to_cpup(prop);
+	}
+
+	sprintf(layer_property_name, "buffer-%d-offset", id);
+	prop = of_get_property(np, layer_property_name, &size);
+	if (!prop) {
+		pr_err("Error getting buffer offset\n");
+		return -EINVAL;
+	} else {
+		lfdata->buffer_offset = be32_to_cpup(prop);
+	}
+
+	prop = of_get_property(np, "row-stride", &size);
+	if (!prop)
+		lfdata->width = 1024;
+	else
+		lfdata->width = be32_to_cpup(prop);
+
+	sprintf(layer_property_name, "layer-%d-alpha-mode", id);
+	prop = of_get_property(np, layer_property_name, &size);
+	if (!prop) {
+		pr_err("Error getting layer alpha mode\n");
+		return -EINVAL;
+	} else {
+		lfdata->alpha_mode = be32_to_cpup(prop);
+	}
+
+	sprintf(layer_property_name, "layer-%d-data-width", id);
+	prop = of_get_property(np, layer_property_name, &size);
+	if (!prop)
+		lfdata->bpp = 16;
+	else
+		lfdata->bpp = be32_to_cpup(prop);
+	if (lfdata->bpp == 24)
+		lfdata->bpp = 32;
+
+	lfdata->bpp_virt = lfdata->bpp;
+
+	switch (lfdata->bpp) {
+		case 8:
+			if (lfdata->alpha_mode == LOGICVC_PIXEL_ALPHA)
+				lfdata->bpp = 16;
+			break;
+		case 16:
+			if (lfdata->alpha_mode == LOGICVC_PIXEL_ALPHA)
+				lfdata->bpp = 32;
+			break;
+	}
+
+	lfdata->layer_fix_info = id;
+
+	return 0;
+}
+
+
+static int xylonfb_of_probe(struct platform_device *pdev)
+{
+	struct xylonfb_init_data init_data;
+	int i, rc;
+
+	memset(&init_data, 0, sizeof(struct xylonfb_init_data));
+
+	init_data.pdev = pdev;
+
+	rc = xylonfb_parse_vram_info(pdev->dev.of_node,
+		&init_data.vmem_base_addr, &init_data.vmem_high_addr);
+	if (rc)
+		return rc;
+	rc = xylonfb_parse_layer_info(pdev->dev.of_node, &init_data);
+	if (rc)
+		return rc;
+	/* if Device-Tree contains video mode options do not use
+	   kernel command line video mode options */
+	xylonfb_parse_vmode_info(pdev->dev.of_node, &init_data);
+
+	for (i = 0; i < init_data.layers; i++) {
+		rc = xylonfb_parse_layer_params(pdev->dev.of_node, i,
+			&init_data.lfdata[i]);
+		if (rc)
+			return rc;
+	}
+
+	return xylonfb_init_driver(&init_data);
+}
+
+static int xylonfb_of_remove(struct platform_device *pdev)
+{
+	return xylonfb_deinit_driver(pdev);
+}
+
+
+static struct of_device_id xylonfb_of_match[] __devinitdata = {
+	{ .compatible = "xylon,logicvc-2.05.c" },
+	{/* end of table */},
+};
+MODULE_DEVICE_TABLE(of, xylonfb_of_match);
+
+
+static struct platform_driver xylonfb_of_driver = {
+	.probe = xylonfb_of_probe,
+	.remove = xylonfb_of_remove,
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = DEVICE_NAME,
+		.of_match_table = xylonfb_of_match,
+	},
+};
+
+
+static int __init xylonfb_of_init(void)
+{
+#ifndef MODULE
+	char *option = NULL;
+	/*
+	 *  For kernel boot options (in 'video=xxxfb:<options>' format)
+	 */
+	if (fb_get_options(DRIVER_NAME, &option))
+		return -ENODEV;
+	/* Set internal module parameters */
+	xylonfb_get_params(option);
+#endif
+	if (platform_driver_register(&xylonfb_of_driver)) {
+		pr_err("Error xylonfb driver registration\n");
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static void __exit xylonfb_of_exit(void)
+{
+	platform_driver_unregister(&xylonfb_of_driver);
+}
+
+
+#ifndef MODULE
+late_initcall(xylonfb_of_init);
+#else
+module_init(xylonfb_of_init);
+module_exit(xylonfb_of_exit);
+#endif
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION(DRIVER_DESCRIPTION);
+MODULE_VERSION(DRIVER_VERSION);
diff -uNr linux-xlnx//drivers/video/xylon/xylonfb/platform/Makefile linux-xlnx_xfb_14.1_build3//drivers/video/xylon/xylonfb/platform/Makefile
--- linux-xlnx//drivers/video/xylon/xylonfb/platform/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-xlnx_xfb_14.1_build3//drivers/video/xylon/xylonfb/platform/Makefile	2012-09-13 17:03:02.269310000 +0200
@@ -0,0 +1,4 @@
+obj-$(CONFIG_FB_XYLON) += xylonfb.o
+xylonfb-objs := ../core/xylonfb.o ../core/xylonfb-ioctl.o \
+	../core/xylonfb-pixclk.o  ../core/clkgen.o
+xylonfb-$(CONFIG_FB_XYLON_PLATFORM) += xylonfb-platform.o
diff -uNr linux-xlnx//drivers/video/xylon/xylonfb/platform/xylonfb-platform.c linux-xlnx_xfb_14.1_build3//drivers/video/xylon/xylonfb/platform/xylonfb-platform.c
--- linux-xlnx//drivers/video/xylon/xylonfb/platform/xylonfb-platform.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-xlnx_xfb_14.1_build3//drivers/video/xylon/xylonfb/platform/xylonfb-platform.c	2012-07-17 16:55:32.000000000 +0200
@@ -0,0 +1,207 @@
+/*
+ * Xylon logiCVC frame buffer platform driver
+ *
+ * Author: Xylon d.o.o.
+ * e-mail: davor.joja@logicbricks.com
+ *
+ * This driver was based on skeletonfb.c and other fb video drivers.
+ * 2012 Xylon d.o.o.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/errno.h>
+#include <linux/xylonfb_platform.h>
+#include "../core/xylonfb.h"
+
+
+static void xylonfb_get_platform_layer_params(
+	struct xylonfb_platform_layer_params *lparams,
+	struct layer_fix_data *lfdata, int id)
+{
+	lfdata->offset = lparams->offset;
+	lfdata->buffer_offset = lparams->buffer_offset;
+	lfdata->bpp = lparams->bpp;
+	lfdata->bpp_virt = lparams->bpp;
+	lfdata->alpha_mode = lparams->alpha_mode;
+
+	switch (lfdata->bpp) {
+		case 8:
+			if (lfdata->alpha_mode == LOGICVC_PIXEL_ALPHA)
+				lfdata->bpp = 16;
+			break;
+		case 16:
+			if (lfdata->alpha_mode == LOGICVC_PIXEL_ALPHA)
+				lfdata->bpp = 32;
+			break;
+	}
+
+	lfdata->layer_fix_info = id;
+}
+
+static int xylonfb_platform_probe(struct platform_device *pdev)
+{
+	struct xylonfb_init_data init_data;
+	struct xylonfb_platform_data *pdata;
+	int i;
+
+	memset(&init_data, 0, sizeof(struct xylonfb_init_data));
+
+	init_data.pdev = pdev;
+
+	pdata = (struct xylonfb_platform_data *)pdev->dev.platform_data;
+	init_data.vmem_base_addr = pdata->vmem_base_addr;
+	init_data.vmem_high_addr = pdata->vmem_high_addr;
+	init_data.vmode_data.ctrl_reg = pdata->ctrl_reg;
+	init_data.layers = pdata->num_layers;
+	init_data.active_layer = pdata->active_layer;
+	init_data.bg_layer_bpp = pdata->bg_layer_bpp;
+	init_data.bg_layer_alpha_mode = pdata->bg_layer_alpha_mode;
+	init_data.vmode_params_set = false;
+
+	for (i = 0; i < init_data.layers; i++) {
+		xylonfb_get_platform_layer_params(
+			&pdata->layer_params[i],
+			&init_data.lfdata[i], i);
+		init_data.lfdata[i].width = pdata->row_stride;
+		init_data.layer_ctrl[i] = pdata->layer_params[i].ctrl;
+	}
+
+	return xylonfb_init_driver(&init_data);
+}
+
+static int xylonfb_platform_remove(struct platform_device *pdev)
+{
+	return xylonfb_deinit_driver(pdev);
+}
+
+
+/* logiCVC parameters for Xylon Zynq-ZC702 2D3D referent design */
+static struct xylonfb_platform_layer_params logicvc_0_layer_params[] = {
+	{
+		.offset = 7290,
+		.buffer_offset = 1080,
+		.bpp = 32,
+		.alpha_mode = LOGICVC_PIXEL_ALPHA,
+		.ctrl = 0,
+	},
+	{
+		.offset = 4050,
+		.buffer_offset = 1080,
+		.bpp = 32,
+		.alpha_mode = LOGICVC_LAYER_ALPHA,
+		.ctrl = 0,
+	},
+	{
+		.offset = 0,
+		.buffer_offset = 1080,
+		.bpp = 32,
+		.alpha_mode = LOGICVC_LAYER_ALPHA,
+		.ctrl = 0,
+	},
+	{
+		.offset = 12960,
+		.buffer_offset = 1080,
+		.bpp = 8,
+		.alpha_mode = LOGICVC_CLUT_32BPP_ALPHA,
+		.ctrl = 0,
+	},
+};
+
+static struct xylonfb_platform_data logicvc_0_platform_data = {
+	.layer_params = logicvc_0_layer_params,
+	.ctrl_reg = (CTRL_REG_INIT | LOGICVC_PIX_ACT_HIGH),
+	.vmem_base_addr = 0x30000000,
+	.vmem_high_addr = 0x3FFFFFFF,
+	.row_stride = 2048,
+	.num_layers = ARRAY_SIZE(logicvc_0_layer_params),
+	.active_layer = 3,
+	.bg_layer_bpp = 32,
+	.bg_layer_alpha_mode = LOGICVC_LAYER_ALPHA,
+};
+
+static struct resource logicvc_0_resource[] = {
+	{
+		.start = 0x40030000,
+		.end = (0x40030000 + LOGICVC_REGISTERS_RANGE),
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = 90,
+		.end = 90,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device logicvc_device = {
+	.name = DEVICE_NAME,
+	.id = 0,
+	.dev = {
+		.platform_data = &logicvc_0_platform_data,
+	},
+	.resource = logicvc_0_resource,
+	.num_resources = ARRAY_SIZE(logicvc_0_resource),
+};
+
+
+static struct platform_driver xylonfb_driver = {
+	.probe = xylonfb_platform_probe,
+	.remove = xylonfb_platform_remove,
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = DEVICE_NAME,
+	},
+};
+
+
+static int __init xylonfb_platform_init(void)
+{
+	int err;
+
+#ifndef MODULE
+	char *option = NULL;
+	/*
+	 *  For kernel boot options (in 'video=xxxfb:<options>' format)
+	 */
+	if (fb_get_options(DRIVER_NAME, &option))
+		return -ENODEV;
+	/* Set internal module parameters */
+	xylonfb_get_params(option);
+#endif
+	err = platform_device_register(&logicvc_device);
+	if (err) {
+		pr_err("Error xylonfb device registration\n");
+		return err;
+	}
+	err = platform_driver_register(&xylonfb_driver);
+	if (err) {
+		pr_err("Error xylonfb driver registration\n");
+		platform_device_unregister(&logicvc_device);
+		return err;
+	}
+
+	return 0;
+}
+
+static void __exit xylonfb_platform_exit(void)
+{
+	platform_driver_unregister(&xylonfb_driver);
+	platform_device_unregister(&logicvc_device);
+}
+
+
+#ifndef MODULE
+late_initcall(xylonfb_platform_init);
+#else
+module_init(xylonfb_platform_init);
+module_exit(xylonfb_platform_exit);
+#endif
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION(DRIVER_DESCRIPTION);
+MODULE_VERSION(DRIVER_VERSION);
diff -uNr linux-xlnx//drivers/video/xylon/xylonfb/xylonfb-data.h linux-xlnx_xfb_14.1_build3//drivers/video/xylon/xylonfb/xylonfb-data.h
--- linux-xlnx//drivers/video/xylon/xylonfb/xylonfb-data.h	2012-05-15 03:09:09.000000000 +0200
+++ linux-xlnx_xfb_14.1_build3//drivers/video/xylon/xylonfb/xylonfb-data.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,72 +0,0 @@
-/*
- * Xylon logiCVC frame buffer driver internal data structures
- *
- * Author: Xylon d.o.o.
- * e-mail: davor.joja@logicbricks.com
- *
- * 2012 (c) Xylon d.o.o.
- *
- * This file is licensed under the terms of the GNU General Public License
- * version 2.  This program is licensed "as is" without any warranty of any
- * kind, whether express or implied.
- */
-
-#ifndef	__XYLON_FB_DATA_H__
-#define __XYLON_FB_DATA_H__
-
-
-/* FB driver flags */
-#define RES_CHANGE_DENIED  0
-#define RES_CHANGE_ALLOWED 1
-
-#define FB_DMA_BUFFER 0x01
-#define FB_MEMORY_LE  0x02
-#define FB_CHANGE_RES 0x10
-
-
-struct layer_fix_data {
-	unsigned short offset;
-	unsigned short width;
-	unsigned short height;
-	unsigned char bpp;
-	unsigned char bpp_virt;
-	unsigned char alpha_mode;
-};
-
-struct xylonfb_sync {
-	wait_queue_head_t wait;
-	unsigned int cnt;
-};
-
-struct xylonfb_common_data {
-	struct mutex irq_mutex;
-	struct xylonfb_sync xylonfb_vsync;
-	/* Delay after applying display power and
-		before applying display signals */
-	unsigned int power_on_delay;
-	/* Delay after applying display signal and
-		before applying display backlight power supply */
-	unsigned int signal_on_delay;
-	unsigned char xylonfb_irq;
-	unsigned char xylonfb_use_ref;
-	unsigned char xylonfb_flags;
-	unsigned char xylonfb_used_layer;
-};
-
-struct xylonfb_layer_data {
-	struct xylonfb_common_data *xylonfb_cd;
-	spinlock_t layer_lock;
-	dma_addr_t reg_base_phys;
-	dma_addr_t fb_phys;
-	void *reg_base_virt;
-	void *fb_virt;
-	unsigned long fb_size;
-	void *layer_reg_base_virt;
-	void *layer_clut_base_virt;
-	struct layer_fix_data layer_fix;
-	unsigned char layer_info;
-	unsigned char layer_use_ref;
-	unsigned char layers;
-};
-
-#endif /* __XYLON_FB_DATA_H__ */
diff -uNr linux-xlnx//drivers/video/xylon/xylonfb/xylonfb-main.c linux-xlnx_xfb_14.1_build3//drivers/video/xylon/xylonfb/xylonfb-main.c
--- linux-xlnx//drivers/video/xylon/xylonfb/xylonfb-main.c	2012-05-15 03:09:09.000000000 +0200
+++ linux-xlnx_xfb_14.1_build3//drivers/video/xylon/xylonfb/xylonfb-main.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1934 +0,0 @@
-/*
- * Xylon logiCVC frame buffer driver
- *
- * Author: Xylon d.o.o.
- * e-mail: davor.joja@logicbricks.com
- *
- * This driver was based on skeletonfb.c and other fb video drivers.
- * 2012 Xylon d.o.o.
- *
- * This file is licensed under the terms of the GNU General Public License
- * version 2.  This program is licensed "as is" without any warranty of any
- * kind, whether express or implied.
- */
-
-/*
-	Driver information:
-	logiCVC must have background layer for proper functioning of screen
-	blanking functions.
-	logiCVC layers should be in order such that layer index and video memory
-	addresses increases. e.g. L0 VRAM addr 0x1000, L1 VRAM addr 0x2000, etc...
- */
-
-#include <asm/io.h>
-#include <asm/unaligned.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/dma-mapping.h>
-#include <linux/interrupt.h>
-#include <linux/ioctl.h>
-#include <linux/delay.h>
-#include <linux/uaccess.h>
-#include <linux/console.h>
-#include <linux/errno.h>
-#include <linux/mm.h>
-#include <linux/init.h>
-#include <linux/fs.h>
-#include <linux/types.h>
-#include <linux/stat.h>
-#include <linux/fb.h>
-#include <linux/vt.h>
-#include <linux/xylonfb.h>
-#include "logicvc.h"
-#include "xylonfb-data.h"
-#include "xylonfb-vmode.h"
-#include "xylonfb-pixclk.h"
-
-#if defined (CONFIG_OF) && !defined (CONFIG_FB_XYLON_PLATFORM)
-#define FB_XYLON_CONFIG_OF
-#endif
-
-
-#define dbg(...) //printk(KERN_INFO __VA_ARGS__)
-
-#define DRIVER_NAME "xylonfb"
-#define PLATFORM_DRIVER_NAME "logicvc"
-#define DRIVER_DESCRIPTION "Xylon logiCVC frame buffer driver"
-
-#define XYLONFB_IOC_MAGIC   'x'
-#define XYLONFB_IOC_GETVRAM _IO(XYLONFB_IOC_MAGIC, 0)
-
-#define XYLONFB_PSEUDO_PALETTE_SZ 256
-
-static unsigned short logicvc_layer_reg_offset[] = {
-	(LOGICVC_LAYER_BASE_OFFSET + LOGICVC_LAYER_0_OFFSET),
-	(LOGICVC_LAYER_BASE_OFFSET + LOGICVC_LAYER_1_OFFSET),
-	(LOGICVC_LAYER_BASE_OFFSET + LOGICVC_LAYER_2_OFFSET),
-	(LOGICVC_LAYER_BASE_OFFSET + LOGICVC_LAYER_3_OFFSET),
-	(LOGICVC_LAYER_BASE_OFFSET + LOGICVC_LAYER_4_OFFSET)
-};
-
-static unsigned short logicvc_clut_reg_offset[] = {
-	(LOGICVC_CLUT_BASE_OFFSET + LOGICVC_CLUT_L0_CLUT_0_OFFSET),
-	(LOGICVC_CLUT_BASE_OFFSET + LOGICVC_CLUT_L0_CLUT_1_OFFSET),
-	(LOGICVC_CLUT_BASE_OFFSET + LOGICVC_CLUT_L1_CLUT_0_OFFSET),
-	(LOGICVC_CLUT_BASE_OFFSET + LOGICVC_CLUT_L1_CLUT_1_OFFSET),
-	(LOGICVC_CLUT_BASE_OFFSET + LOGICVC_CLUT_L2_CLUT_0_OFFSET),
-	(LOGICVC_CLUT_BASE_OFFSET + LOGICVC_CLUT_L2_CLUT_1_OFFSET),
-	(LOGICVC_CLUT_BASE_OFFSET + LOGICVC_CLUT_L3_CLUT_0_OFFSET),
-	(LOGICVC_CLUT_BASE_OFFSET + LOGICVC_CLUT_L3_CLUT_1_OFFSET),
-	(LOGICVC_CLUT_BASE_OFFSET + LOGICVC_CLUT_L4_CLUT_0_OFFSET),
-	(LOGICVC_CLUT_BASE_OFFSET + LOGICVC_CLUT_L4_CLUT_1_OFFSET)
-};
-
-static struct fb_videomode drv_vmode;
-static char *mode_option __devinitdata;
-
-/* Function declarations */
-static inline void xylonfb_set_fbi_timings(struct fb_var_screeninfo *var);
-static int xylonfb_set_timings(struct fb_info *fbi, int bpp, bool change_res);
-static void xylonfb_start_logicvc(struct fb_info *fbi);
-static void xylonfb_stop_logicvc(struct fb_info *fbi);
-
-extern struct xylonfb_vmode_params xylonfb_vmode;
-
-
-static int xylonfb_set_pixelclock(struct fb_info *fbi)
-{
-	dbg("%s\n", __func__);
-
-	return pixclk_set(fbi);
-}
-
-static irqreturn_t xylonfb_isr(int irq, void *dev_id)
-{
-	struct fb_info **afbi = (struct fb_info **)dev_id;
-	struct fb_info *fbi = afbi[0];
-	struct xylonfb_layer_data *layer_data = fbi->par;
-	struct xylonfb_common_data *common_data =
-		layer_data->xylonfb_cd;
-	u32 isr;
-
-	dbg("%s\n", __func__);
-
-	isr = readl(layer_data->reg_base_virt + LOGICVC_INT_ROFF);
-	if (isr & LOGICVC_V_SYNC_INT) {
-		writel(LOGICVC_V_SYNC_INT,
-			layer_data->reg_base_virt + LOGICVC_INT_ROFF);
-		common_data->xylonfb_vsync.cnt++;
-		wake_up_interruptible(&common_data->xylonfb_vsync.wait);
-		return IRQ_HANDLED;
-	} else
-		return IRQ_NONE;
-}
-
-static int xylonfb_open(struct fb_info *fbi, int user)
-{
-	struct xylonfb_layer_data *layer_data = fbi->par;
-
-	dbg("%s\n", __func__);
-
-	spin_lock(&layer_data->layer_lock);
-
-	if (layer_data->layer_use_ref == 0) {
-		/* turn on layer */
-		writel(1, (layer_data->layer_reg_base_virt + LOGICVC_LAYER_CTRL_ROFF));
-		/* set layer ON flag */
-		layer_data->layer_info |= LOGICVC_LAYER_ON;
-	}
-	layer_data->layer_use_ref++;
-	layer_data->xylonfb_cd->xylonfb_use_ref++;
-
-	spin_unlock(&layer_data->layer_lock);
-
-	return 0;
-}
-
-static int xylonfb_release(struct fb_info *fbi, int user)
-{
-	struct xylonfb_layer_data *layer_data = fbi->par;
-
-	dbg("%s\n", __func__);
-
-	spin_lock(&layer_data->layer_lock);
-
-	layer_data->layer_use_ref--;
-	if (layer_data->layer_use_ref == 0) {
-		/* turn off layer */
-		writel(0, (layer_data->layer_reg_base_virt + LOGICVC_LAYER_CTRL_ROFF));
-		/* set layer OFF flag */
-		layer_data->layer_info &= (~LOGICVC_LAYER_ON);
-	}
-	layer_data->xylonfb_cd->xylonfb_use_ref--;
-
-	spin_unlock(&layer_data->layer_lock);
-
-	return 0;
-}
-
-static int xylonfb_check_var(struct fb_var_screeninfo *var,
-	struct fb_info *fbi)
-{
-	struct xylonfb_layer_data *layer_data = fbi->par;
-	int ret;
-	bool denied = 0;
-	char vmode_opt[20+1];
-
-	dbg("%s\n", __func__);
-
-	/* HW layer bpp value can not be changed */
-	if (var->bits_per_pixel != fbi->var.bits_per_pixel) {
-		if (var->bits_per_pixel == 24)
-			var->bits_per_pixel = 32;
-		else
-			return -EINVAL;
-	}
-
-	if ((var->xres != fbi->var.xres) || (var->yres != fbi->var.yres)) {
-		sprintf(vmode_opt, "%dx%dM-%d@60",
-			var->xres, var->yres, var->bits_per_pixel);
-		mode_option = vmode_opt;
-		printk(KERN_INFO "xylonfb requested new video mode %s\n", mode_option);
-		ret = xylonfb_set_timings(fbi, var->bits_per_pixel, RES_CHANGE_ALLOWED);
-		if (ret == 1 || ret == 2)
-			layer_data->xylonfb_cd->xylonfb_flags |= FB_CHANGE_RES;
-		else
-			denied = 1;
-		mode_option = NULL;
-	}
-
-	if (var->xres_virtual > fbi->var.xres_virtual)
-		var->xres_virtual = fbi->var.xres_virtual;
-	if (var->yres_virtual > fbi->var.yres_virtual)
-		var->yres_virtual = fbi->var.yres_virtual;
-
-	if (fbi->var.xres != 0)
-		if ((var->xoffset + fbi->var.xres) >= fbi->var.xres_virtual)
-			var->xoffset = fbi->var.xres_virtual - fbi->var.xres - 1;
-	if (fbi->var.yres != 0)
-		if ((var->yoffset + fbi->var.yres) >= fbi->var.yres_virtual)
-			var->yoffset = fbi->var.yres_virtual - fbi->var.yres - 1;
-
-	var->transp.offset = fbi->var.transp.offset;
-	var->transp.length = fbi->var.transp.length;
-	var->transp.msb_right = fbi->var.transp.msb_right;
-	var->red.offset = fbi->var.red.offset;
-	var->red.length = fbi->var.red.length;
-	var->red.msb_right = fbi->var.red.msb_right;
-	var->green.offset = fbi->var.green.offset;
-	var->green.length = fbi->var.green.length;
-	var->green.msb_right = fbi->var.green.msb_right;
-	var->blue.offset = fbi->var.blue.offset;
-	var->blue.length = fbi->var.blue.length;
-	var->blue.msb_right = fbi->var.blue.msb_right;
-	var->activate = fbi->var.activate;
-	var->height = fbi->var.height;
-	var->width = fbi->var.width;
-	var->sync = fbi->var.sync;
-	var->rotate = fbi->var.rotate;
-
-	if (denied) {
-		printk(KERN_ERR "Error xylonfb res change not allowed\n");
-		return -EPERM;
-	}
-
-	return 0;
-}
-
-static int xylonfb_set_par(struct fb_info *fbi)
-{
-	struct xylonfb_layer_data *layer_data = fbi->par;
-	struct xylonfb_common_data *common_data =
-		layer_data->xylonfb_cd;
-
-	dbg("%s\n", __func__);
-
-	if (common_data->xylonfb_flags & FB_CHANGE_RES) {
-		xylonfb_set_fbi_timings(&fbi->var);
-		xylonfb_stop_logicvc(fbi);
-		if (xylonfb_set_pixelclock(fbi)) {
-			printk(KERN_ERR "Error xylonfb changing pixel clock\n");
-			return -EACCES;
-		}
-		xylonfb_start_logicvc(fbi);
-		common_data->xylonfb_flags &= (~FB_CHANGE_RES);
-		printk(KERN_INFO
-			"xylonfb new video mode: %dx%d-%dbpp@60\n",
-			fbi->var.xres, fbi->var.yres, fbi->var.bits_per_pixel);
-	}
-
-	return 0;
-}
-
-static int xylonfb_set_color_hw(u16 *transp, u16 *red, u16 *green, u16 *blue,
-	int len, int idx, struct fb_info *fbi)
-{
-	struct xylonfb_layer_data *layer_data = fbi->par;
-	struct layer_fix_data *lfdata = &layer_data->layer_fix;
-	u32 pixel;
-	int bpp_virt, toff, roff, goff, boff;
-
-	dbg("%s\n", __func__);
-
-	bpp_virt = lfdata->bpp_virt;
-
-	toff = fbi->var.transp.offset;
-	roff = fbi->var.red.offset;
-	goff = fbi->var.green.offset;
-	boff = fbi->var.blue.offset;
-
-	if (fbi->fix.visual == FB_VISUAL_PSEUDOCOLOR) {
-		u32 clut_value;
-
-		if (idx > 255 || len > 256)
-			return -EINVAL;
-
-		if (lfdata->alpha_mode == LOGICVC_CLUT_16BPP_ALPHA) {
-			if (transp) {
-				while (len > 0) {
-					clut_value =
-						((((transp[idx] & 0xFC) >> 2) << toff) |
-						(((red[idx] & 0xF8) >> 3) << roff) |
-						(((green[idx] & 0xFC) >> 2) << goff) |
-						(((blue[idx] & 0xF8) >> 3) << boff));
-					writel(clut_value, layer_data->layer_clut_base_virt +
-						(idx*LOGICVC_CLUT_REGISTER_SIZE));
-					len--;
-					idx++;
-				}
-			} else {
-				while (len > 0) {
-					clut_value =
-						((0x3F << toff) |
-						(((red[idx] & 0xF8) >> 3) << roff) |
-						(((green[idx] & 0xFC) >> 2) << goff) |
-						(((blue[idx] & 0xF8) >> 3) << boff));
-					writel(clut_value, layer_data->layer_clut_base_virt +
-						(idx*LOGICVC_CLUT_REGISTER_SIZE));
-					len--;
-					idx++;
-				}
-			}
-		} else if (lfdata->alpha_mode == LOGICVC_CLUT_32BPP_ALPHA) {
-			if (transp) {
-				while (len > 0) {
-					clut_value =
-						(((transp[idx] & 0xFF) << toff) |
-						((red[idx] & 0xFF) << roff) |
-						((green[idx] & 0xFF) << goff) |
-						((blue[idx] & 0xFF) << boff));
-					writel(clut_value, layer_data->layer_clut_base_virt +
-						(idx*LOGICVC_CLUT_REGISTER_SIZE));
-					len--;
-					idx++;
-				}
-			} else {
-				while (len > 0) {
-					clut_value =
-						((0xFF << toff) |
-						((red[idx] & 0xFF) << roff) |
-						((green[idx] & 0xFF) << goff) |
-						((blue[idx] & 0xFF) << boff));
-					writel(clut_value, layer_data->layer_clut_base_virt +
-						(idx*LOGICVC_CLUT_REGISTER_SIZE));
-					len--;
-					idx++;
-				}
-			}
-		}
-	} else if (fbi->fix.visual == FB_VISUAL_TRUECOLOR) {
-		if (bpp_virt == 8) {
-			if (lfdata->alpha_mode == LOGICVC_LAYER_ALPHA) {
-				while (len > 0) {
-					pixel = ((((red[idx] & 0xE0) >> 5) << roff) |
-						(((green[idx] & 0xE0) >> 5) << goff) |
-						(((blue[idx] & 0xC0) >> 6) << boff));
-					((u32 *)(fbi->pseudo_palette))[idx] =
-						(pixel << 24) | (pixel << 16) | (pixel << 8) | pixel;
-					len--;
-					idx++;
-				}
-			} else if (lfdata->alpha_mode == LOGICVC_PIXEL_ALPHA) {
-				if (transp) {
-					while (len > 0) {
-						pixel = ((((transp[idx] & 0xE0) >> 5) << toff) |
-							(((red[idx] & 0xE0) >> 5) << roff) |
-							(((green[idx] & 0xE0) >> 5) << goff) |
-							(((blue[idx] & 0xC0) >> 6) << boff));
-						((u32 *)(fbi->pseudo_palette))[idx] =
-							(pixel << 16) | pixel;
-						len--;
-						idx++;
-					}
-				} else {
-					while (len > 0) {
-						pixel = ((0x07 << toff) |
-							(((red[idx] & 0xE0) >> 5) << roff) |
-							(((green[idx] & 0xE0) >> 5) << goff) |
-							(((blue[idx] & 0xC0) >> 6) << boff));
-						((u32 *)(fbi->pseudo_palette))[idx] =
-							(pixel << 16) | pixel;
-						len--;
-						idx++;
-					}
-				}
-			}
-		} else if (bpp_virt == 16) {
-			if (lfdata->alpha_mode == LOGICVC_LAYER_ALPHA) {
-				while (len > 0) {
-					pixel = ((((red[idx] & 0xF8) >> 3) << roff) |
-						(((green[idx] & 0xFC) >> 2) << goff) |
-						(((blue[idx] & 0xF8) >> 3) << boff));
-					((u32 *)(fbi->pseudo_palette))[idx] =
-						(pixel << 16) | pixel;
-					len--;
-					idx++;
-				}
-			} else if (lfdata->alpha_mode == LOGICVC_PIXEL_ALPHA) {
-				if (transp) {
-					while (len > 0) {
-						((u32 *)(fbi->pseudo_palette))[idx] =
-							((((transp[idx] & 0xFC) >> 2) << toff) |
-							(((red[idx] & 0xF8) >> 3) << roff) |
-							(((green[idx] & 0xFC) >> 2) << goff) |
-							(((blue[idx] & 0xF8) >> 3) << boff));
-						len--;
-						idx++;
-					}
-				} else {
-					while (len > 0) {
-						((u32 *)(fbi->pseudo_palette))[idx] =
-							((0x3F << toff) |
-							(((red[idx] & 0xF8) >> 3) << roff) |
-							(((green[idx] & 0xFC) >> 2) << goff) |
-							(((blue[idx] & 0xF8) >> 3) << boff));
-						len--;
-						idx++;
-					}
-				}
-			}
-		} else if (bpp_virt == 32) {
-			if (lfdata->alpha_mode == LOGICVC_LAYER_ALPHA) {
-				while (len > 0) {
-					((u32 *)(fbi->pseudo_palette))[idx] =
-						(((red[idx] & 0xFF) << roff) |
-						((green[idx] & 0xFF) << goff) |
-						((blue[idx] & 0xFF) << boff));
-					len--;
-					idx++;
-				}
-			} else if (lfdata->alpha_mode == LOGICVC_PIXEL_ALPHA) {
-				if (transp) {
-					while (len > 0) {
-						((u32 *)(fbi->pseudo_palette))[idx] =
-							(((transp[idx] & 0xFF) << toff) |
-							((red[idx] & 0xFF) << roff) |
-							((green[idx] & 0xFF) << goff) |
-							((blue[idx] & 0xFF) << boff));
-						len--;
-						idx++;
-					}
-				} else {
-					while (len > 0) {
-						((u32 *)(fbi->pseudo_palette))[idx] =
-							((0xFF << toff) |
-							((red[idx] & 0xFF) << roff) |
-							((green[idx] & 0xFF) << goff) |
-							((blue[idx] & 0xFF) << boff));
-						len--;
-						idx++;
-					}
-				}
-			}
-		}
-	} else
-		return -EINVAL;
-
-	return 0;
-}
-
-static int xylonfb_set_color_reg(unsigned regno, unsigned red, unsigned green,
-	unsigned blue, unsigned transp, struct fb_info *fbi)
-{
-	dbg("%s\n", __func__);
-
-	return xylonfb_set_color_hw(
-			(u16 *)&transp,
-			(u16 *)&red,
-			(u16 *)&green,
-			(u16 *)&blue,
-			1, regno, fbi);
-}
-
-static int xylonfb_set_cmap(struct fb_cmap *cmap, struct fb_info *fbi)
-{
-	dbg("%s\n", __func__);
-
-	return
-		xylonfb_set_color_hw(cmap->transp, cmap->red, cmap->green, cmap->blue,
-			cmap->len, cmap->start, fbi);
-}
-
-static void xylonfb_set_pixels(struct fb_info *fbi,
-	struct xylonfb_layer_data *layer_data, int bpp, unsigned int pix)
-{
-	u32* vmem;
-	u8 *vmem8;
-	u16 *vmem16;
-	u32 *vmem32;
-	int x, y, pix_off;
-
-	dbg("%s\n", __func__);
-
-	vmem = layer_data->fb_virt +
-		(fbi->var.xoffset * (fbi->var.bits_per_pixel/4)) +
-		(fbi->var.yoffset * fbi->var.xres_virtual *
-		(fbi->var.bits_per_pixel/4));
-
-	switch (bpp) {
-		case 8:
-			vmem8 = (u8 *)vmem;
-			for (y = fbi->var.yoffset; y < fbi->var.yres; y++) {
-				pix_off = (y * fbi->var.xres_virtual);
-				for (x = fbi->var.xoffset; x < fbi->var.xres; x++)
-					vmem8[pix_off+x] = pix;
-			}
-			break;
-		case 16:
-			vmem16 = (u16 *)vmem;
-			for (y = fbi->var.yoffset; y < fbi->var.yres; y++) {
-				pix_off = (y * fbi->var.xres_virtual);
-				for (x = fbi->var.xoffset; x < fbi->var.xres; x++)
-					vmem16[pix_off+x] = pix;
-			}
-			break;
-		case 32:
-			vmem32 = (u32 *)vmem;
-			for (y = fbi->var.yoffset; y < fbi->var.yres; y++) {
-				pix_off = (y * fbi->var.xres_virtual);
-				for (x = fbi->var.xoffset; x < fbi->var.xres; x++)
-					vmem32[pix_off+x] = pix;
-			}
-			break;
-	}
-}
-
-static int xylonfb_blank(int blank_mode, struct fb_info *fbi)
-{
-	struct xylonfb_layer_data *layer_data = fbi->par;
-	struct layer_fix_data *lfdata = &layer_data->layer_fix;
-	u32 pix, reg;
-	int i;
-
-	dbg("%s\n", __func__);
-
-	switch (blank_mode) {
-		case FB_BLANK_UNBLANK:
-			dbg("FB_BLANK_UNBLANK\n");
-			reg = readl(layer_data->reg_base_virt + LOGICVC_SPWRCTRL_ROFF);
-			reg |= LOGICVC_V_EN_MSK;
-			writel(reg, layer_data->reg_base_virt + LOGICVC_SPWRCTRL_ROFF);
-			mdelay(50);
-			break;
-
-		case FB_BLANK_NORMAL:
-			dbg("FB_BLANK_NORMAL\n");
-			switch (lfdata->bpp_virt) {
-				case 8:
-					switch (lfdata->alpha_mode) {
-						case LOGICVC_LAYER_ALPHA:
-							xylonfb_set_pixels(fbi, layer_data, 8, 0x00);
-							break;
-						case LOGICVC_PIXEL_ALPHA:
-							xylonfb_set_pixels(fbi, layer_data, 16, 0xFF00);
-							break;
-						case LOGICVC_CLUT_16BPP_ALPHA:
-						case LOGICVC_CLUT_32BPP_ALPHA:
-							for (i = 0; i < 256; i++) {
-								pix = readl(layer_data->layer_clut_base_virt +
-									(i*LOGICVC_CLUT_REGISTER_SIZE));
-								pix &= 0x00FFFFFF;
-								if (pix == 0)
-									break;
-							}
-							xylonfb_set_pixels(fbi, layer_data, 8, i);
-							break;
-					}
-					break;
-				case 16:
-					switch (lfdata->alpha_mode) {
-						case LOGICVC_LAYER_ALPHA:
-							xylonfb_set_pixels(fbi, layer_data, 16, 0x0000);
-							break;
-						case LOGICVC_PIXEL_ALPHA:
-							xylonfb_set_pixels(fbi, layer_data, 32, 0xFF000000);
-							break;
-					}
-					break;
-				case 32:
-					xylonfb_set_pixels(fbi, layer_data, 32, 0xFF000000);
-					break;
-			}
-			break;
-
-		case FB_BLANK_POWERDOWN:
-			dbg("FB_BLANK_POWERDOWN\n");
-			reg = readl(layer_data->reg_base_virt + LOGICVC_SPWRCTRL_ROFF);
-			reg &= ~LOGICVC_V_EN_MSK;
-			writel(reg, layer_data->reg_base_virt + LOGICVC_SPWRCTRL_ROFF);
-			mdelay(50);
-			break;
-
-		case FB_BLANK_VSYNC_SUSPEND:
-		case FB_BLANK_HSYNC_SUSPEND:
-		default:
-			dbg("FB_BLANK_ not supported!\n");
-			return -EINVAL;
-	}
-
-	return 0;
-}
-
-static int xylonfb_pan_display(struct fb_var_screeninfo *var, struct fb_info *fbi)
-{
-	struct xylonfb_layer_data *layer_data = fbi->par;
-
-	dbg("%s\n", __func__);
-
-	if (fbi->var.xoffset == var->xoffset && fbi->var.yoffset == var->yoffset)
-		return 0;
-
-	/* check for negative values */
-	if (var->xoffset < 0)
-		var->xoffset += var->xres;
-	if (var->yoffset < 0)
-		var->yoffset += var->yres;
-
-	if (var->vmode & FB_VMODE_YWRAP) {
-		if (var->yoffset > fbi->var.yres_virtual ||
-			var->xoffset) {
-			return -EINVAL;
-		}
-	} else {
-		if (var->xoffset + var->xres > fbi->var.xres_virtual ||
-			var->yoffset + var->yres > fbi->var.yres_virtual) {
-			/* if smaller then physical layer video memory allow panning */
-			if ((var->xoffset + var->xres > layer_data->layer_fix.width)
-					||
-				(var->yoffset + var->yres > layer_data->layer_fix.height)) {
-				return -EINVAL;
-			}
-		}
-	}
-	fbi->var.xoffset = var->xoffset;
-	fbi->var.yoffset = var->yoffset;
-	if (var->vmode & FB_VMODE_YWRAP)
-		fbi->var.vmode |= FB_VMODE_YWRAP;
-	else
-		fbi->var.vmode &= ~FB_VMODE_YWRAP;
-	/* set HW memory X offset */
-	writel(var->xoffset, (layer_data->layer_reg_base_virt + LOGICVC_LAYER_HOR_OFF_ROFF));
-	/* set HW memory Y offset */
-	writel(var->yoffset, (layer_data->layer_reg_base_virt + LOGICVC_LAYER_VER_OFF_ROFF));
-	/* Apply changes */
-	writel((var->yres-1), (layer_data->layer_reg_base_virt + LOGICVC_LAYER_VER_POS_ROFF));
-
-	return 0;
-}
-
-static int xylonfb_get_vblank(struct fb_vblank *vblank, struct fb_info *fbi)
-{
-	dbg("%s\n", __func__);
-
-	vblank->flags |= FB_VBLANK_HAVE_VSYNC;
-
-	return 0;
-}
-
-static int xylonfb_wait_for_vsync(u32 crt, struct fb_info *fbi)
-{
-	struct xylonfb_layer_data *layer_data = fbi->par;
-	struct xylonfb_common_data *common_data =
-		layer_data->xylonfb_cd;
-	u32 imr;
-	int ret, cnt;
-
-	dbg("%s\n", __func__);
-
-	mutex_lock(&common_data->irq_mutex);
-
-	cnt = common_data->xylonfb_vsync.cnt;
-
-	/* prepare LOGICVC V-sync interrupt */
-	imr = readl(layer_data->reg_base_virt + LOGICVC_INT_MASK_ROFF);
-	imr &= (~LOGICVC_V_SYNC_INT);
-	/* clear LOGICVC V-sync interrupt */
-	writel(LOGICVC_V_SYNC_INT, layer_data->reg_base_virt + LOGICVC_INT_ROFF);
-	/* enable LOGICVC V-sync interrupt */
-	writel(imr, layer_data->reg_base_virt + LOGICVC_INT_MASK_ROFF);
-
-	ret = wait_event_interruptible_timeout(
-			common_data->xylonfb_vsync.wait,
-			(cnt != common_data->xylonfb_vsync.cnt), HZ/10);
-
-	/* disable LOGICVC V-sync interrupt */
-	imr |= LOGICVC_V_SYNC_INT;
-	writel(imr, layer_data->reg_base_virt + LOGICVC_INT_MASK_ROFF);
-
-	mutex_unlock(&common_data->irq_mutex);
-
-	if (ret < 0)
-		return ret;
-	else if (ret == 0) {
-		dbg("xylonfb timeout waiting for V-sync\n");
-		return -ETIMEDOUT;
-	}
-
-	return 0;
-}
-
-static int xylonfb_ioctl(struct fb_info *fbi, unsigned int cmd,
-	unsigned long arg)
-{
-	struct fb_var_screeninfo var;
-	struct fb_fix_screeninfo fix;
-	struct fb_vblank vblank;
-	void __user *argp = (void __user *)arg;
-	u32 crt;
-	long ret = 0;
-
-	dbg("%s\n", __func__);
-
-	switch (cmd) {
-	case FBIOGET_VSCREENINFO:
-		dbg("FBIOGET_VSCREENINFO\n");
-		if (!lock_fb_info(fbi))
-			return -ENODEV;
-		var = fbi->var;
-		unlock_fb_info(fbi);
-
-		ret = copy_to_user(argp, &var, sizeof(var)) ? -EFAULT : 0;
-		break;
-
-	case FBIOPUT_VSCREENINFO:
-		dbg("FBIOPUT_VSCREENINFO\n");
-		if (copy_from_user(&var, argp, sizeof(var)))
-			return -EFAULT;
-		if (!lock_fb_info(fbi))
-			return -ENODEV;
-		console_lock();
-		fbi->flags |= FBINFO_MISC_USEREVENT;
-		ret = fb_set_var(fbi, &var);
-		fbi->flags &= ~FBINFO_MISC_USEREVENT;
-		console_unlock();
-		unlock_fb_info(fbi);
-		if (!ret && copy_to_user(argp, &var, sizeof(var)))
-			ret = -EFAULT;
-		break;
-
-	case FBIOGET_FSCREENINFO:
-		dbg("FBIOGET_FSCREENINFO\n");
-		if (!lock_fb_info(fbi))
-			return -ENODEV;
-		fix = fbi->fix;
-		unlock_fb_info(fbi);
-
-		ret = copy_to_user(argp, &fix, sizeof(fix)) ? -EFAULT : 0;
-		break;
-
-	case FBIOPAN_DISPLAY:
-		dbg("FBIOPAN_DISPLAY\n");
-		if (copy_from_user(&var, argp, sizeof(var)))
-			return -EFAULT;
-		if (!lock_fb_info(fbi))
-			return -ENODEV;
-		console_lock();
-		ret = fb_pan_display(fbi, &var);
-		console_unlock();
-		unlock_fb_info(fbi);
-		if (ret == 0 && copy_to_user(argp, &var, sizeof(var)))
-			return -EFAULT;
-		break;
-
-	case FBIO_CURSOR:
-		dbg("FBIO_CURSOR\n");
-		ret = -EINVAL;
-		break;
-
-	case FBIOBLANK:
-		dbg("FBIOBLANK\n");
-		if (!lock_fb_info(fbi))
-			return -ENODEV;
-		console_lock();
-		fbi->flags |= FBINFO_MISC_USEREVENT;
-		ret = fb_blank(fbi, arg);
-		fbi->flags &= ~FBINFO_MISC_USEREVENT;
-		console_unlock();
-		unlock_fb_info(fbi);
-		break;
-
-	case FBIOGET_VBLANK:
-		dbg("FBIOGET_VBLANK\n");
-		if (copy_from_user(&vblank, argp, sizeof(vblank)))
-			return -EFAULT;
-		ret = xylonfb_get_vblank(&vblank, fbi);
-		if (!ret)
-			if (copy_to_user(argp, &vblank, sizeof(vblank)))
-				ret = -EFAULT;
-		break;
-
-	case FBIO_WAITFORVSYNC:
-		dbg("FBIO_WAITFORVSYNC\n");
-		if (get_user(crt, (u32 __user *) arg))
-			break;
-		ret = xylonfb_wait_for_vsync(crt, fbi);
-		break;
-
-	default:
-		dbg("FBIO_DEFAULT\n");
-		ret = -EINVAL;
-	}
-
-	return ret;
-}
-
-/*
- * Framebuffer operations structure.
- */
-static struct fb_ops xylonfb_ops = {
-	.owner = THIS_MODULE,
-	.fb_open = xylonfb_open,
-	.fb_release = xylonfb_release,
-	.fb_check_var = xylonfb_check_var,
-	.fb_set_par = xylonfb_set_par,
-	.fb_setcolreg = xylonfb_set_color_reg,
-	.fb_setcmap = xylonfb_set_cmap,
-	.fb_blank = xylonfb_blank,
-	.fb_pan_display = xylonfb_pan_display,
-	.fb_fillrect = cfb_fillrect,
-	.fb_copyarea = cfb_copyarea,
-	.fb_imageblit = cfb_imageblit,
-	.fb_cursor = NULL,
-	.fb_rotate = NULL,
-	.fb_sync = NULL,
-	.fb_ioctl = xylonfb_ioctl,
-	.fb_mmap = NULL,
-	.fb_get_caps = NULL,
-	.fb_destroy = NULL,
-};
-
-
-static inline void set_ctrl_reg(unsigned long pix_data_invert,
-	unsigned long pix_clk_act_edge)
-{
-	u32 sync = xylonfb_vmode.fb_vmode.sync;
-	u32 ctrl = CTRL_REG_INIT;
-
-	if (sync & (1<<0)) {	//FB_SYNC_HOR_HIGH_ACT
-		ctrl &= (~(1<<1));
-	}
-	if (sync & (1<<1)) {	// FB_SYNC_VERT_HIGH_ACT
-		ctrl &= (~(1<<3));
-	}
-	if (pix_data_invert) {
-		ctrl |= (1<<7);
-	}
-	if (pix_clk_act_edge) {
-		ctrl |= (1<<8);
-	}
-
-	xylonfb_vmode.ctrl_reg = ctrl;
-}
-
-#ifdef FB_XYLON_CONFIG_OF
-static int xylonfb_parse_vram_info(struct platform_device *pdev,
-	unsigned long *vmem_base_addr, unsigned long *vmem_high_addr)
-{
-	u32 const *prop;
-	int size;
-
-	dbg("%s\n", __func__);
-
-	prop =
-		of_get_property(pdev->dev.of_node, "vmem-baseaddr", &size);
-	if (!prop) {
-		printk(KERN_ERR "Error xylonfb getting VRAM address begin\n");
-		return -EINVAL;
-	}
-	*vmem_base_addr = be32_to_cpup(prop);
-
-	prop =
-		of_get_property(pdev->dev.of_node, "vmem-highaddr", &size);
-	if (!prop) {
-		printk(KERN_ERR "Error xylonfb getting VRAM address end\n");
-		return -EINVAL;
-	}
-	*vmem_high_addr = be32_to_cpup(prop);
-
-	return 0;
-}
-
-static int xylonfb_parse_layer_info(struct platform_device *pdev,
-	int *layers)
-{
-	u32 const *prop;
-	int size;
-
-	dbg("%s\n", __func__);
-
-	prop = of_get_property(pdev->dev.of_node, "num-of-layers", &size);
-	if (!prop) {
-		printk(KERN_ERR "Error getting number of layers\n");
-		return -EINVAL;
-	}
-	*layers = be32_to_cpup(prop);
-
-	prop = of_get_property(pdev->dev.of_node, "use-background", &size);
-	if (!prop) {
-		printk(KERN_ERR "Error getting use background\n");
-		return -EINVAL;
-	}
-	/* if background layer is present decrease number of layers */
-	if (be32_to_cpup(prop) == 1)
-		(*layers)--;
-	else
-		dbg("xylonfb no BG layer\n");
-
-	return 0;
-}
-
-static int xylonfb_parse_vmode_info(struct platform_device *pdev,
-	int *active_layer)
-{
-	struct device_node *dn, *vmode_dn;
-	u32 const *prop;
-	unsigned long pix_data_invert, pix_clk_act_edge;
-	int i, size, vmode_id;
-
-	dbg("%s\n", __func__);
-
-	*active_layer = 0;
-
-	dn = of_find_node_by_name(NULL, "xylon-videomode-params");
-	if (dn == NULL) {
-		printk(KERN_ERR "Error getting video mode parameters\n");
-		return -1;
-	}
-
-	pix_data_invert = 0;
-	prop = of_get_property(dn, "pixel-data-invert", &size);
-	if (!prop)
-		printk(KERN_ERR "Error getting pixel data invert\n");
-	else
-		pix_data_invert = be32_to_cpup(prop);
-	pix_clk_act_edge = 0;
-	prop = of_get_property(dn, "pixel-clock-active-edge", &size);
-	if (!prop)
-		printk(KERN_ERR "Error getting pixel active edge\n");
-	else
-		pix_clk_act_edge = be32_to_cpup(prop);
-
-	prop = of_get_property(dn, "default-active-layer-idx", &size);
-	if (prop)
-		*active_layer = be32_to_cpup(prop);
-	else
-		printk(KERN_INFO "xylonfb setting default layer to %d\n",
-			*active_layer);
-
-	prop = of_get_property(dn, "default-videomode-idx", &size);
-	if (prop)
-		vmode_id = be32_to_cpup(prop);
-	else {
-		vmode_id = 0;
-		printk(KERN_INFO "xylonfb setting default video mode to %d\n",
-			vmode_id);
-	}
-	for (i = 0, vmode_dn = NULL; i <= vmode_id; i++)
-		vmode_dn = of_get_next_child(dn, vmode_dn);
-
-	prop = of_get_property(vmode_dn, "mode-name", &size);
-	if (!prop)
-		printk(KERN_ERR "Error getting video mode name\n");
-	else
-		strcpy(xylonfb_vmode.name, (char *)prop);
-
-	prop = of_get_property(vmode_dn, "refresh", &size);
-	if (!prop)
-		printk(KERN_ERR "Error getting refresh rate\n");
-	else
-		xylonfb_vmode.fb_vmode.refresh = be32_to_cpup(prop);
-
-	prop = of_get_property(vmode_dn, "xres", &size);
-	if (!prop)
-		printk(KERN_ERR "Error getting xres\n");
-	else
-		xylonfb_vmode.fb_vmode.xres = be32_to_cpup(prop);
-
-	prop = of_get_property(vmode_dn, "yres", &size);
-	if (!prop)
-		printk(KERN_ERR "Error getting yres\n");
-	else
-		xylonfb_vmode.fb_vmode.yres = be32_to_cpup(prop);
-
-	prop = of_get_property(vmode_dn, "pixclock-khz", &size);
-	if (!prop)
-		printk(KERN_ERR "Error getting pixclock-khz\n");
-	else
-		xylonfb_vmode.fb_vmode.pixclock = KHZ2PICOS(be32_to_cpup(prop));
-
-	prop = of_get_property(vmode_dn, "left-margin", &size);
-	if (!prop)
-		printk(KERN_ERR "Error getting left-margin\n");
-	else
-		xylonfb_vmode.fb_vmode.left_margin = be32_to_cpup(prop);
-
-	prop = of_get_property(vmode_dn, "right-margin", &size);
-	if (!prop)
-		printk(KERN_ERR "Error getting right-margin\n");
-	else
-		xylonfb_vmode.fb_vmode.right_margin = be32_to_cpup(prop);
-
-	prop = of_get_property(vmode_dn, "upper-margin", &size);
-	if (!prop)
-		printk(KERN_ERR "Error getting upper-margin\n");
-	else
-		xylonfb_vmode.fb_vmode.upper_margin = be32_to_cpup(prop);
-
-	prop = of_get_property(vmode_dn, "lower-margin", &size);
-	if (!prop)
-		printk(KERN_ERR "Error getting lower-margin\n");
-	else
-		xylonfb_vmode.fb_vmode.lower_margin = be32_to_cpup(prop);
-
-	prop = of_get_property(vmode_dn, "hsync-len", &size);
-	if (!prop)
-		printk(KERN_ERR "Error getting hsync-len\n");
-	else
-		xylonfb_vmode.fb_vmode.hsync_len = be32_to_cpup(prop);
-
-	prop = of_get_property(vmode_dn, "vsync-len", &size);
-	if (!prop)
-		printk(KERN_ERR "Error getting vsync-len\n");
-	else
-		xylonfb_vmode.fb_vmode.vsync_len = be32_to_cpup(prop);
-
-	prop = of_get_property(vmode_dn, "sync", &size);
-	if (!prop)
-		printk(KERN_ERR "Error getting sync\n");
-	else
-		xylonfb_vmode.fb_vmode.sync = be32_to_cpup(prop);
-
-	prop = of_get_property(vmode_dn, "vmode", &size);
-	if (!prop)
-		printk(KERN_ERR "Error getting vmode\n");
-	else
-		xylonfb_vmode.fb_vmode.vmode = be32_to_cpup(prop);
-
-	set_ctrl_reg(pix_data_invert, pix_clk_act_edge);
-
-	return 0;
-}
-
-static int xylonfb_parse_layer_params(struct platform_device *pdev,
-	int id, struct layer_fix_data *lfdata)
-{
-	u32 const *prop;
-	int size;
-	char layer_property_name[25];
-
-	dbg("%s\n", __func__);
-
-	sprintf(layer_property_name, "layer-%d-offset", id);
-	prop = of_get_property(pdev->dev.of_node, layer_property_name, &size);
-	if (!prop) {
-		printk(KERN_ERR "Error getting layer offset\n");
-		return -EINVAL;
-	} else {
-		lfdata->offset = be32_to_cpup(prop);
-	}
-
-	prop = of_get_property(pdev->dev.of_node, "row-stride", &size);
-	if (!prop)
-		lfdata->width = 1024;
-	else
-		lfdata->width = be32_to_cpup(prop);
-
-	sprintf(layer_property_name, "layer-%d-alpha-mode", id);
-	prop = of_get_property(pdev->dev.of_node, layer_property_name, &size);
-	if (!prop) {
-		printk(KERN_ERR "Error getting layer alpha mode\n");
-		return -EINVAL;
-	} else {
-		lfdata->alpha_mode = be32_to_cpup(prop);
-	}
-
-	sprintf(layer_property_name, "layer-%d-data-width", id);
-	prop = of_get_property(pdev->dev.of_node, layer_property_name, &size);
-	if (!prop)
-		lfdata->bpp = 16;
-	else
-		lfdata->bpp = be32_to_cpup(prop);
-	if (lfdata->bpp == 24)
-		lfdata->bpp = 32;
-
-	lfdata->bpp_virt = lfdata->bpp;
-
-	switch (lfdata->bpp) {
-		case 8:
-			if (lfdata->alpha_mode == LOGICVC_PIXEL_ALPHA)
-				lfdata->bpp = 16;
-			break;
-		case 16:
-			if (lfdata->alpha_mode == LOGICVC_PIXEL_ALPHA)
-				lfdata->bpp = 32;
-			break;
-	}
-
-	return 0;
-}
-#endif
-
-static int xylonfb_find_next_layer(struct layer_fix_data *lfdata,
-	int layers, int curr)
-{
-	u32 address, temp_address, loop_address;
-	int i, next;
-
-	dbg("%s\n", __func__);
-
-	address = lfdata[curr].offset * lfdata[curr].width * lfdata[curr].bpp;
-	temp_address = 0xFFFFFFFF;
-	next = -1;
-
-	for (i = 0; i < layers; i++) {
-		loop_address = lfdata[i].offset * lfdata[i].width * lfdata[i].bpp;
-		if (address < loop_address
-				&&
-			loop_address < temp_address) {
-			next = i;
-			temp_address = loop_address;
-		}
-	}
-
-	return next;
-}
-
-static void xylonfb_set_yvirt(struct layer_fix_data *lfdata,
-	unsigned long vmem_base_addr, unsigned long vmem_high_addr,
-	int layers, int curr)
-{
-	int next;
-
-	dbg("%s\n", __func__);
-
-	next = xylonfb_find_next_layer(lfdata, layers, curr);
-
-	if (next != -1) {
-		lfdata[curr].height =
-			((lfdata[next].width * (lfdata[next].bpp/8) *
-			lfdata[next].offset)
-				-
-			(lfdata[curr].width * (lfdata[curr].bpp/8) *
-			lfdata[curr].offset)) /
-			(lfdata[curr].width * (lfdata[curr].bpp/8));
-	} else { /* last physical logiCVC layer */
-		/* FIXME - this is set for 1920x1080 tripple buffering,
-			but it should be read from dt parameters */
-		lfdata[curr].height = 3240;
-		while (1) {
-			if (((lfdata[curr].width * (lfdata[curr].bpp/8) *
-				lfdata[curr].height)
-					+
-				(lfdata[curr].width * (lfdata[curr].bpp/8) *
-				lfdata[curr].offset))
-					<=
-				(vmem_high_addr - vmem_base_addr))
-				break;
-			lfdata[curr].height -= 64; /* FIXME - magic number? */
-		}
-	}
-}
-
-static int xylonfb_map(int id, int layers, struct device *dev,
-	struct xylonfb_layer_data *layer_data, struct layer_fix_data *lfdata,
-	unsigned long vmem_base_addr, u32 reg_base_phys, void *reg_base_virt)
-{
-	dbg("%s\n", __func__);
-
-	/* logiCVC register mapping */
-	layer_data->reg_base_phys = reg_base_phys;
-	layer_data->reg_base_virt = reg_base_virt;
-	/* Video memory mapping */
-	layer_data->fb_phys = vmem_base_addr +
-		(lfdata->width * (lfdata->bpp/8) * lfdata->offset);
-	layer_data->fb_size =
-		lfdata->width * (lfdata->bpp/8) * lfdata->height;
-
-	if (layer_data->xylonfb_cd->xylonfb_flags & FB_DMA_BUFFER) {
-		/* NOT USED FOR NOW! */
-		layer_data->fb_virt = dma_alloc_writecombine(dev,
-			PAGE_ALIGN(layer_data->fb_size),
-			&layer_data->fb_phys, GFP_KERNEL);
-	} else {
-		layer_data->fb_virt =
-			ioremap_wc(layer_data->fb_phys, layer_data->fb_size);
-	}
-	/* check memory mappings */
-	if (!layer_data->reg_base_virt || !layer_data->fb_virt) {
-		printk(KERN_ERR "Error xylonfb ioremap REGS 0x%X FB 0x%X\n",
-			(unsigned int)layer_data->reg_base_virt,
-			(unsigned int)layer_data->fb_virt);
-		return -ENOMEM;
-	}
-	//memset_io((void __iomem *)layer_data->fb_virt, 0, layer_data->fb_size);
-	layer_data->layer_reg_base_virt =
-		layer_data->reg_base_virt + logicvc_layer_reg_offset[id];
-	layer_data->layer_clut_base_virt =
-		layer_data->reg_base_virt + logicvc_clut_reg_offset[id];
-	layer_data->layer_use_ref = 0;
-	layer_data->layer_info = id;
-	layer_data->layers = layers;
-
-	return 0;
-}
-
-static inline void xylonfb_set_drv_vmode(void)
-{
-	dbg("%s\n", __func__);
-
-	drv_vmode.xres = xylonfb_vmode.fb_vmode.xres;
-	drv_vmode.yres = xylonfb_vmode.fb_vmode.yres;
-	drv_vmode.pixclock = xylonfb_vmode.fb_vmode.pixclock;
-	drv_vmode.left_margin = xylonfb_vmode.fb_vmode.left_margin;
-	drv_vmode.right_margin = xylonfb_vmode.fb_vmode.right_margin;
-	drv_vmode.upper_margin = xylonfb_vmode.fb_vmode.upper_margin;
-	drv_vmode.lower_margin = xylonfb_vmode.fb_vmode.lower_margin;
-	drv_vmode.hsync_len = xylonfb_vmode.fb_vmode.hsync_len;
-	drv_vmode.vsync_len = xylonfb_vmode.fb_vmode.vsync_len;
-	drv_vmode.vmode = xylonfb_vmode.fb_vmode.vmode;
-}
-
-static inline void xylonfb_set_fbi_timings(struct fb_var_screeninfo *var)
-{
-	dbg("%s\n", __func__);
-
-	var->xres = drv_vmode.xres;
-	var->yres = drv_vmode.yres;
-	var->pixclock = drv_vmode.pixclock;
-	var->left_margin = drv_vmode.left_margin;
-	var->right_margin = drv_vmode.right_margin;
-	var->upper_margin = drv_vmode.upper_margin;
-	var->lower_margin = drv_vmode.lower_margin;
-	var->hsync_len = drv_vmode.hsync_len;
-	var->vsync_len = drv_vmode.vsync_len;
-	var->sync = drv_vmode.sync;
-	var->vmode = drv_vmode.vmode;
-}
-
-static inline void xylonfb_set_hw_specifics(struct fb_info *fbi,
-	struct xylonfb_layer_data *layer_data, struct layer_fix_data *lfdata,
-	u32 reg_base_phys)
-{
-	dbg("%s\n", __func__);
-
-	fbi->fix.smem_start = layer_data->fb_phys;
-	fbi->fix.smem_len = layer_data->fb_size;
-	fbi->fix.type = FB_TYPE_PACKED_PIXELS;
-	if ((lfdata->bpp == 8) &&
-		((lfdata->alpha_mode == LOGICVC_CLUT_16BPP_ALPHA) ||
-		(lfdata->alpha_mode == LOGICVC_CLUT_32BPP_ALPHA)))
-		fbi->fix.visual = FB_VISUAL_PSEUDOCOLOR;
-	else
-		/*
-			Other logiCVC layer pixel formats:
-			- 8 bpp: LAYER or PIXEL alpha
-			  It is not true color, RGB triplet is stored in 8 bits.
-			- 16 bpp:
-			  LAYER alpha: RGB triplet is stored in 16 bits
-			  PIXEL alpha: ARGB quadriplet is stored in 32 bits
-			- 32 bpp: LAYER or PIXEL alpha
-			  True color, RGB triplet or ARGB quadriplet is stored in 32 bits.
-		*/
-		fbi->fix.visual = FB_VISUAL_TRUECOLOR;
-	fbi->fix.xpanstep = 1;
-	fbi->fix.ypanstep = 1;
-	fbi->fix.ywrapstep = LOGICVC_MAX_VRES;
-	fbi->fix.line_length = lfdata->width * (lfdata->bpp/8);
-	fbi->fix.mmio_start = reg_base_phys;
-	fbi->fix.mmio_len = LOGICVC_REGISTERS_RANGE;
-	fbi->fix.accel = FB_ACCEL_NONE;
-
-	fbi->var.xres_virtual = lfdata->width;
-	if (lfdata->height <= LOGICVC_MAX_VRES)
-		fbi->var.yres_virtual = lfdata->height;
-	else
-		fbi->var.yres_virtual = LOGICVC_MAX_VRES;
-	fbi->var.bits_per_pixel = lfdata->bpp;
-
-	/*	Set values according to logiCVC layer data width configuration:
-		- layer data width can be 1, 2, 4 bytes
-		- layer data width for 16 bpp can be 2 or 4 bytes */
-	if (lfdata->alpha_mode == LOGICVC_LAYER_ALPHA) {
-		fbi->var.transp.offset = 0;
-		fbi->var.transp.length = 0;
-	}
-	switch (lfdata->bpp_virt) {
-		case 8:
-			switch (lfdata->alpha_mode) {
-				case LOGICVC_PIXEL_ALPHA:
-					fbi->var.transp.offset = 8;
-					fbi->var.transp.length = 3;
-
-				case LOGICVC_LAYER_ALPHA:
-					fbi->var.red.offset = 5;
-					fbi->var.red.length = 3;
-					fbi->var.green.offset = 2;
-					fbi->var.green.length = 3;
-					fbi->var.blue.offset = 0;
-					fbi->var.blue.length = 2;
-					break;
-
-				case LOGICVC_CLUT_16BPP_ALPHA:
-					fbi->var.transp.offset = 24;
-					fbi->var.transp.length = 6;
-					fbi->var.red.offset = 19;
-					fbi->var.red.length = 5;
-					fbi->var.green.offset = 10;
-					fbi->var.green.length = 6;
-					fbi->var.blue.offset = 3;
-					fbi->var.blue.length = 5;
-					break;
-
-				case LOGICVC_CLUT_32BPP_ALPHA:
-					fbi->var.transp.offset = 24;
-					fbi->var.transp.length = 8;
-					fbi->var.red.offset = 16;
-					fbi->var.red.length = 8;
-					fbi->var.green.offset = 8;
-					fbi->var.green.length = 8;
-					fbi->var.blue.offset = 0;
-					fbi->var.blue.length = 8;
-					break;
-			}
-			break;
-		case 16:
-			switch (lfdata->alpha_mode) {
-				case LOGICVC_PIXEL_ALPHA:
-					fbi->var.transp.offset = 24;
-					fbi->var.transp.length = 6;
-
-				case LOGICVC_LAYER_ALPHA:
-					fbi->var.red.offset = 11;
-					fbi->var.red.length = 5;
-					fbi->var.green.offset = 5;
-					fbi->var.green.length = 6;
-					fbi->var.blue.offset = 0;
-					fbi->var.blue.length = 5;
-					break;
-			}
-			break;
-		case 32:
-			switch (lfdata->alpha_mode) {
-				case LOGICVC_PIXEL_ALPHA:
-					fbi->var.transp.offset = 24;
-					fbi->var.transp.length = 8;
-
-				case LOGICVC_LAYER_ALPHA:
-					fbi->var.red.offset = 16;
-					fbi->var.red.length = 8;
-					fbi->var.green.offset = 8;
-					fbi->var.green.length = 8;
-					fbi->var.blue.offset = 0;
-					fbi->var.blue.length = 8;
-					break;
-			}
-			break;
-	}
-	fbi->var.transp.msb_right = 0;
-	fbi->var.red.msb_right = 0;
-	fbi->var.green.msb_right = 0;
-	fbi->var.blue.msb_right = 0;
-	fbi->var.activate = FB_ACTIVATE_NOW;
-	fbi->var.height = 0;
-	fbi->var.width = 0;
-	fbi->var.sync = 0;
-	fbi->var.rotate = 0;
-}
-
-static int xylonfb_set_timings(struct fb_info *fbi,
-	int bpp, bool change_res)
-{
-	struct fb_var_screeninfo fb_var;
-	int rc;
-	bool set = 0;
-
-	dbg("%s\n", __func__);
-
-	if (change_res)
-		if (!pixclk_change(fbi))
-			return 0;
-
-	rc = fb_find_mode(&fb_var, fbi, mode_option, NULL, 0,
-		&xylonfb_vmode.fb_vmode, bpp);
-	switch (rc) {
-		case 0:
-			printk(KERN_ERR "Error xylonfb video mode option\n"
-				"using driver default mode %s\n", xylonfb_vmode.name);
-			break;
-
-		case 1 ... 4:
-			if (rc == 1) {
-				dbg("xylonfb using video mode option %s\n",
-					mode_option);
-					set = 1;
-			}
-			else if (rc == 2) {
-				printk(KERN_INFO "xylonfb using video mode option, "
-					"with ignored refresh rate %s\n", mode_option);
-					set = 1;
-			}
-			else if (rc == 3) {
-				printk(KERN_INFO "xylonfb using default video mode %s\n",
-					xylonfb_vmode.name);
-				if (!change_res)
-					set = 1;
-			}
-			else if (rc == 4) {
-				printk(KERN_INFO "xylonfb video mode fallback\n");
-				if (!change_res)
-					set = 1;
-			}
-
-			if (set) {
-				dbg("set!\n");
-				drv_vmode.xres = fb_var.xres;
-				drv_vmode.yres = fb_var.yres;
-				drv_vmode.pixclock = fb_var.pixclock;
-				drv_vmode.left_margin = fb_var.left_margin;
-				drv_vmode.right_margin = fb_var.right_margin;
-				drv_vmode.upper_margin = fb_var.upper_margin;
-				drv_vmode.lower_margin = fb_var.lower_margin;
-				drv_vmode.hsync_len = fb_var.hsync_len;
-				drv_vmode.vsync_len = fb_var.vsync_len;
-				drv_vmode.sync = fb_var.sync;
-				drv_vmode.vmode = fb_var.vmode;
-			}
-
-			break;
-	}
-
-	return rc;
-}
-
-static int xylonfb_register_fb(struct fb_info *fbi,
-	struct xylonfb_layer_data *layer_data, struct layer_fix_data *lfdata,
-	u32 reg_base_phys, int id, int *regfb)
-{
-	int alpha;
-	dbg("%s\n", __func__);
-
-	fbi->flags = FBINFO_DEFAULT;
-	fbi->screen_base = (char __iomem *)layer_data->fb_virt;
-	fbi->screen_size = layer_data->fb_size;
-	fbi->pseudo_palette = kzalloc(sizeof(u32) * XYLONFB_PSEUDO_PALETTE_SZ,
-		GFP_KERNEL);
-	fbi->fbops = &xylonfb_ops;
-
-	sprintf(fbi->fix.id, "Xylon FB%d", id);
-	xylonfb_set_hw_specifics(fbi, layer_data, lfdata, reg_base_phys);
-
-	/* if mode_option is set, find mode will be done only once */
-	if (mode_option) {
-		xylonfb_set_timings(fbi, lfdata->bpp, RES_CHANGE_DENIED);
-		mode_option = NULL;
-	}
-
-	xylonfb_set_fbi_timings(&fbi->var);
-
-	if (lfdata->alpha_mode == LOGICVC_LAYER_ALPHA)
-		alpha = 0;
-	else
-		alpha = 1;
-	if (fb_alloc_cmap(&fbi->cmap, 256, alpha))
-		return -ENOMEM;
-
-	*regfb = register_framebuffer(fbi);
-	if (*regfb) {
-		printk(KERN_ERR "Error xylonfb registering xylonfb %d\n", id);
-		return -EINVAL;
-	}
-	printk(KERN_INFO "xylonfb %d registered\n", id);
-	/* after driver registration values in struct fb_info
-		must not be changed anywhere else except in xylonfb_set_par */
-
-	return 0;
-}
-
-static void xylonfb_logicvc_disp_ctrl(struct fb_info *fbi)
-{
-	struct xylonfb_layer_data *layer_data = fbi->par;
-	struct xylonfb_common_data *common_data =
-		layer_data->xylonfb_cd;
-	u32 val;
-
-	dbg("%s\n", __func__);
-
-	val = LOGICVC_EN_VDD_MSK;
-	writel(val, layer_data->reg_base_virt + LOGICVC_SPWRCTRL_ROFF);
-	mdelay(common_data->power_on_delay);
-	val |= LOGICVC_V_EN_MSK;
-	writel(val, layer_data->reg_base_virt + LOGICVC_SPWRCTRL_ROFF);
-	mdelay(common_data->signal_on_delay);
-	val |= LOGICVC_EN_BLIGHT_MSK;
-	writel(val, layer_data->reg_base_virt + LOGICVC_SPWRCTRL_ROFF);
-}
-
-static void xylonfb_start_logicvc(struct fb_info *fbi)
-{
-	struct xylonfb_layer_data *layer_data = fbi->par;
-
-	dbg("%s\n", __func__);
-
-	writel(fbi->var.right_margin-1,
-		layer_data->reg_base_virt + LOGICVC_SHSY_FP_ROFF);
-	writel(fbi->var.hsync_len-1,
-		layer_data->reg_base_virt + LOGICVC_SHSY_ROFF);
-	writel(fbi->var.left_margin-1,
-		layer_data->reg_base_virt + LOGICVC_SHSY_BP_ROFF);
-	writel(fbi->var.xres-1,
-		layer_data->reg_base_virt + LOGICVC_SHSY_RES_ROFF);
-	writel(fbi->var.lower_margin-1,
-		layer_data->reg_base_virt + LOGICVC_SVSY_FP_ROFF);
-	writel(fbi->var.vsync_len-1,
-		layer_data->reg_base_virt + LOGICVC_SVSY_ROFF);
-	writel(fbi->var.upper_margin-1,
-		layer_data->reg_base_virt + LOGICVC_SVSY_BP_ROFF);
-	writel(fbi->var.yres-1,
-		layer_data->reg_base_virt + LOGICVC_SVSY_RES_ROFF);
-	writel(xylonfb_vmode.ctrl_reg,
-		layer_data->reg_base_virt + LOGICVC_SCTRL_ROFF);
-	writel(SD_REG_INIT, layer_data->reg_base_virt + LOGICVC_SDTYPE_ROFF);
-	writel(BACKGROUND_COLOR, layer_data->reg_base_virt + LOGICVC_BACKCOL_ROFF);
-//	writel(0x00, layer_data->reg_base_virt + LOGICVC_DOUBLE_VBUFF_ROFF);
-//	writel(0x00, layer_data->reg_base_virt + LOGICVC_DOUBLE_CLUT_ROFF);
-	writel(0xFFFF, layer_data->reg_base_virt + LOGICVC_INT_ROFF);
-	writel(0xFFFF, layer_data->reg_base_virt + LOGICVC_INT_MASK_ROFF);
-	writel(TRANSPARENT_COLOR_24BPP,
-		(layer_data->layer_reg_base_virt + LOGICVC_LAYER_TRANSP_ROFF));
-
-	dbg("\n");
-	dbg("logiCVC HW parameters:\n");
-	dbg("    Horizontal Front Porch: %d pixclks\n",
-		fbi->var.right_margin);
-	dbg("    Horizontal Sync:        %d pixclks\n",
-		fbi->var.hsync_len);
-	dbg("    Horizontal Back Porch:  %d pixclks\n",
-		fbi->var.left_margin);
-	dbg("    Vertical Front Porch:   %d pixclks\n",
-		fbi->var.lower_margin);
-	dbg("    Vertical Sync:          %d pixclks\n",
-		fbi->var.vsync_len);
-	dbg("    Vertical Back Porch:    %d pixclks\n",
-		fbi->var.upper_margin);
-	dbg("    Pixel Clock (ps):       %d\n",
-		fbi->var.pixclock);
-	dbg("    Bits per Pixel:         %d\n",
-		fbi->var.bits_per_pixel);
-	dbg("    Horizontal Res:         %d\n",
-		fbi->var.xres);
-	dbg("    Vertical Res:           %d\n",
-		fbi->var.yres);
-	dbg("\n");
-}
-
-static void xylonfb_stop_logicvc(struct fb_info *fbi)
-{
-	struct xylonfb_layer_data *layer_data = fbi->par;
-
-	dbg("%s\n", __func__);
-
-	writel(0, layer_data->reg_base_virt + LOGICVC_SCTRL_ROFF);
-}
-
-static int xylonfb_start(struct fb_info **afbi, int layers)
-{
-	struct xylonfb_layer_data *layer_data;
-	int i;
-
-	dbg("%s\n", __func__);
-
-	if (xylonfb_set_pixelclock(afbi[0]))
-		return -EACCES;
-	/* start logiCVC and enable primary layer */
-	xylonfb_start_logicvc(afbi[0]);
-	/* display power control */
-	xylonfb_logicvc_disp_ctrl(afbi[0]);
-	/* turn OFF all layers except already used ones */
-	for (i = 0; i < layers; i++) {
-		layer_data = (struct xylonfb_layer_data *)afbi[i]->par;
-		if (layer_data->layer_info & LOGICVC_LAYER_ON)
-			continue;
-		/* turn off layer */
-		writel(0, (layer_data->layer_reg_base_virt + LOGICVC_LAYER_CTRL_ROFF));
-	}
-	/* print layer parameters */
-	for (i = 0; i < layers; i++) {
-		layer_data = (struct xylonfb_layer_data *)afbi[i]->par;
-		dbg("logiCVC layer %d\n", i);
-		dbg("    Registers Base Address:     0x%X\n",
-			(unsigned int)layer_data->reg_base_phys);
-		dbg("    Layer Video Memory Address: 0x%X\n",
-			(unsigned int)layer_data->fb_phys);
-		dbg("    X resolution:               %d\n",
-			afbi[i]->var.xres);
-		dbg("    Y resolution:               %d\n",
-			afbi[i]->var.yres);
-		dbg("    X resolution (virtual):     %d\n",
-			afbi[i]->var.xres_virtual);
-		dbg("    Y resolution (virtual):     %d\n",
-			afbi[i]->var.yres_virtual);
-		dbg("    Line length (bytes):        %d\n",
-			afbi[i]->fix.line_length);
-		dbg("    Bits per Pixel:             %d\n",
-			afbi[i]->var.bits_per_pixel);
-		dbg("\n");
-	}
-
-	return 0;
-}
-
-static int xylonfb_probe(struct platform_device *pdev)
-{
-	struct device *dev = &pdev->dev;
-	struct fb_info **afbi;
-	struct fb_info *fbi;
-	struct xylonfb_common_data *common_data;
-	struct xylonfb_layer_data *layer_data;
-	struct resource *reg_res, *irq_res;
-#ifndef FB_XYLON_CONFIG_OF
-	struct xylonfb_platform_data *pdata;
-#endif
-	struct layer_fix_data lfdata[LOGICVC_MAX_LAYERS];
-	void *reg_base_virt;
-	u32 reg_base_phys;
-	unsigned long vmem_base_addr, vmem_high_addr;
-	int reg_range, layers, active_layer;
-	int i, rc;
-	int regfb[LOGICVC_MAX_LAYERS];
-
-	dbg("%s\n", __func__);
-
-	reg_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	irq_res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
-	if ((!reg_res) || (!irq_res)) {
-		printk(KERN_ERR "Error xylonfb resources: MEM 0x%X IRQ 0x%X\n",
-			(unsigned int)reg_res, (unsigned int)irq_res);
-		return -ENODEV;
-	}
-
-#ifdef FB_XYLON_CONFIG_OF
-	rc = xylonfb_parse_vram_info(pdev, &vmem_base_addr, &vmem_high_addr);
-	if (rc)
-		return rc;
-	rc = xylonfb_parse_layer_info(pdev, &layers);
-	if (rc)
-		return rc;
-	if (xylonfb_parse_vmode_info(pdev, &active_layer) == 0) {
-		/* if DT contains video mode options do not use
-		   kernel command line video mode options */
-		mode_option = NULL;
-	}
-#else
-	pdata = (struct xylonfb_platform_data *)pdev->dev.platform_data;
-	vmem_base_addr = pdata->vmem_base_addr;
-	vmem_high_addr = pdata->vmem_high_addr;
-	layers = pdata->num_layers;
-	active_layer = pdata->active_layer;
-#endif
-	xylonfb_set_drv_vmode();
-
-#if CONFIG_FB_XYLON_NUM_FBS > 0
-	layers = CONFIG_FB_XYLON_NUM_FBS;
-#endif
-
-	afbi = kzalloc(sizeof(struct fb_info *) * layers, GFP_KERNEL);
-	common_data = kzalloc(sizeof(struct xylonfb_common_data), GFP_KERNEL);
-	if (!afbi || !common_data) {
-		printk(KERN_ERR "Error xylonfb allocating internal data\n");
-		rc = -ENOMEM;
-		goto err_mem;
-	}
-
-	layer_data = NULL;
-
-	reg_base_phys = reg_res->start;
-	reg_range = reg_res->end - reg_res->start;
-	reg_base_virt = ioremap_nocache(reg_base_phys, reg_range);
-
-	/* load layer parameters for all layers */
-	for (i = 0; i < layers; i++) {
-#ifdef FB_XYLON_CONFIG_OF
-		xylonfb_parse_layer_params(pdev, i, &lfdata[i]);
-#else
-		lfdata[i].offset = pdata->layer_params[i].offset;
-		lfdata[i].bpp = pdata->layer_params[i].bpp;
-		lfdata[i].width = pdata->row_stride;
-#endif
-		regfb[i] = -1;
-	}
-
-	/* make /dev/fb0 to be default active layer
-	   no matter how hw layers are organized */
-	for (i = active_layer; i < layers; i++) {
-		if (regfb[i] != -1)
-			continue;
-
-		fbi = framebuffer_alloc(sizeof(struct xylonfb_layer_data), dev);
-		if (!fbi) {
-			printk(KERN_ERR "Error xylonfb allocate info\n");
-			rc = -ENOMEM;
-			goto err_fb;
-		}
-		afbi[i] = fbi;
-		layer_data = fbi->par;
-		layer_data->xylonfb_cd = common_data;
-
-		xylonfb_set_yvirt(lfdata, vmem_base_addr, vmem_high_addr, layers, i);
-
-		layer_data->layer_fix = lfdata[i];
-
-		rc = xylonfb_map(i, layers, dev, layer_data, &lfdata[i],
-			vmem_base_addr, reg_base_phys, reg_base_virt);
-		if (rc)
-			goto err_fb;
-
-		rc = xylonfb_register_fb(fbi, layer_data, &lfdata[i],
-			reg_base_phys, i, &regfb[i]);
-		if (rc)
-			goto err_fb;
-
-		spin_lock_init(&layer_data->layer_lock);
-
-		/* register following layers in HW configuration order */
-		if (active_layer > 0) {
-			i = -1; /* after for loop increment i will be zero */
-			active_layer = -1;
-		}
-
-		dbg( \
-			"    Layer ID %d\n" \
-			"    Layer offset %d\n" \
-			"    Layer width %d pixels\n" \
-			"    Layer height %d lines\n" \
-			"    Layer bits per pixel %d\n" \
-			"    Layer bits per pixel (virtual) %d\n" \
-			"    Layer FB size %ld bytes\n", \
-			(layer_data->layer_info & 0x0F),
-			layer_data->layer_fix.offset,
-			layer_data->layer_fix.width,
-			layer_data->layer_fix.height,
-			layer_data->layer_fix.bpp,
-			layer_data->layer_fix.bpp_virt,
-			layer_data->fb_size);
-	}
-
-	common_data->xylonfb_irq = irq_res->start;
-	if (request_irq(common_data->xylonfb_irq, xylonfb_isr,
-			IRQF_TRIGGER_HIGH, PLATFORM_DRIVER_NAME, afbi)) {
-		common_data->xylonfb_irq = 0;
-		goto err_fb;
-	}
-
-#if defined(__LITTLE_ENDIAN)
-	common_data->xylonfb_flags |= FB_MEMORY_LE;
-#endif
-	mutex_init(&common_data->irq_mutex);
-	init_waitqueue_head(&common_data->xylonfb_vsync.wait);
-	common_data->xylonfb_use_ref = 0;
-
-	dev_set_drvdata(dev, (void *)afbi);
-
-	/* start HW */
-	rc = xylonfb_start(afbi, layers);
-	if (rc)
-		goto err_fb;
-
-	printk(KERN_INFO
-		"xylonfb video mode: %dx%d-%dbpp@60\n",
-		afbi[0]->var.xres, afbi[0]->var.yres, afbi[0]->var.bits_per_pixel);
-
-	return 0;
-
-err_fb:
-	if (common_data->xylonfb_irq != 0)
-		free_irq(common_data->xylonfb_irq, afbi);
-	if (layer_data->reg_base_virt)
-		iounmap(layer_data->reg_base_virt);
-	for (i = layers-1; i >= 0; i--) {
-		fbi = afbi[i];
-		if (!fbi)
-			continue;
-		layer_data = fbi->par;
-		if (regfb[i] == 0)
-			unregister_framebuffer(fbi);
-		else
-			regfb[i] = 0;
-		if (fbi->cmap.red)
-			fb_dealloc_cmap(&fbi->cmap);
-		if (layer_data) {
-			if (common_data->xylonfb_flags & FB_DMA_BUFFER) {
-				/* NOT USED FOR NOW! */
-				dma_free_coherent(dev, PAGE_ALIGN(fbi->fix.smem_len),
-					layer_data->fb_virt, layer_data->fb_phys);
-			} else {
-				if (layer_data->fb_virt)
-					iounmap(layer_data->fb_virt);
-			}
-			kfree(fbi->pseudo_palette);
-			framebuffer_release(fbi);
-		}
-	}
-
-err_mem:
-	if (common_data)
-		kfree(common_data);
-	if (afbi)
-		kfree(afbi);
-
-	dev_set_drvdata(dev, NULL);
-
-	return rc;
-}
-
-static int xylonfb_remove(struct platform_device *pdev)
-{
-	struct device *dev = &pdev->dev;
-	struct fb_info **afbi = (struct fb_info **)dev_get_drvdata(dev);
-	struct fb_info *fbi = afbi[0];
-	struct xylonfb_layer_data *layer_data = fbi->par;
-	struct xylonfb_common_data *common_data =
-		layer_data->xylonfb_cd;
-	int i;
-	bool logicvc_off;
-
-	dbg("%s\n", __func__);
-
-	if (common_data->xylonfb_use_ref) {
-		printk(KERN_ERR "Error xylonfb in use\n");
-		return -EINVAL;
-	}
-
-	logicvc_off = 0;
-
-	free_irq(common_data->xylonfb_irq, afbi);
-	for (i = layer_data->layers-1; i >= 0; i--) {
-		fbi = afbi[i];
-		layer_data = fbi->par;
-		if (!logicvc_off) {
-			xylonfb_stop_logicvc(fbi);
-			iounmap(layer_data->reg_base_virt);
-			logicvc_off = 1;
-		}
-		unregister_framebuffer(fbi);
-		fb_dealloc_cmap(&fbi->cmap);
-		if (common_data->xylonfb_flags & FB_DMA_BUFFER) {
-			dma_free_coherent(dev, PAGE_ALIGN(fbi->fix.smem_len),
-				layer_data->fb_virt, layer_data->fb_phys);
-		} else {
-			iounmap(layer_data->fb_virt);
-		}
-		kfree(fbi->pseudo_palette);
-		framebuffer_release(fbi);
-	}
-
-	kfree(common_data);
-	kfree(afbi);
-
-	dev_set_drvdata(dev, NULL);
-
-	return 0;
-}
-
-/* Match table for of_platform binding */
-#ifdef FB_XYLON_CONFIG_OF
-static struct of_device_id xylonfb_of_match[] __devinitdata = {
-	{ .compatible = "xylon,logicvc-2.04.a" },
-	{ .compatible = "xylon,logicvc-2.05.b" },
-	{/* end of table */},
-};
-MODULE_DEVICE_TABLE(of, xylonfb_of_match);
-#else
-#define xylonfb_of_match NULL
-#endif
-
-static struct platform_driver xylonfb_driver = {
-	.probe = xylonfb_probe,
-	.remove = xylonfb_remove,
-	.driver = {
-		.owner = THIS_MODULE,
-		.name = PLATFORM_DRIVER_NAME,
-		.of_match_table = xylonfb_of_match,
-	},
-};
-
-
-#ifndef MODULE
-static int __init xylonfb_setup(char *options)
-{
-	char *this_opt;
-
-	dbg("%s\n", __func__);
-
-	if (!options || !*options)
-		return 0;
-
-	while ((this_opt = strsep(&options, ",")) != NULL) {
-		if (!*this_opt)
-			continue;
-		mode_option = this_opt;
-	}
-	return 0;
-}
-#endif
-
-static int __init xylonfb_init(void)
-{
-#ifndef MODULE
-	char *option = NULL;
-
-	dbg("%s\n", __func__);
-
-	/*
-	 *  For kernel boot options (in 'video=xxxfb:<options>' format)
-	 */
-	if (fb_get_options(DRIVER_NAME, &option))
-		return -ENODEV;
-	/* Set internal module parameters */
-	xylonfb_setup(option);
-#endif
-
-	if (platform_driver_register(&xylonfb_driver)) {
-		printk(KERN_ERR "Error xylonfb driver registration\n");
-		return -ENODEV;
-	}
-
-	return 0;
-}
-
-static void __exit xylonfb_exit(void)
-{
-	dbg("%s\n", __func__);
-
-	platform_driver_unregister(&xylonfb_driver);
-}
-
-
-#ifndef MODULE
-late_initcall(xylonfb_init);
-#else
-module_init(xylonfb_init);
-module_exit(xylonfb_exit);
-#endif
-
-MODULE_LICENSE("Dual BSD/GPL");
-MODULE_DESCRIPTION(DRIVER_DESCRIPTION);
diff -uNr linux-xlnx//drivers/video/xylon/xylonfb/xylonfb-pixclk.c linux-xlnx_xfb_14.1_build3//drivers/video/xylon/xylonfb/xylonfb-pixclk.c
--- linux-xlnx//drivers/video/xylon/xylonfb/xylonfb-pixclk.c	2012-05-15 03:09:09.000000000 +0200
+++ linux-xlnx_xfb_14.1_build3//drivers/video/xylon/xylonfb/xylonfb-pixclk.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,164 +0,0 @@
-/*
- * Xylon logiCVC frame buffer driver pixel clock generation
- *
- * Author: Xylon d.o.o.
- * e-mail: davor.joja@logicbricks.com
- *
- * 2012 (c) Xylon d.o.o.
- *
- * This file is licensed under the terms of the GNU General Public License
- * version 2.  This program is licensed "as is" without any warranty of any
- * kind, whether express or implied.
- */
-
-
-/*
- * This file implements HW dependent functionality for controlling pixel clock
- * generation on various HW platforms.
- */
-
-
-#include <linux/fb.h>
-
-
-#define HW_PIXEL_CLOCK_CHANGE_SUPPORTED 1
-
-
-#if defined(CONFIG_FB_XYLON_TEST)
-
-#define HW_PIXEL_CLOCK_CHANGE_SUPPORTED 0
-int pixclk_set(struct fb_info *fbi)
-{
-	printk(KERN_INFO
-		"Changing of pixel clock for %s on platform TEST not supported\n",
-		fbi->fix.id);
-
-	return -EPERM;
-}
-
-#elif defined(CONFIG_FB_XYLON_ZYNQ_PS_PIXCLK)
-
-int pixclk_set(struct fb_info *fbi)
-{
-	unsigned long pllclk, sysclk, pixclk;
-	unsigned long div, delta, delta_dec, delta_inc;
-	void *slcr_regs, *clk_regs, *rst_reg;
-
-	/* all clock values are in kHz */
-	pllclk = 1000000;
-	sysclk = 100000;
-	pixclk = PICOS2KHZ(fbi->var.pixclock);
-
-	slcr_regs = ioremap_nocache(0xF8000004, 8);
-	if (!slcr_regs) {
-		printk(KERN_ERR
-			"Error mapping SLCR\n");
-		return -EBUSY;
-	}
-	clk_regs = ioremap_nocache(0xF8000170, 32);
-	if (!clk_regs) {
-		printk(KERN_ERR
-			"Error setting xylonfb pixelclock\n");
-		iounmap(slcr_regs);
-		return -EBUSY;
-	}
-	rst_reg = ioremap_nocache(0xF8000240, 4);
-	if (!rst_reg) {
-		printk(KERN_ERR
-			"Error setting xylonfb pixelclock\n");
-		iounmap(clk_regs);
-		iounmap(slcr_regs);
-		return -EBUSY;
-	}
-
-	/* unlock register access */
-	writel(0xDF0D, (slcr_regs+4));
-//	/* calculate system clock divisor */
-//	div = pllclk / sysclk;
-//	/* prepare for register writting */
-//	div = (div + 0x1000) << 8;
-//	/* set system clock */
-//	writel(div, clk_regs);
-	/* calculate video clock divisor */
-	div = pllclk / pixclk;
-	delta = (pllclk / div) - pixclk;
-	if (delta != 0) {
-		delta_inc = pixclk - (pllclk / (div+1));
-		delta_dec = (pllclk / (div-1)) - pixclk;
-		if (delta < delta_inc) {
-			if (delta > delta_dec)
-				div--;
-			//else
-			//	div = div;
-		} else {
-			if (delta > delta_dec) {
-				if (delta_inc > delta_dec)
-					div--;
-				else
-					div++;
-			} else {
-				div++;
-			}
-		}
-	}
-	/* prepare for register writting */
-	div = (div + 0x1000) << 8;
-	/* set video clock */
-	writel(div, (clk_regs+0x10));
-//	/* reset FPGA */
-//	writel(0, rst_reg);
-//	writel(0x1, rst_reg);
-//	writel(0, rst_reg);
-	/* lock register access */
-	writel(0x767B, slcr_regs);
-
-	iounmap(rst_reg);
-	iounmap(clk_regs);
-	iounmap(slcr_regs);
-
-	return 0;
-}
-
-#elif defined(CONFIG_FB_XYLON_ZC702_PIXCLK)
-
-#include <linux/i2c/si570.h>
-
-int pixclk_set(struct fb_info *fbi)
-{
-	struct i2c_client *si570_client;
-	unsigned long pixclk;
-
-	pixclk = PICOS2KHZ(fbi->var.pixclock) * 1000;
-
-	si570_client = get_i2c_client_si570();
-	if (si570_client)
-		return set_frequency_si570(&si570_client->dev, pixclk);
-	else
-		return -EPERM;
-}
-
-#else
-
-#if defined (HW_PIXEL_CLOCK_CHANGE_SUPPORTED)
-#undef HW_PIXEL_CLOCK_CHANGE_SUPPORTED
-#endif
-#define HW_PIXEL_CLOCK_CHANGE_SUPPORTED 0
-int pixclk_set(struct fb_info *fbi)
-{
-	printk(KERN_INFO "Changing of pixel clock for %s not supported\n",
-		fbi->fix.id);
-
-	return -EPERM;
-}
-
-#endif
-
-
-inline int pixclk_change(struct fb_info *fbi)
-{
-#if HW_PIXEL_CLOCK_CHANGE_SUPPORTED == 0
-	return 0;
-#elif HW_PIXEL_CLOCK_CHANGE_SUPPORTED == 1
-	return 1;
-#endif
-}
diff -uNr linux-xlnx//drivers/video/xylon/xylonfb/xylonfb-pixclk.h linux-xlnx_xfb_14.1_build3//drivers/video/xylon/xylonfb/xylonfb-pixclk.h
--- linux-xlnx//drivers/video/xylon/xylonfb/xylonfb-pixclk.h	2012-05-15 03:09:09.000000000 +0200
+++ linux-xlnx_xfb_14.1_build3//drivers/video/xylon/xylonfb/xylonfb-pixclk.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,21 +0,0 @@
-/*
- * Xylon logiCVC frame buffer driver pixel clock generation declarations
- *
- * Author: Xylon d.o.o.
- * e-mail: davor.joja@logicbricks.com
- *
- * 2012 (c) Xylon d.o.o.
- *
- * This file is licensed under the terms of the GNU General Public License
- * version 2.  This program is licensed "as is" without any warranty of any
- * kind, whether express or implied.
- */
-
-#ifndef	__XYLON_FB_PIXCLK_H__
-#define __XYLON_FB_PIXCLK_H__
-
-
-int pixclk_set(struct fb_info *fbi);
-inline int pixclk_change(struct fb_info *fbi);
-
-#endif /* __XYLON_FB_PIXCLK_H__ */
diff -uNr linux-xlnx//drivers/video/xylon/xylonfb/xylonfb-vmode.c linux-xlnx_xfb_14.1_build3//drivers/video/xylon/xylonfb/xylonfb-vmode.c
--- linux-xlnx//drivers/video/xylon/xylonfb/xylonfb-vmode.c	2012-05-15 03:09:09.000000000 +0200
+++ linux-xlnx_xfb_14.1_build3//drivers/video/xylon/xylonfb/xylonfb-vmode.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,156 +0,0 @@
-/*
- * Xylon logiCVC supported video modes
- *
- * Author: Xylon d.o.o.
- * e-mail: davor.joja@logicbricks.com
- *
- * 2012 (c) Xylon d.o.o.
- *
- * This file is licensed under the terms of the GNU General Public License
- * version 2.  This program is licensed "as is" without any warranty of any
- * kind, whether express or implied.
- */
-
-/*
- * This file implements hw dependent functionality for controlling pixel clock generation.
- */
-
-
-#include <linux/fb.h>
-#include "xylonfb-vmode.h"
-
-
-struct xylonfb_vmode_params xylonfb_vmode = {
-#if ((VIDEO_MODE == VESA_640x480_8) || \
-	 (VIDEO_MODE == VESA_640x480_16) || \
-	 (VIDEO_MODE == VESA_640x480_32))
-	.fb_vmode = {
-		.refresh      = 60,
-		.xres         = 640,
-		.yres         = 480,
-		.pixclock     = KHZ2PICOS(25152),
-		.left_margin  = 48,
-		.right_margin = 16,
-		.upper_margin = 31,
-		.lower_margin = 11,
-		.hsync_len    = 96,
-		.vsync_len    = 2,
-		.vmode        = FB_VMODE_NONINTERLACED
-	},
-	.name = "VGA",
-#endif /* #if (VIDEO_MODE == VESA_640x480_ ...) */
-
-#if ((VIDEO_MODE == VESA_800x600_8) || \
-	 (VIDEO_MODE == VESA_800x600_16) || \
-	 (VIDEO_MODE == VESA_800x600_32))
-	.fb_vmode = {
-		.refresh      = 60,
-		.xres         = 800,
-		.yres         = 600,
-		.pixclock     = KHZ2PICOS(39790),
-		.left_margin  = 88,
-		.right_margin = 40,
-		.upper_margin = 23,
-		.lower_margin = 1,
-		.hsync_len    = 128,
-		.vsync_len    = 4,
-		.vmode        = FB_VMODE_NONINTERLACED
-	},
-	.name = "SVGA",
-#endif /* #if (VIDEO_MODE == VESA_800x600_ ...) */
-
-#if ((VIDEO_MODE == VESA_1024x768_8) || \
-	 (VIDEO_MODE == VESA_1024x768_16) || \
-	 (VIDEO_MODE == VESA_1024x768_32))
-	.fb_vmode = {
-		.refresh      = 60,
-		.xres         = 1024,
-		.yres         = 768,
-		.pixclock     = KHZ2PICOS(65076),
-		.left_margin  = 160,
-		.right_margin = 24,
-		.upper_margin = 29,
-		.lower_margin = 3,
-		.hsync_len    = 136,
-		.vsync_len    = 6,
-		.vmode        = FB_VMODE_NONINTERLACED
-	},
-	.name = "XGA",
-#endif /* #if (VIDEO_MODE == VESA_1024x768_ ...) */
-
-#if ((VIDEO_MODE == VESA_1280x720_8) || \
-	 (VIDEO_MODE == VESA_1280x720_16) || \
-	 (VIDEO_MODE == VESA_1280x720_32))
-	.fb_vmode = {
-		.refresh      = 60,
-		.xres         = 1280,
-		.yres         = 720,
-		.pixclock     = KHZ2PICOS(74250),
-		.left_margin  = 220,
-		.right_margin = 110,
-		.upper_margin = 20,
-		.lower_margin = 5,
-		.hsync_len    = 40,
-		.vsync_len    = 5,
-		.vmode        = FB_VMODE_NONINTERLACED
-	},
-	.name = "HD720",
-#endif /* #if (VIDEO_MODE == VESA_1280x720_ ...) */
-
-#if ((VIDEO_MODE == VESA_1280x1024_8) || \
-	 (VIDEO_MODE == VESA_1280x1024_16) || \
-	 (VIDEO_MODE == VESA_1280x1024_32))
-	.fb_vmode = {
-		.refresh      = 60,
-		.xres         = 1280,
-		.yres         = 1024,
-		.pixclock     = KHZ2PICOS(107964),
-		.left_margin  = 248,
-		.right_margin = 48,
-		.upper_margin = 38,
-		.lower_margin = 1,
-		.hsync_len    = 112,
-		.vsync_len    = 3,
-		.vmode        = FB_VMODE_NONINTERLACED
-	},
-	.name = "SXGA",
-#endif /* #if (VIDEO_MODE == VESA_1280x1024_ ...) */
-
-#if ((VIDEO_MODE == VESA_1680x1050_8) || \
-	 (VIDEO_MODE == VESA_1680x1050_16) || \
-	 (VIDEO_MODE == VESA_1680x1050_32))
-	.fb_vmode = {
-		.refresh      = 60,
-		.xres         = 1680,
-		.yres         = 1050,
-		.pixclock     = KHZ2PICOS(146361),
-		.left_margin  = 280,
-		.right_margin = 104,
-		.upper_margin = 30,
-		.lower_margin = 3,
-		.hsync_len    = 176,
-		.vsync_len    = 6,
-		.vmode        = FB_VMODE_NONINTERLACED
-	},
-	.name = "WSXVGA+",
-#endif /* #if (VIDEO_MODE == VESA_1680x1050_ ...) */
-
-#if ((VIDEO_MODE == VESA_1920x1080_8) || \
-	 (VIDEO_MODE == VESA_1920x1080_16) || \
-	 (VIDEO_MODE == VESA_1920x1080_32))
-	.fb_vmode = {
-		.refresh      = 60,
-		.xres         = 1920,
-		.yres         = 1080,
-		.pixclock     = KHZ2PICOS(148500),
-		.left_margin  = 148,
-		.right_margin = 88,
-		.upper_margin = 36,
-		.lower_margin = 4,
-		.hsync_len    = 44,
-		.vsync_len    = 5,
-		.vmode        = FB_VMODE_NONINTERLACED
-	},
-	.name = "HD1080",
-#endif /* #if (VIDEO_MODE == VESA_1920x1080_ ...) */
-};
diff -uNr linux-xlnx//drivers/video/xylon/xylonfb/xylonfb-vmode.h linux-xlnx_xfb_14.1_build3//drivers/video/xylon/xylonfb/xylonfb-vmode.h
--- linux-xlnx//drivers/video/xylon/xylonfb/xylonfb-vmode.h	2012-05-15 03:09:09.000000000 +0200
+++ linux-xlnx_xfb_14.1_build3//drivers/video/xylon/xylonfb/xylonfb-vmode.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,101 +0,0 @@
-/*
- * Xylon logiCVC supported video modes definitions
- *
- * Author: Xylon d.o.o.
- * e-mail: davor.joja@logicbricks.com
- *
- * 2012 (c) Xylon d.o.o.
- *
- * This file is licensed under the terms of the GNU General Public License
- * version 2.  This program is licensed "as is" without any warranty of any
- * kind, whether express or implied.
- */
-
-#ifndef	__VIDEOMODES_H__
-#define __VIDEOMODES_H__
-
-
-#include <linux/types.h>
-
-
-/* Supported_video_modes */
-#define XYLONFB_VM_VESA_640x480_8    (0x101+0x200)
-#define XYLONFB_VM_VESA_640x480_16   (0x111+0x200)
-#define XYLONFB_VM_VESA_640x480_32   (0x112+0x200)
-#define XYLONFB_VM_VESA_800x600_8    (0x103+0x200)
-#define XYLONFB_VM_VESA_800x600_16   (0x114+0x200)
-#define XYLONFB_VM_VESA_800x600_32   (0x115+0x200)
-#define XYLONFB_VM_VESA_1024x768_8   (0x105+0x200)
-#define XYLONFB_VM_VESA_1024x768_16  (0x117+0x200)
-#define XYLONFB_VM_VESA_1024x768_32  (0x118+0x200)
-#define XYLONFB_VM_VESA_1280x720_8    0
-#define XYLONFB_VM_VESA_1280x720_16   0
-#define XYLONFB_VM_VESA_1280x720_32   0
-#define XYLONFB_VM_VESA_1280x1024_8  (0x107+0x200)
-#define XYLONFB_VM_VESA_1280x1024_16 (0x11A+0x200)
-#define XYLONFB_VM_VESA_1280x1024_32 (0x11B+0x200)
-#define XYLONFB_VM_VESA_1680x1050_8   0
-#define XYLONFB_VM_VESA_1680x1050_16  0
-#define XYLONFB_VM_VESA_1680x1050_32  0
-#define XYLONFB_VM_VESA_1920x1080_8   0
-#define XYLONFB_VM_VESA_1920x1080_16  0
-#define XYLONFB_VM_VESA_1920x1080_32  0
-
-#define VESA_640x480_8    1
-#define VESA_640x480_16   2
-#define VESA_640x480_32   3
-#define VESA_800x600_8    4
-#define VESA_800x600_16   5
-#define VESA_800x600_32   6
-#define VESA_1024x768_8   7
-#define VESA_1024x768_16  8
-#define VESA_1024x768_32  9
-#define VESA_1280x720_8   10
-#define VESA_1280x720_16  11
-#define VESA_1280x720_32  12
-#define VESA_1280x1024_8  13
-#define VESA_1280x1024_16 14
-#define VESA_1280x1024_32 15
-#define VESA_1680x1050_8  16
-#define VESA_1680x1050_16 17
-#define VESA_1680x1050_32 18
-#define VESA_1920x1080_8  19
-#define VESA_1920x1080_16 20
-#define VESA_1920x1080_32 21
-
-/* Choose FB driver default video resolution
-   which will be set at driver initialization */
-//#define VIDEO_MODE VESA_640x480_8
-//#define VIDEO_MODE VESA_640x480_16
-#define VIDEO_MODE VESA_640x480_32
-//#define VIDEO_MODE VESA_800x600_8
-//#define VIDEO_MODE VESA_800x600_16
-//#define VIDEO_MODE VESA_800x600_32
-//#define VIDEO_MODE VESA_1024x768_8
-//#define VIDEO_MODE VESA_1024x768_16
-//#define VIDEO_MODE VESA_1024x768_32
-//#define VIDEO_MODE VESA_1280x720_8
-//#define VIDEO_MODE VESA_1280x720_16
-//#define VIDEO_MODE VESA_1280x720_32
-//#define VIDEO_MODE VESA_1280x1024_8
-//#define VIDEO_MODE VESA_1280x1024_16
-//#define VIDEO_MODE VESA_1280x1024_32
-//#define VIDEO_MODE VESA_1680x1050_8
-//#define VIDEO_MODE VESA_1680x1050_16
-//#define VIDEO_MODE VESA_1680x1050_32
-//#define VIDEO_MODE VESA_1920x1080_8
-//#define VIDEO_MODE VESA_1920x1080_16
-//#define VIDEO_MODE VESA_1920x1080_32
-
-/*
-    Structure contains detailed data about
-    the particular display or standard VGA resolution type.
- */
-struct xylonfb_vmode_params
-{
-	u32 ctrl_reg;
-	struct fb_videomode fb_vmode;	/* Video mode parameters */
-	char name[10];					/* Video mode name */
-};
-
-#endif /* __VIDEOMODES_H__ */
diff -uNr linux-xlnx//include/linux/i2c/adv7511.h linux-xlnx_xfb_14.1_build3//include/linux/i2c/adv7511.h
--- linux-xlnx//include/linux/i2c/adv7511.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-xlnx_xfb_14.1_build3//include/linux/i2c/adv7511.h	2012-07-09 17:28:49.033347000 +0200
@@ -0,0 +1,35 @@
+/*
+ * adv7511.h - Configuration for adv7511 misc driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation (version 2 of the License only).
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __LINUX_ADV7511_H
+#define __LINUX_ADV7511_H
+
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/i2c.h>
+
+#define ADV7511_UNDEFINED 0
+#define ADV7511_RGB       1
+#define ADV7511_YCbCr     2
+
+#define FORMAT_NAME_SZ (5+1)
+
+struct adv7511_platform_data {
+	char format[FORMAT_NAME_SZ];
+};
+
+struct i2c_client *adv7511_get_client(void);
+int adv7511_get_format(struct device *dev);
+int adv7511_set_format(struct device *dev, int type);
+
+#endif /* __LINUX_ADV7511_H */
diff -uNr linux-xlnx//include/linux/i2c/si570.h linux-xlnx_xfb_14.1_build3//include/linux/i2c/si570.h
--- linux-xlnx//include/linux/i2c/si570.h	2012-05-15 03:09:09.000000000 +0200
+++ linux-xlnx_xfb_14.1_build3//include/linux/i2c/si570.h	2012-07-09 13:37:17.578221123 +0200
@@ -15,6 +15,8 @@
 #define __LINUX_SI570_H
 
 #include <linux/types.h>
+#include <linux/device.h>
+#include <linux/i2c.h>
 
 struct si570_platform_data {
 	u64 factory_fout;		/* Factory default output frequency */
@@ -23,7 +25,7 @@
 
 int get_frequency_si570(struct device *dev, unsigned long *freq);
 int set_frequency_si570(struct device *dev, unsigned long freq);
-void reset_si570(struct device *dev, int id);
+int reset_si570(struct device *dev, int id);
 struct i2c_client *get_i2c_client_si570(void);
 
 #endif /* __LINUX_SI570_H */
diff -uNr linux-xlnx//include/linux/xylonfb.h linux-xlnx_xfb_14.1_build3//include/linux/xylonfb.h
--- linux-xlnx//include/linux/xylonfb.h	2012-05-15 03:09:09.000000000 +0200
+++ linux-xlnx_xfb_14.1_build3//include/linux/xylonfb.h	2012-07-09 13:37:17.582221123 +0200
@@ -1,5 +1,5 @@
 /*
- * Xylon logiCVC frame buffer driver
+ * Xylon logiCVC frame buffer driver IOCTL parameters
  *
  * Author: Xylon d.o.o.
  * e-mail: davor.joja@logicbricks.com
@@ -15,22 +15,59 @@
 #define __XYLON_FB_H__
 
 
-/* Framebuffer driver platform layer structure */
-struct xylonfb_platform_layer_params
-{
-	unsigned long offset;	/* Layer memory offset in lines */
-	unsigned char bpp;		/* Layer bits per pixel */
+#include <linux/types.h>
+
+
+struct xylonfb_layer_color {
+	__u32 raw_rgb;
+	__u8 use_raw;
+	__u8 r;
+	__u8 g;
+	__u8 b;
+};
+
+struct xylonfb_layer_pos_size {
+	__u16 x;
+	__u16 y;
+	__u16 width;
+	__u16 height;
 };
 
-/* Framebuffer driver platform data structure */
-struct xylonfb_platform_data
-{
-	unsigned long vmem_base_addr;	/* Physical starting address of the video memory */
-	unsigned long vmem_high_addr;	/* Physical ending address of the video memory */
-	unsigned int row_stride;		/* Layer row stride in pixels */
-	struct xylonfb_platform_layer_params *layer_params;
-	unsigned char num_layers;
-	unsigned char active_layer;
+struct xylonfb_hw_access {
+	__u32 offset;
+	__u32 value;
 };
 
+
+#define XYLONFB_IOW(num, dtype)  _IOW('x', num, dtype)
+#define XYLONFB_IOR(num, dtype)  _IOR('x', num, dtype)
+#define XYLONFB_IOWR(num, dtype) _IOWR('x', num, dtype)
+#define XYLONFB_IO(num)          _IO('x', num)
+
+#define XYLONFB_GET_LAYER_IDX           XYLONFB_IOR(30, unsigned int)
+#define XYLONFB_GET_LAYER_ALPHA         XYLONFB_IOR(31, unsigned int)
+#define XYLONFB_SET_LAYER_ALPHA         XYLONFB_IOW(32, unsigned int)
+#define XYLONFB_LAYER_COLOR_TRANSP      XYLONFB_IOW(33, unsigned int)
+#define XYLONFB_GET_LAYER_COLOR_TRANSP \
+	XYLONFB_IOR(34, struct xylonfb_layer_color)
+#define XYLONFB_SET_LAYER_COLOR_TRANSP \
+	XYLONFB_IOW(35, struct xylonfb_layer_color)
+#define XYLONFB_GET_LAYER_SIZE_POS \
+	XYLONFB_IOR(36, struct xylonfb_layer_pos_size)
+#define XYLONFB_SET_LAYER_SIZE_POS \
+	XYLONFB_IOW(37, struct xylonfb_layer_pos_size)
+#define XYLONFB_GET_LAYER_BUFFER        XYLONFB_IOR(38, unsigned int)
+#define XYLONFB_SET_LAYER_BUFFER        XYLONFB_IOW(39, unsigned int)
+#define XYLONFB_GET_LAYER_BUFFER_OFFSET XYLONFB_IOR(40, unsigned int)
+#define XYLONFB_GET_LAYER_BUFFERS_NUM   XYLONFB_IOR(41, unsigned int)
+#define XYLONFB_GET_BACKGROUND_COLOR \
+	XYLONFB_IOR(42, struct xylonfb_layer_color)
+#define XYLONFB_SET_BACKGROUND_COLOR \
+	XYLONFB_IOW(43, struct xylonfb_layer_color)
+#define XYLONFB_LAYER_EXT_BUFF_SWITCH   XYLONFB_IOW(43, unsigned int)
+#define XYLONFB_READ_HW_REG \
+	XYLONFB_IOR(44, struct xylonfb_hw_access)
+#define XYLONFB_WRITE_HW_REG \
+	XYLONFB_IOW(45, struct xylonfb_hw_access)
+
 #endif /* __XYLON_FB_H__ */
diff -uNr linux-xlnx//include/linux/xylonfb_platform.h linux-xlnx_xfb_14.1_build3//include/linux/xylonfb_platform.h
--- linux-xlnx//include/linux/xylonfb_platform.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-xlnx_xfb_14.1_build3//include/linux/xylonfb_platform.h	2012-07-09 13:37:17.582221123 +0200
@@ -0,0 +1,58 @@
+/*
+ * Xylon logiCVC frame buffer driver platform data structures
+ *
+ * Author: Xylon d.o.o.
+ * e-mail: davor.joja@logicbricks.com
+ *
+ * 2012 (c) Xylon d.o.o.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#ifndef	__XYLON_FB_PLATFORM_H__
+#define __XYLON_FB_PLATFORM_H__
+
+
+#include <linux/types.h>
+
+
+/* Framebuffer driver platform layer structure */
+struct xylonfb_platform_layer_params
+{
+	/* Layer memory offset in lines */
+	unsigned int offset;
+	/* Layer buffer memory offset in lines */
+	unsigned short buffer_offset;
+	/* Layer bits per pixel */
+	unsigned char bpp;
+	/* Layer alpha mode */
+	unsigned char alpha_mode;
+	/* Layer control register value */
+	unsigned char ctrl;
+};
+
+/* Framebuffer driver platform data structure */
+struct xylonfb_platform_data
+{
+	struct xylonfb_platform_layer_params *layer_params;
+	/* logiCVC Control Register value */
+	u32 ctrl_reg;
+	/* Physical starting address of the video memory */
+	unsigned long vmem_base_addr;
+	/* Physical ending address of the video memory */
+	unsigned long vmem_high_addr;
+	/* Layer row stride in pixels */
+	unsigned short row_stride;
+	/* Number of logiCVC layers */
+	unsigned char num_layers;
+	/* logiCVC layer ID for FB console */
+	unsigned char active_layer;
+	/* Background layer bits per pixel */
+	unsigned char bg_layer_bpp;
+	/* Background layer alpha mode */
+	unsigned char bg_layer_alpha_mode;
+};
+
+#endif /* __XYLON_FB_PLATFORM_H__ */
